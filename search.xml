<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈集成学习]]></title>
    <url>%2F2018%2F05%2F31%2Fensembel-learning%2F</url>
    <content type="text"><![CDATA[1. 集成学习集成学习(ensenble learning)是指通过构建并结合多个学习器来完成学习任务。一般来说，多个“弱学习器”结合起来的效果往往好于单个强学习器的效果，所以集成学习的应用非常广泛，比如著名的集成树模型系列。 集成学习按照个体学习器是否相同，可以分为同质集成和异质集成。同质集成的个体学习器是相同，比如都是决策树，个体学习器也往往被称为基学习器。异质集成中的个体学习器由不同的学习算法生成，比如不同的分类器(如决策树、lr和svm)投票出最终的结果。 集成学习另一种比较普通的分类方法是根据个体学习器之间的组合方式，一种是串行的方式，称为boosting方法，如Adaboost；一种是并行的方法，称为bagging方法，如随机森林。 1.1 从偏差和方差说起此处所提到的偏差和方差是有一定指代范围的，偏差指的是在训练集上的效果好坏，比如计算的正例的概率都集中在1附近，模型刻画能力较好，那么偏差就较小；方差指的是在不同测试集上的预测效果的浮动程度，比如在不同测试集上正例预测的概率范围都很接近，那么方差就较小。用打靶子来比喻的话，低偏差就是训练的时候每一枪都打到了靶中心周围，而低方差就是不管是训练还是比赛的时候，每次打的位置都比较接近。 偏差相当于刻画了模型在训练集上的效果，方差刻画了模型在不同测试集上的泛化能力，一个欠拟合的模型很明显是偏差大的，一个过拟合的模型很明显是方差大的。 1.2 boostingboosting方法是集成学习中的第一大类别，这类算法的一般工作机制为：先在训练集上训练出一个个体学习器，然后根据个体学习器的在训练集上的效果，重新分配训练样本的权重，比如对错误分类样本增大权重，在此基础上训练新的个体学习器。直到个体学习器的个数达到了目标的个数，停止训练，将n个个体学习器线性加和作为最终的结果。boosting是一种串行的集成学习算法，主要的目的是降低偏差。 前向分步算法我们考虑一个加法模型，在我们训练了很多基学习器以后，使用线性相加的形式作为最后的模型。 f(x) = \sum_{m=1}^M\beta_mb(x;\gamma_m)$f(x)$是最终的模型，$\beta_m$是每个基学习器的权重，$b(x;\gamma_m)$是基学习器，$\gamma_m$是基学习器的参数。 在给定损失函数$L(yi, \sum{m=1}^Mb(x_i;\gamma_m))$的条件下，即转换为极小化损失函数的问题： \mathop{min}\limits_{\gamma_m, \beta_m} L(y, \sum_{m=1}^M\beta_mb(x;\gamma_m))这种情况非常难以求解，于是，可以转换为从前到后每次求解一个基学习器的权值和参数。 具体算法 输入：训练数据集 $((x_1, y_1),…,(x_n, y_n))$，损失函数 $L(y, f(x))$，基学习器 $b(x, \gamma)$ 输出：学习器 $f(x)$ 初始化 $f_0(x) = 0$ 对0,…,M 更新 f_m(x) = f_{m-1} + \beta_mb(x;\gamma_m) 极小化损失函数 (\gamma_m, \beta_m) = \mathop{argmin}\limits_{\gamma_m, \beta_m} L(y, f_{m-1}(x) + \beta_mb(x;\gamma_m)) 得到加法模型 Adaboost我对于Adaboost算法的理解，就是从前向分步算法推导出来的，所以此处给出前向分步算法推导出Adaboost算法。 算法最终的分类器为 f(x) = \sum_{m=1}^M \alpha_mG_m(x)损失函数是指数损失 L(y, f(x)) = exp(-yf(x))根据前向分布算法 \begin{align*} (G(x), \alpha_m) &= \mathop{argmin}\limits_{G(x), \alpha_m} \sum_iL(y_i, f_{m-1}(x_i) + \alpha_mG(x_i)) \\ &= \mathop{argmin}\limits_{G(x), \alpha_m} \sum_iexp(-y_if_{m-1}(x_i)-y_i\alpha_mG(x_i)) \\ &= \mathop{argmin}\limits_{G(x), \alpha_m} \sum_iw_{mi}exp(-y_i\alpha_mG(x_i)) \end{align*}其中 $w{mi} = exp(-y_if{m-1}(_i))$，可以认为是每个样本的权重。 下面求解$\alpha_m$ \begin{align*} \sum_{i=1}^N w_{mi}exp(-y_i\alpha G(x_i)) &= \sum_{y_i=G(x_i)}e^{-\alpha} + \sum_{y_i!=G(x_i)}e^{\alpha} \\ &= (e^\alpha - e^{-\alpha})\sum_{i=1}^Nw_{mi}I(y_i\neq G(x_i)) +e^{-\alpha}\sum_{i=1}^Nw_{mi} \end{align*}求导，令导数为0得到 \alpha_m = \frac{1}{2}log\frac{1-e_m}{e_m}其中 e_m = \frac{\sum_{i=1}^Nw_{mi}I(y_i\neq G(x_i)) }{\sum_{i=1}^Nw_{mi}}所以，我们可以算得下一个基分类器训练时每个样本的权重，以及该基分类器在最终的模型中所占的权重，这样就得到了完整的Adaboost的算法形式。 下面具体详细地阐述Adaboost算法 模型为加法模型、损失函数为指数损失函数、学习算法为前向分布算法的学习方法 最终的分类器 $f(x) = \sum_{m=1}^M\alpha_mG_m(x)$ 涉及到两个主要问题 $\alpha_m$：每个基分类器的权值是多少 $w_{mi}$：每个基分类器训练时，各个训练样本的权值是多少 一旦有了这两个参数，可以计算loss，进行训练，同时计算下一个训练样本的权值分布 过程 第m个分类器的分类误差率 e_m = \sum_{i=1}^Nw_{mi}I(y_i\neq G_m(x_i)) 第m个分类器的loss \sum_{i=1}^Nw_{mi}exp[-y_i\alpha_m G(x_i)] 对loss求导可以得到 \alpha_m = \frac{1}{2}log\frac{1-e_m}{e_m} 当 e_m \leq \frac{1}{2} 时，em越小 \alpha_m 的权值越大 训练样本权值更新 w_{m+1, i} = \frac{w_{mi}}{Z_m}exp(-\alpha_my_iG_m(x_i)) 如果分类正确，则减小样本的权值 如果分类错误，则增大样本的权值 继续如上过程训练 1.3 baggingbagging是集成学习中的第二大类方法，是并行式集成学习的代表。bagging方法的基础是自助采样法(bootstrap sampling)，我们从样本中抽取一个样本，再把该样本放回原训练集中，再进行第二次采样。根据此方法可以采样得到一个容量为m的子训练样本，原训练样本中有些在子训练样本中从未出现过，有些会重复出现。我们采样出T个这样的容量为m的子训练样本，通过T次的子训练样本可以训练得到T个基分类器。最后T个基分类器结合得到最终的结果(比如投票法)。当我们想得到泛化能力强的集成模型，我们希望每个基分类器尽量独立，也就是具有差异性。通过bagging方法得到的T的基分类器因为训练样本的差异性，模型本身也具有差异性，所以集成以后效果会比较好。 random forest随机森林是bagging的一个变体，随机森林在以决策树为基础构建bagging集成学习的基础上，在决策树的训练过程中引入了随机属性选择。 具体地，随机森林的基分类器是决策树，每个基分类器的训练样本来自于bagging方法的采样。同时，在每个基分类器的训练过程中，还会随机选择k个属性作为当前基分类器的划分属性集合。这样，对于每个基分类器来说，不仅训练样本不同，用于划分的属性集合也不同，增加了每个基分类器之间的差异性，同时，因为每次不需要考虑所有的属性，计算量减少了，提高了训练效率。 1.4 两种集成方法对比boosting方法和bagging方法的区别主要体现在两个方面： 一个是体现在每个基分类器的组合形式上，前者是串行，后者是并行。串行的方式，必须得等待前面的基分类器训练完，基于该分类器的结果才可以训练下一个基分类器，和循环神经网络类似，不能进行并行计算提高效率；并行的bagging方法因为每个基分类器之间的训练之间没有相互依赖关系，所以可以进行并行计算提高效率。 另一个方面是两种方法主要的效果上，前者是主要降低偏差，后者主要降低方差。boosting方法希望在训练集上的误差越小越好，每次的基分类器都是以降低偏差为目标；bagging方法训练样本是有差异的或者因为特征子集也不尽相同，所以每个基分类器是有差异的，这些有差异的基分类器相当于模拟了在不同测试集上的表现，基分类器之间会相互弥补，达到降低方差的效果。 2. 典型的集成树模型2.1 gradient boost对于前向分步算法，一个比较关键的问题是，在优化求解m个基学习器时，优化目标是什么。当计算使用指数损失函数作为loss的分类问题时，每个基学习器的优化目标很容易地进行求解，此时就是Adaboost算法；当计算使用平方误差损失作为loss的回归问题时，每个基学习器的优化目标同样很容易求解，就是boosting tree的形式，此时可以直接化解为残差的形式，即每个基学习器优化的是上一个基学习器和目标的残差。 此处可以证明一下平方损失函数作为loss时残差优化目标的推导： L(y, f_{m-1}(x) + \beta_mb(x;\gamma_m)) = (y - f_{m-1}(x) - \beta_mb(x;\gamma_m))^2 = (r - \beta_mb(x;\gamma_m))^2其中 $r = y - f_{m-1}(x)$即为残差形式。 接下来，对于除了以上的两种情况以外的一般损失函数来说，每一步的优化目标并不容易确定，所以，提出了每次的优化目标是损失函数的负梯度在当前模型的值。即优化 -[\frac{\partial L(y, f(x_i))}{\partial f(x_i)}]_{f(x) = f_{m-1}(x)}2.2 GBDTGBDT全称是gradient boosting decision tree。使用的是gradient boosting方法，基学习器是CART树。 对于GBDT回归算法，和上面gradient boosting方法完全类似，基学习器时CART树，使用的loss是平方损失，所以每一个基学习器的优化目标是上一个CART树与优化目标的残差。 比如，我们要用GBDT预测人的年龄，目标是30岁。那么，第一个树的目标是30岁，如果预测的值是20岁，那么第二个树的目标则为30-20=10岁，依次类推下去。 2.3 xgboost计划看一下陈天奇的论文再做进一步总结。 xgboost和GBDT的主要不同体现在优化的目标上，GBDT优化的是梯度，相当于是一阶导数，而xgboost对loss进行了二阶泰勒展开，同时加上了正则化项作为优化目标，正则化项包括叶子节点个数以及叶子节点输出值的L2值。 3. 典型集成模型对比rf、GBDT、xgboost、lightGBM random forest 优点 训练速度、准确率都较好 能够处理高维数据，不用进行特征筛选，训练后能看到特征的重要性 可以进行并行训练 缺点 在噪声大的训练数据上容易过拟合 GBDT 优点 灵活处理各种数据 较少调参时间内准确度较高 缺点 boosting方法，串行，难以并行训练 xgboost和GBDT GBDT是基学习器是回归树，而xgboost支持线性分类器 GBDT的优化目标只利用了一阶导数，而xgboost利用了一阶导数和二阶导数 shrinkage。在每个基分类器计算完后，会将叶子节点权值乘以一个参数，为了削弱每颗树的影响，为了让后面有更大的学习空间 xgboost加入了正则化项，防止了过拟合 列抽样，和随机森林一样支持列抽样，防止过拟合，减少计算 缺失值的处理 xgboost进行了并行计算，在特征选择的过程中用了排序方法 为什么rf需要设置树的深度较深，而xgboost并不需要 rf是bagging方法，主要是降低方差，所以希望单个模型偏差较低，所以倾向于偏差低的单个模型 xgboost是boosting方法，主要是为了降低偏差，所以希望单个模型方差较低，方差较低就希望单个模型不要太复杂，所以倾向于树的深度浅一些。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈逻辑回归]]></title>
    <url>%2F2018%2F05%2F15%2Flogistic-regression%2F</url>
    <content type="text"><![CDATA[从线性回归说起 线性回归 $y = w^Tx + b$ x表示n维的特征向量，通过线性相加得到y值，可以使用使用最小二乘求解。 逻辑回归与线性回归的联系与区别 对数几率角度理解 逻辑回归是，通过线性回归的方法去预测对数几率，即：$ln\frac{y}{1-y} = w^Tx+b$ 求解得到 $y = \frac{1}{e^{-(w^Tx+b)}+1}$ 线性回归形式预测的是几率大小，逻辑回归将可能性大小映射到0-1之间 将 $y = w^Tx + b$ 认为y是预测的对数几率的大小，经过一个sigmoid将对数几率变为0-1之间。 也就是说sigmoid将对数几率变为了y的概率 逻辑回归与线性可分 逻辑回归从线性回归来，这个线性回归预测的结果是对数几率，大于0是为正例，小于0时为负例，本质上没有改变线性分类超平面（$y = w^Tx + b$ 构成的超平面）。 通过构造特征，映射到高维，映射到高维的线性可分。 逻辑回归的公式推导 loss 使用的是神奇的负的对数似然作为loss $J = -\frac{1}{m}\sum_i (y_iln(h(w^Tx^i) + (1-y_i)ln(1-h(w^Tx^i)))$ 对应的是二分类形式的交叉熵 梯度下降公式推导 补充 $\sigma’(x) = \sigma(x)(1-\sigma(x))$ $(1-\sigma(x))’ = -\sigma’(x)(1-\sigma(x))$ 令$\theta_i = y_iln(h(w^Tx^i) + (1-y_i)ln(1-h(w^Tx^i) $ \begin{align*} \frac{\partial J}{\partial w_j} &= -\frac{1}{m}\sum_i\frac{\partial \theta_i}{\partial w_j} \\ \frac{\partial \theta_i}{\partial w_j} &= y_i\frac{1}{h(w^Tx^i)}h’ (w^Tx^i)x_j^i + (1-y_i)\frac{1}{1-h(w^Tx^i)}(-h'(w^Tx^i))x_j^i \\ &= y_i\frac{1}{h(w^Tx^i)}h (w^Tx^i)(1-h(w^Tx^i))x_j^i + (1-y_i)\frac{1}{1-h(w^Tx^i)}(h(w^Tx^i)(h (w^Tx^i)-1))x_j^i \\ &=(y_i-h(w^Tx^i))x_j^i \\ \frac{\partial J}{\partial w_j} &= -\frac{1}{m}\sum_i\frac{\partial \theta_i}{\partial w_j} = -\frac{1}{m}\sum_i(y_i-h(w^Tx^i))x_j^i \\ \end{align*} 在此基础上，根据梯度下降公式 w_j = w_j - \alpha \frac{\partial J}{\partial w_j} 逻辑回归的正则化 l1和l2 L1：$||w||_1 = (\sum_i |w_i|)$ L2: $||w||_2 = \sqrt(\sum_iw_i^2)$ l1和l2的区别以及为什么 l1会使得参数变得稀疏，l2会使得参数变得更接近0 最终的loss为：$J = loss + ||w||_p$ 图形解释 一圈一圈的是loss的等高线(loss值)，方形和圆形分别是l1和l2的等高线，基于梯度下降思想，需要更加接近圆心，才会loss更小。 对于l1来说，弧形会最先与轴上的点相交，对于l2来说，因为是圆弧，所以会先与圆相切 那么结论就出来了，与轴上点相交时，w1的值就为零了，而与圆弧相交则使得w1和w2变得较小。 可能loss的等高线并不是弧形，这点其实需要思考，该部分不够严谨，对于l1的图来说，其实是存在与弧线相切的线的，比如在靠近圆心的位置，此时，w1和w2并不为零，所以可能理解有偏差，仅供参考 从参数更新公式理解 参数更新公式为 $w = w - \alpha \frac{\partial J}{\partial w}$ $\alpha$是学习率，偏导项是梯度，可以分为两个部分，一个部分是原本的loss，一个部分是正则化项的梯度。对于l1和l2正则来说，前半部分都是相同的，只有后半部分不一样 对于l1正则化来说， ​ ​ \begin{align*} \frac{\partial ||w||_1}{\partial w} &= 1 \ \ if \ w > 0 \\ \frac{\partial ||w||_1}{\partial w} &= -1 \ \ if \ w < 0 \end{align*} 根据参数更新公式$w = w - \alpha \frac{\partial J}{\partial w}$，当w大于0时，正则化项的梯度为1，会使w往0的方向靠近，当w小于0时，正则化项的梯度为-1，同样会使得w往0的方向靠近，直至为0 对于l2正则化来说 \frac{\partial ||w||_2}{\partial w} = 2w 同样根据参数更新公式$w = w - \alpha \frac{\partial J}{\partial w}$，$w = (1 - 2\alpha)w $ ，在原有w基础上乘以一个系数，会使得w接近于0，而不是变为0 逻辑回归与极大似然估计本质上来说，逻辑回归就是极大似然估计。因为逻辑回归的损失函数是负的对数似然函数，本质上的优化，也是使得对数似然函数尽可能大，也就是极大似然法的思想。 逻辑回归与最大熵模型逻辑回归可以认为是特殊形式的最大熵模型。 逻辑回归 \begin{align*} P(y=1|x) &= \frac{1}{e^{-w^Tx+b}+1} \\ P(y=0|x) &= \frac{e^{-w^Tx+b}}{e^{-w^Tx+b}+1} \end{align*}最大熵模型 \begin{align*} P(y|x) &= \frac{1}{Z(x)} \times e^{\sum_iw_if_i(x,y)} \\ Z(x) &= \sum_y e^{\sum_iw_if_i(x,y)} \end{align*}如果令 \begin{equation} f_i(x, y)=\left\{ \begin{aligned} & -x_i & y = 1 \\ & 0 & y = 0 \end{aligned} \right. \end{equation}则可以由最大熵模型推导得到 \begin{align*} P(y=0|x) &= \frac{1}{Z(x)} \times e^{\sum_iw_if_i(x,0)} = \frac{1}{e^{\sum_iw_if_i(x,0)}+ e^{\sum_iw_if_i(x,1)}} = \frac{1}{1+e^{-w^Tx}}\\ P(y=1|x) &= \frac{1}{Z(x)} \times e^{\sum_iw_if_i(x,y)} = \frac{e^{\sum_iw_if_i(x,1)}}{e^{\sum_iw_if_i(x,1)}+ e^{\sum_iw_if_i(x,1)}} = \frac{e^{-w^Tx}}{1+e^{-w^Tx}}\\ \end{align*}根据上面的推导，我们可以得到逻辑回归的形式，也就是特殊形式的最大熵模型(特征函数以及y是特征的) 特征交叉和特征离散化逻辑回归只能解决线性可分问题，所以对于一个现实问题，要想取得比较好的效果，一般会进行特征交叉以及特征离散化。特征离散化是将连续特征(离散特征也可以)的每个特征值都变为一维，类似变成了ont-hot向量。 特征交叉是指某些特征之间是具有联系的，有时候可以将特征与特征联合进行考虑，即交叉得到新的特征。具体见fm和ffm算法。 具体特征交叉和离散化在CTR中的应用 逻辑回归的优缺点没有找到详细的解释，有大概几点，有详细解释再补充吧。 优点 计算快 结果是概率形式，可以知道可能性大小 可以并行化计算，工业上用的比较多 缺点 容易欠拟合，分类或者回归的精度不高 特征空间大效果不好]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2018%2F05%2F08%2Fleetcode%2F</url>
    <content type="text"><![CDATA[LinkedList链表翻转、两个链表代表的数求和（两种形式）、找到链表的倒数第k个节点（删除链表的倒数第k个节点） 445. Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: 12Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 题目大意 给定两个非空的链表，链表的每个节点代表非负整数的一位，链表的靠前的位置代表着高位。返回两个链表所代表的数相加的结果，结果以链表形式返回。 如果不能改变输入的链表即不能翻转链表该如何操作。 思路 翻转链表，按顺序加起来，然后构造链表即可；(但是题目要求不允许改变链表)； 空间换时间，遍历两个链表用数组存起来，使用数组相加，同时生成结果链表，生成结果链表的时候可以逆序直接生成结果链表； 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; vector&lt;int&gt; vec1, vec2, vec3; ListNode *res = NULL, *p = NULL; while (l1 != NULL)&#123; vec1.push_back(l1-&gt;val); l1 = l1-&gt;next; &#125; while (l2 != NULL)&#123; vec2.push_back(l2-&gt;val); l2 = l2-&gt;next; &#125; int len1 = vec1.size(), len2 = vec2.size(), c = 0; for (int i=len1-1, j=len2-1; i&gt;=0 || j&gt;=0 || c &gt; 0; --i, --j)&#123; int sum = c; if (i &gt;= 0) sum += vec1[i]; if (j &gt;= 0) sum += vec2[j]; c = sum / 10; p = new ListNode(sum % 10); p-&gt;next = res; res = p; &#125; return res; &#125;&#125;; 翻转链表，熟悉下链表翻转 123456789101112131415161718192021222324252627282930313233343536373839// reverse the linked listclass Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *l1_r = reverse(l1); ListNode *l2_r = reverse(l2); int c = 0; ListNode *res = NULL, *p = NULL; while ((l1_r!=NULL) || (l2_r!=NULL) || c&gt;0)&#123; int sum = c; if (l1_r != NULL) &#123; sum += l1_r-&gt;val; l1_r = l1_r-&gt;next; &#125; if (l2_r != NULL) &#123; sum += l2_r-&gt;val; l2_r = l2_r-&gt;next; &#125; c = sum / 10; p = new ListNode(sum % 10); p-&gt;next = res; res = p; &#125; return res; &#125; ListNode* reverse(ListNode* node)&#123; if (node == NULL || node-&gt;next == NULL) return node; ListNode *p = NULL, *q = node; while (q != NULL)&#123; ListNode *tmp = q-&gt;next; q-&gt;next = p; p = q; q = tmp; &#125; return p; &#125; &#125;; 2.Add Two Numbers题目大意 用一个链表给出一个非负数，链表的头是数的低位，尾部是高位，求两个链表所代表数的和的链表形式。 思路 比445简单多了，直接遍历链表相加，返回即可。 考虑 如果是有符号数，得考虑大小再做减法 代码 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *head, *p, *q; head = new ListNode(0); p = head; int sum = 0, carry = 0; while (l1 || l2 || carry)&#123; sum =carry; if (l1)&#123; sum += l1-&gt;val; l1 = l1-&gt;next; &#125; if (l2)&#123; sum += l2-&gt;val; l2 = l2-&gt;next; &#125; carry = sum / 10; sum = sum % 10; p-&gt;next = new ListNode(sum); p = p-&gt;next; &#125; /* if (!head-&gt;next || !head-&gt;next-&gt;next) return head-&gt;next; p = NULL; q = head-&gt;next; delete head; while (q)&#123; ListNode* tmp = q-&gt;next; q-&gt;next = p; p = q; q = tmp; &#125; return p; */ return head-&gt;next; &#125;&#125;; 19.Remove Nth Node From End of List题目大意 删除链表的倒数第n个节点 思路 使用双指针法，第一个指针访问第n个节点，然后同时移动两个指针，当第一个指针到达尾部时，第二个指针指向的就是倒数第n个节点。 需要考虑边界条件 head节点为空 n大于链表节点数目 当链表只有一个节点且需要删除当前节点的情况(有指向head的头结点时会更好处理) 使用一个指向head的头节点会比较好处理一些。 代码 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 考虑head为空 if (!head) return head; ListNode *bak, *low = head, *fast = head; for (int i=0; i&lt;n; ++i)&#123; if (!fast) return head; fast = fast-&gt;next; &#125; if (fast == NULL)&#123; bak = head-&gt;next; delete head; return bak; &#125; while(fast-&gt;next)&#123; fast = fast-&gt;next; low = low-&gt;next; &#125; fast = low-&gt;next; low-&gt;next = low-&gt;next-&gt;next; delete fast; return head; &#125;&#125;; 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 考虑head为空 if (!head) return head; ListNode *pre; pre = new ListNode(0); pre-&gt;next = head; ListNode *low = pre, *fast = pre; for (int i=0; i!=n; ++i)&#123; // 考虑n超过范围 if (!fast) return head; fast = fast-&gt;next; &#125; // fast肯定不会为空，只是保险 while (fast &amp;&amp; fast-&gt;next)&#123; low = low-&gt;next; fast = fast-&gt;next; &#125; fast = low-&gt;next; low-&gt;next = low-&gt;next-&gt;next; // 记得释放删除节点的内存 delete fast; low = pre-&gt;next; delete pre; return low; &#125;&#125;; 92.Reverse Linked List II题目大意 给定一个单链表，翻转m到n的位置，链表从1开始标号。要求in-place and one-pass。 思路 使用额外空间： fast指针先指到m位置，遍历到n，将值push到栈中； low从m位置开始，依次将栈中值pop出来存储到对应的节点位置 直接操作 pre指向(m-1)位置，pStart指向m位置，那么依次开始逆序 tmp = pStart-&gt;next; pStart-&gt;next = tmp-&gt;next; tmp-&gt;next = pre-&gt;next; pre-&gt;next = tmp; 代码 12345678910111213141516171819202122class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (head == NULL) return head; ListNode preHead(0); ListNode *pre = &amp;preHead; pre-&gt;next = head; ListNode *p=pre, *pstart=NULL, *t=NULL; for (int i=0; i&lt;m-1; ++i) p = p-&gt;next; pstart = p-&gt;next; for (int i=0; i&lt;n-m; ++i)&#123; t = pstart-&gt;next; pstart-&gt;next = t-&gt;next; t-&gt;next = p-&gt;next; p-&gt;next = t; &#125; return pre-&gt;next; &#125;&#125;; 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (!head || !head-&gt;next) return head; n -= m; ListNode *root=NULL, *pre=NULL, *pStart=NULL; ListNode preNode(0); root = &amp;preNode; root-&gt;next = head; pre = root; while (--m)&#123; pre = pre-&gt;next; &#125; pStart = pre-&gt;next; while (n--)&#123; ListNode *t = pStart-&gt;next; pStart-&gt;next = t-&gt;next; t-&gt;next = pre-&gt;next; pre-&gt;next = t; &#125; return root-&gt;next; &#125;&#125;; 21.Merge Two Sorted Lists题目大意 将两条排序好的链表合并，要求返回的新链表的节点是由旧链表而来。 思路 归并排序的思路 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *pre = NULL; ListNode prenode(0); pre = &amp;prenode; ListNode *cur = pre; while (l1 &amp;&amp; l2)&#123; if (l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if (l1)&#123; cur-&gt;next = l1; &#125; if (l2)&#123; cur-&gt;next = l2; &#125; return pre-&gt;next; &#125;&#125;; 23.Merge k Sorted Lists题目大意 合并k条排好序的链表 思路 普通思路 转换为k次两个链表的合并 时间复杂度为$O(k^2n)$ 复杂度为$O(log(k)n)$ 比较k个链表的当前最小值时，使用堆排序维护顺序，这样的话就不需要重复进行排序了 代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode *tmp=NULL; for (int i=0; i!=lists.size(); ++i)&#123; tmp = mergeTwoLists(tmp, lists[i]); &#125; return tmp; &#125;private: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)&#123; if (!l1 &amp;&amp; !l2) return l1; ListNode* pre=NULL; ListNode preHead(0); pre = &amp;preHead; ListNode* head = pre; while (l1 &amp;&amp; l2)&#123; if (l1-&gt;val &gt; l2-&gt;val)&#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125;else &#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; head = head-&gt;next; &#125; if (l1) head-&gt;next = l1; if (l2) head-&gt;next = l2; return pre-&gt;next; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233// priority_queue的比较struct cmp&#123; bool operator()(ListNode* a, ListNode* b)&#123; // 小顶堆 return (a-&gt;val &gt; b-&gt;val); &#125;&#125;;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode *pre=NULL, *cur=NULL, *tmp=NULL; ListNode preHead(0); pre = &amp;preHead; cur = pre; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; q; for (int i=0; i!=lists.size(); ++i)&#123; if (lists[i])&#123; q.push(lists[i]); &#125; &#125; while (!q.empty())&#123; tmp = q.top(); q.pop(); cur-&gt;next = tmp; cur = cur-&gt;next; if (tmp-&gt;next) q.push(tmp-&gt;next); &#125; return pre-&gt;next; &#125;&#125;; 138.Copy List with Random Pointer 题目大意 给定一条带有随机指针的链表，随机指针随机指向链表中的某个节点，要求返回该链表的深拷贝。 思路 1 先对仅仅对链表的普通关系进行复制，同时用一个map存储原来链表节点和复制链表节点的对应关系 再遍历一遍普通链表，对非空的random指针在复制链表中复制，指向的节点有map确定 2 对原有链表复制一个节点插入到当前节点后面 复制random pointer 拆分 代码 1234567891011121314151617181920212223242526class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode* pre=NULL; RandomListNode preHead(0); pre = &amp;preHead; RandomListNode *cur1=head, *cur2 = pre; map&lt;RandomListNode*, RandomListNode*&gt; cache; while (cur1)&#123; cur2-&gt;next = new RandomListNode(cur1-&gt;label); cache[cur1] = cur2-&gt;next; cur1 = cur1-&gt;next; cur2 = cur2-&gt;next; &#125; cur1 = head; cur2 = pre-&gt;next; while (cur1)&#123; if (cur1-&gt;random)&#123; cur2-&gt;random = cache[cur1-&gt;random]; &#125; cur1 = cur1-&gt;next; cur2 = cur2-&gt;next; &#125; return pre-&gt;next; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738// method 2class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; if (!head) return head; RandomListNode *cur = head, *tmp=NULL, *cur1=NULL, *res=NULL; // step 1 while (cur)&#123; tmp = cur-&gt;next; cur-&gt;next = new RandomListNode(cur-&gt;label); cur = cur-&gt;next; cur-&gt;next = tmp; cur = cur-&gt;next; &#125; // step 2 cur = head; while (cur)&#123; if (cur-&gt;random)&#123; cur-&gt;next-&gt;random = cur-&gt;random-&gt;next; &#125; cur = cur-&gt;next-&gt;next; &#125; // step 3 res = head-&gt;next; cur1 = head-&gt;next; cur = head; while (cur)&#123; tmp = cur1-&gt;next; if (tmp)&#123; cur1-&gt;next = tmp-&gt;next; cur1 = cur1-&gt;next; &#125; cur-&gt;next = tmp; cur = cur-&gt;next; &#125; return res; &#125;&#125;; 160.Intersection of Two Linked Lists 题目大意 给定两个有公共部分的单链表，找出单链表的交叉点 思路 将两个单链表当做循环链表 如果两个链表长度相同，那么两个指针相遇的位置即为交叉点 如果长度不同，一个大圈一个小圈，循环遍历，一定有某个时刻会相遇到交叉点 123456789101112131415class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *l1=headA, *l2=headB; if (l1==NULL || l2==NULL) return NULL; while (l1!=l2)&#123; l1 = l1-&gt;next; l2 = l2-&gt;next; if (l1 == l2) return l1; if (l1 == NULL) l1 = headA; if (l2 == NULL) l2 = headB; &#125; return l1; &#125;&#125;; 141.Linked List Cycle142.Linked List Cycle II题目大意 判断一个链表是否有环 如果一个链表有环，找到环的入口 思路 有环 使用快慢指针 如果相遇则有环，否则fast到达尾部(NULL) 入口 相遇位置为(km) 开始节点到入口(n-m) 相遇位置到入口需要走的路径长度为(m - (km-(n-m))) = n - km 所以必然会相遇在入口节点 123456789101112131415161718// 141class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (head==NULL) return false; ListNode *fast=head, *slow=head; while (fast!=NULL)&#123; if (fast-&gt;next!=NULL) fast = fast-&gt;next-&gt;next; else return false; slow = slow-&gt;next; if (slow == fast) return true; &#125; return false; &#125;&#125;; 12345678910111213141516171819202122232425// 142class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head==NULL) return head; ListNode *slow=head, *fast=head; while (fast!=NULL)&#123; if (fast-&gt;next!=NULL) fast = fast-&gt;next-&gt;next; else return NULL; slow = slow-&gt;next; if (slow == fast) break; &#125; if (fast == NULL) return fast; fast = head; while (fast!=slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; 287. Find the Duplicate Number题目大意 给定一个包含n+1个整数（[1,n]）的数组，假设只有一个重复数字，要求找到这个重复的数字。 思路 本身这个题目不算难，用hash或者排序都可以做，但是要求不能改变原数组、空间复杂度为O(1)、时间复杂度低于o(n^2)，这样就不好做了。 142. Linked List Cycle II类似于这道题的解法。 双指针方法 设置low指针和fast指针，low每次走一步，fast每次走两步； 存在环必然会相遇，设相遇时low走了k步，环的长度为r，则2k-k = nr； 环入口到相遇位置距离为m，数组开始位置到环入口位置的距离为s，则k - s =m, nr - s = m, s = (n-1)r + (r-m) 由上式可知，相遇后，如果fast再从0位置开始，low在相遇位置开始，low和fast都以一步为步长前进，则会相遇到环入口，而环入口上一个位置则为重复的数。 指针从不同位置开始，结果会略微不同，需要注意。 1234567891011121314151617181920212223242526class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; /* 整数是1到n，而重复的指针下一步会指到相同的位置， *所以必然会形成一个循环，因此可以通过步长不同的指针去找到这个循环 *如果是这样开始的话，2k-k-1=nr, k-s=m, nr-1-s=m, -&gt; s = (n-1)r+(r-m)+1 * 所以fast需要从0开始，而不能从nums[0]开始 */ while (low != fast)&#123; low = nums[low]; fast = nums[nums[fast]]; cout &lt;&lt; low &lt;&lt; " " &lt;&lt; fast &lt;&lt; endl; &#125; /*可以证明，low在第一次meet的位置，fast从第一个位置开始 *同时以一步移动，最后会相遇在相同的那个数 */ fast = 0; while (low != fast)&#123; low = nums[low]; fast = nums[fast]; cout &lt;&lt; low &lt;&lt; " " &lt;&lt; fast &lt;&lt; endl; &#125; return fast; &#125;&#125;; BinaryTree572.Subtree of Another Tree题目大意 给定两棵二叉树s和t，判断t是否是a的子树。 思路 二叉树问题基本都可以用递归解决 isSubtree：看看s和t是否是相同的，是就return true，否则，判断s-&gt;left和t或者s-&gt;right和t是否是相同的； isSame：如果s-&gt;val == t-&gt;val 则递归判断left和right，否则直接返回false； 代码 123456789101112131415161718192021class Solution &#123;public: bool isSubtree(TreeNode* s, TreeNode* t) &#123; if (!s &amp;&amp; !t) return true; if ((s &amp;&amp; !t) || (!s &amp;&amp; t)) return false; if (isSame(s, t)) return true; else&#123; return isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t); &#125; &#125;private: bool isSame(TreeNode* s, TreeNode* t)&#123; if (!s &amp;&amp; !t) return true; if ((s &amp;&amp; !t) || (!s &amp;&amp; t)) return false; if (s-&gt;val == t-&gt;val) return isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right); else return false; &#125;&#125;; 144.Binary Tree Preorder Traversal145.Binary Tree Postorder Traversal题目大意 前序和后序遍历二叉树 思路 基础的二叉树前序、中序和后序遍历没什么好说的，但是这两个题目提供了新的思路，值得思考 前序遍历 不再沿着左子树一直搜索下去，每次将右节点和左节点入栈，下一次循环时，左节点出栈继续该过程，因此也达到了先序遍历的目的 中序不适合此种方式，因为栈中没有存储所有的左子节点，所以没办法等到最后一个最深处的左子节点被访问以后再访问父节点，所以无法完成中序遍历 后序遍历 以往的思路是，对当前节点做一个标记，如果是第二次访问，则该访问该节点，否则 不访问该节点，继续入栈，但是如果节点本身无法做标记就没办法做了； 思路是 先序遍历是 root-left-right，如果root-right-left这样遍历的话，结果反过来就是left-right-root，就是后序遍历的结果(可以递归去思考为什么reverse就是后序的结果) root-right-left有两种思路 原来的先序遍历，先入栈右节点 1中提到的先序遍历，同样先入栈左节点 补充一种做法：使用pre节点记录回溯时上一次访问的节点（两种情况，一种是遇到叶子节点会回溯，一种是第二次访问某个节点需要继续向上回溯），如果是当前节点的右节点，说明该节点是第二次访问，访问该节点，出栈即可。 代码 preorder 123456789101112131415161718// new way to preoder binary treeclass Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; ss; ss.push(root); while (!ss.empty())&#123; root = ss.top(); res.push_back(root-&gt;val); ss.pop(); if (root-&gt;right) ss.push(root-&gt;right); if (root-&gt;left) ss.push(root-&gt;left); &#125; return res; &#125;&#125;; 12345678910111213141516void nPreOrder(Node *bt)&#123; if (bt == NULL) return; stack&lt;Node*&gt; s; // 如果栈为空但是bt不为空则需要继续遍历 while (!ss.empty() || bt)&#123; while (bt != NULL)&#123; cout &lt;&lt; bt-&gt;val &lt;&lt; " "; s.push(bt); bt = bt-&gt;lchild; &#125; if (s.empty()) return; bt = s.top(); bt = bt-&gt;rchild; s.pop(); &#125;&#125; postorder 12345678910111213141516171819class Solution2 &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if (!root) return result; stack&lt;TreeNode*&gt; ss; ss.push(root); while (!ss.empty())&#123; root = ss.top(); result.push_back(root-&gt;val); ss.pop(); if (root-&gt;left) ss.push(root-&gt;left); if (root-&gt;right) ss.push(root-&gt;right); &#125; reverse(result.begin(), result.end()); return result; &#125;&#125;; 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if (!root) return result; stack&lt;TreeNode*&gt; ss; while (!ss.empty() || root)&#123; while (root)&#123; result.push_back(root-&gt;val); ss.push(root); root = root-&gt;right; &#125; if (!ss.empty())&#123; root = ss.top(); ss.pop(); &#125; if(root) root = root-&gt;left; &#125; reverse(result.begin(), result.end()); return result; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; // 用来记录上次访问的节点是什么，从而判断当前节点是不是第一次访问 TreeNode* pre=NULL; while (root || !s.empty())&#123; while (root)&#123; s.push(root); root = root-&gt;left; &#125; if (s.empty()) break; root = s.top(); if (root-&gt;right &amp;&amp; root-&gt;right != pre)&#123; root = root-&gt;right; &#125;else&#123; // 包含两种情况，1. 是叶子节点 2. 是第二次访问的节点 res.push_back(root-&gt;val); pre = root; s.pop(); root = NULL; &#125; &#125; return res; &#125;&#125;; 二叉树路径和为某一值112.Path Sum 题目大意 给定一棵二叉树和某个值，判断二叉树是否存在某条路径使得路径和为给定值。路径的起点为根节点，终点为叶子节点。 思路 递归 非递归 非递归的方法，因为在遍历完左子树和右子树时才能pop掉当前节点，所以和后序遍历很相似 三种后序遍历方法 标记节点是第几次访问，如果是第二次访问，则visit该节点。如果节点无法标记做没法做 使用left-right-root的reverse是root-right-left，稍微修改先序遍历代码，得到root-right-left的访问结果，再翻转即可 使用pre节点，记录回溯时刻当前节点的上一次访问的节点，如果是右子树，那么是第二次访问，visit，否则是第一次访问，继续保留在栈中 显然，这个问题只能用第三种方法做。 代码 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; stack&lt;TreeNode*&gt; ss; TreeNode* pre=NULL; int s = 0; while (root || !ss.empty())&#123; while (root)&#123; s += root-&gt;val; ss.push(root); root = root-&gt;left; &#125; if (ss.empty()) break; root = ss.top(); if ((!root-&gt;left &amp;&amp; !root-&gt;right) &amp;&amp; s==sum) return true; if (root-&gt;right &amp;&amp; root-&gt;right != pre)&#123; root = root-&gt;right; &#125;else&#123; pre = root; s -= root-&gt;val; ss.pop(); root = NULL; &#125; &#125; return false; &#125;&#125;; 12345678class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (!root) return false; if ((root-&gt;val == sum) &amp;&amp; (!root-&gt;left &amp;&amp; !root-&gt;right)) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; 113.Path Sum II 题目大意 给定一颗二叉树和给定值，要求找到所有的和为给定值的路径，路径定义和上题一样 思路 有了上题基础，直接递归思路，设置两个引用参数，用于存储路径即可 代码 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; if (!root) return res; findPath(res, tmp, root, sum); return res; &#125;private: void findPath(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, TreeNode* root, int sum)&#123; if (!root) return; if ((root-&gt;val == sum) &amp;&amp; (!root-&gt;left &amp;&amp; !root-&gt;right))&#123; tmp.push_back(root-&gt;val); res.push_back(tmp); tmp.pop_back(); return; &#125; tmp.push_back(root-&gt;val); findPath(res, tmp, root-&gt;left, sum-root-&gt;val); findPath(res, tmp, root-&gt;right, sum-root-&gt;val); tmp.pop_back(); &#125;&#125;; 437. Path Sum III 题目大意 给定二叉树和给定值，求和为给定值的路径个数，路径的起始和结束不一定是跟节点和叶子节点，但是肯定是自上而下的。 思路 这道题和求解Binary Tree Maximum Path Sum ,相当于遍历二叉树每个节点，以每个节点作为起始点，搜索是否存在相应的路径 代码 12345678910111213141516class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if (!root) return 0; return totalPath(root, sum, 0) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); &#125;private: int totalPath(TreeNode* root, int sum, int s)&#123; if (!root) return 0; int total = 0; if (s+root-&gt;val == sum) total++; return total + totalPath(root-&gt;left, sum, s+root-&gt;val) + totalPath(root-&gt;right, sum, s+root-&gt;val); &#125;&#125;; 255.Verify Preorder Sequence in Binary Search Tree 题目大意 给定一个序列，判断是否是搜索二叉树的后序遍历（剑指offer上是后序） 思路 序列的最后一个数是根节点，将n-1的序列分为小于和大于两部分，如果找到分界点后，大于的部分出现了小于根节点的数则不符合要求； 递归左子树和右子树 1234567891011121314151617181920212223class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if (sequence.empty()) return false; int n = sequence.size(), i=0, j=0; bool flagLeft=true, flagRight=true; for (; i!=n-1; ++i)&#123; if (sequence[i] &gt; sequence[n-1]) break; &#125; j = i; for (; j!=n-1; ++j)&#123; if (sequence[j] &lt; sequence[n-1]) return false; &#125; vector&lt;int&gt; left(sequence.begin(), sequence.begin()+i); vector&lt;int&gt; right(sequence.begin()+i, sequence.end()-1); if(!left.empty()) flagLeft = VerifySquenceOfBST(left); if (!right.empty()) flagRight = VerifySquenceOfBST(right); return (flagLeft &amp;&amp; flagRight); &#125; 114.Flatten Binary Tree to Linked List 题目大意 将一棵二叉树转换为链表，要求in-place 思路 递归：先将链表的末端（右侧）完成，递归到最左侧 非递归 遍历所有节点 保存好root右子树的 root右子树指向左子树 1234567891011121314class Solution &#123;public: void flatten(TreeNode* root) &#123; if (!root) return; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right = pre; root-&gt;left = NULL; pre = root; &#125;private: TreeNode* pre;&#125;; 1234567891011121314151617181920class Solution &#123;public: void flatten(TreeNode* root) &#123; if (!root) return; while (root)&#123; if (!root-&gt;left)&#123; root = root-&gt;right; &#125;else&#123; TreeNode* tmp = root-&gt;left; while (tmp-&gt;right)&#123; tmp = tmp-&gt;right; &#125; tmp-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125; &#125; &#125;&#125;; 二叉搜索树与双向链表 题目大意 将一棵二叉搜索树转换为双向链表 思路 很上一题很相似，都是二叉树转换为链表，上题是先序遍历，该题是中序遍历 分为三个部分，根节点、左节点和右节点 将左子树排序好返回最大的链表节点 将根节点插入到链表中(最后一个节点) 将右节点当做根节点递归 代码 123456789101112131415161718192021222324252627class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; if(!pRootOfTree) return pRootOfTree; TreeNode* last = NULL; convertNode(pRootOfTree, &amp;last); TreeNode* tmp = last; while (tmp != NULL &amp;&amp; tmp-&gt;left != NULL) tmp = tmp-&gt;left; return tmp; &#125;private: void convertNode(TreeNode* node, TreeNode** last)&#123; if (node == NULL) return; TreeNode* cur = node; if (node-&gt;left) convertNode(node-&gt;left, last); cur-&gt;left = *last; if (*last) (*last)-&gt;right = cur; *last = cur; if (cur-&gt;right) convertNode(cur-&gt;right, last); &#125;&#125;; 104.Maximum Depth of Binary Tree111.Minimum Depth of Binary Tree题目大意 题目很简单，得到一颗二叉树的最大深度和最小深度。深度的定义是根节点到叶子节点的路径长度。 思路 递归思路 1 + 以当前节点为根节点的最小或最大深度 层次遍历 如果节点是左右子树均为NULL，则为叶子节点 最小，第一次遇到叶子节点即返回深度 最大，遍历所有，返回最大深度即可 代码 min 123456789class Solution1 &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; if (!root-&gt;left) return 1+minDepth(root-&gt;right); if (!root-&gt;right) return 1+minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;right), minDepth(root-&gt;left)); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435// 使用队列，用额外的空间存储层数相关信息class Solution2 &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; queue&lt;map&lt;TreeNode*, int&gt; &gt; q; int layer = 0; TreeNode* cur = root; while (cur != NULL || !q.empty())&#123; if (cur != NULL)&#123; if (cur-&gt;left != NULL)&#123; map&lt;TreeNode*, int&gt; m1; m1[cur-&gt;left] = layer++; q.push(m1); &#125; if (cur-&gt;right != NULL)&#123; map&lt;TreeNode*, int&gt; m2; m2[cur-&gt;right] = layer++; q.push(m2); &#125; &#125; if (!q.empty())&#123; map&lt;TreeNode*, int&gt; m; m = q.front(); cur = (m.begin())-&gt;first; layer = m[cur]; q.pop(); if (!(cur-&gt;left || cur-&gt;right)) return m[cur]; &#125; &#125; return layer; &#125;&#125;; 12345678910111213141516171819202122232425// 比较巧妙的记录层数信息，每一次都遍历完队列中的节点，这些节点都是属于同一层的cclass Solution3 &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; queue&lt;TreeNode*&gt; q; TreeNode* cur = root; q.push(cur); int layer = 0; while (!q.empty())&#123; ++layer; int k = q.size(); for (int i=0; i!=k; ++i)&#123; cur = q.front(); q.pop(); if (cur-&gt;left) q.push(cur-&gt;left); // if we judge the push TreeNode is not NULL, // then you couldn't judge the node is not NULL outspace if (cur-&gt;right) q.push(cur-&gt;right); if (!(cur-&gt;left || cur-&gt;right)) return layer; &#125; &#125; return 0; &#125;&#125;; max 12345678910class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; if (!root-&gt;left) return 1+maxDepth(root-&gt;right); if (!root-&gt;right) return 1+maxDepth(root-&gt;left); return 1+max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)); &#125;&#125;; 12345678910111213141516171819202122class Solution1 &#123;public: int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; queue&lt;TreeNode*&gt; q; TreeNode* cur = root; q.push(cur); int layer = 0; while(!q.empty())&#123; layer++; int k = q.size(); for (int i=0; i!=k; ++i)&#123; cur = q.front(); q.pop(); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125; &#125; return layer; &#125;&#125;; 222.Count Complete Tree Nodes题目大意 给定一颗完全二叉树，求节点个数。要求复杂度低于O(n) 思路 如果左子树右子树高度相等，那么不需要判断直接根据高度计算。否则，递归计算左子树和右子树的节点数。 因为一定存在较多满二叉树，所以时间复杂度低于O(n)。仔细想想，不存在太坏的情况。 123456789101112131415161718class Solution &#123;public: int countNodes(TreeNode* root) &#123; if (!root) return 0; TreeNode *l=root, *r=root; int lh=0, rh = 0; while(l) &#123; l = l-&gt;left; lh++; &#125; while(r) &#123; r = r-&gt;right; rh++; &#125; if (lh == rh) return pow(2, lh) - 1; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; 236.Lowest Common Ancestor of a Binary Tree题目大意 找到一棵二叉树两点节点最近公共祖先。 思路 遍历找到分别到两个节点的路径，比较两个路径，第一个不同节点的上一个节点则为公共祖先 如果root为p则返回root，如果root为q则返回root，如果root为空则返回空(其实也就是返回了p或q是否在子树里) 否则，递归左、右子树 如果q、p在同一个子树那么返回的就是公共祖先，否则如果p和q分别在两个子树，则root是公共祖先 123456789101112131415class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root) return root; if (root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) return root; if (!left) return right; else return left; &#125;&#125;; 235.Lowest Common Ancestor of a Binary Search Tree题目大意 给定一个二叉搜索树及两个节点，找到节点的最近公共祖先。 思路 利用BST的特点，如果p和q的值跟root比一大一小，则root为最近公共祖先，否则递归左子树或者右子树。 12345678910class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); if (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); return root; &#125;&#125;; 124.Binary Tree Maximum Path Sum题目大意 给定一棵二叉树，找到最大的路径和。路径可以试从child-root-child 思路 类比求数组的最大连续子数组和 用res记录最大路径和，每一层递归记录以root为中间节点的最大和(root-&gt;val + max(0, left) + max(0, right)) 返回的是root-child的单向最大和，因为需要和parent组成child-root-child路径 12345678910111213141516171819class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int res = INT_MIN; findMax(root, res); return res; &#125;private: int findMax(TreeNode* root, int&amp; res)&#123; if (root==NULL) return 0; int left = findMax(root-&gt;left, res); int right = findMax(root-&gt;right, res); if (left &lt; 0) left = 0; if (right &lt; 0) right = 0; if (root-&gt;val + left + right &gt; res) res = root-&gt;val + left + right; return root-&gt;val + max(left, right); &#125;&#125;; root-child的最大路径和1234567891011121314151617181920class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int res = INT_MIN; findMax(root, res); return res; &#125;private: int findMax(TreeNode* root, int&amp; res)&#123; if (root==NULL) return 0; int left = findMax(root-&gt;left, res); int right = findMax(root-&gt;right, res); if (left &lt; 0) left = 0; if (right &lt; 0) right = 0; int cur = root-&gt;val + max(left, right); res = max(res, cur); return res; &#125;&#125;; 116. Populating Next Right Pointers in Each Node117. Populating Next Right Pointers in Each Node II题目大意 给定一棵满二叉树，在水平方向上的前一个节点有next指针指向下一个节点； 如果是一颗普通二叉树呢 思路 满二叉树 当前节点的left指向right 当前root节点的right的next指向root-&gt;next的left节点 递归左子树和右子树 普通二叉树 root的right要指向的节点隔了好几个节点（while(root-&gt;next)找到root-&gt;next-&gt;left或者root-&gt;next-&gt;right不为空的节点） 上面的循环要求右子树先形成next，所以先递归右子树 1234567891011121314151617181920212223/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root==NULL) return; if (root-&gt;next)&#123; if (root-&gt;right &amp;&amp; root-&gt;next-&gt;left) root-&gt;right-&gt;next = root-&gt;next-&gt;left; &#125; if (root-&gt;left &amp;&amp; root-&gt;right)&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; connect(root-&gt;left); connect(root-&gt;right); &#125;&#125;; 12345678910111213141516171819202122232425262728class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root == NULL) return; int flag = 0; TreeLinkNode* tmp = root; // 因为二叉树不是完全二叉树，可能水平方向隔了很多个节点才有下一个节点，所以需要一直循环root-&gt;next // 直到找到下一个节点或者null TreeLinkNode* left = tmp-&gt;right ? tmp-&gt;right : tmp-&gt;left; while (tmp-&gt;next)&#123; TreeLinkNode* right = tmp-&gt;next-&gt;left ? tmp-&gt;next-&gt;left : tmp-&gt;next-&gt;right; if (left &amp;&amp; right)&#123; left-&gt;next = right; flag = 1; &#125; if (flag == 1) break; tmp = tmp-&gt;next; &#125; if (root-&gt;left &amp;&amp; root-&gt;right)&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; // 可能root右侧隔了很多个空节点才有节点，所以先调整好右边，在到左边 一直循环next找下去 connect(root-&gt;right); connect(root-&gt;left); &#125;&#125;; Tree208.Implement Trie (Prefix Tree)题目大意 实现一棵字典树 思路 一个trie node，用于存储当前的字母以及当前字母是否为单词的结束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class TrieNode &#123;public: TrieNode* next[26]; bool is_word; TrieNode(bool word = false)&#123; memset(next, 0, sizeof(next)); is_word = word; &#125;&#125;;class Trie &#123;public: /** Initialize your data structure here. */ Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; TrieNode* p = root; for (int i=0; i!=word.size(); ++i)&#123; if (p-&gt;next[word[i]-'a'] == NULL)&#123; p-&gt;next[word[i]-'a'] = new TrieNode(); &#125; p = p-&gt;next[word[i]-'a']; &#125; p-&gt;is_word = true; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; if (word.empty()) return true; TrieNode* p = root; for (int i=0; i!=word.size(); ++i)&#123; if (p-&gt;next[word[i]-'a'] != NULL) p = p-&gt;next[word[i]-'a']; else return false; &#125; return p-&gt;is_word; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; TrieNode* p = root; for (int i=0; i!=prefix.size(); ++i)&#123; if (p-&gt;next[prefix[i]-'a'] != NULL) p = p-&gt;next[prefix[i]-'a']; else return false; &#125; return true; &#125;private: TrieNode* root;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * bool param_2 = obj.search(word); * bool param_3 = obj.startsWith(prefix); */ 116. Populating Next Right Pointers in Each Node题目大意 给定一棵满二叉树，要求每个节点有个next指针，指向右侧的节点 思路 递归处理，对于每个节点root，需要做两件事情 将右子树的next指向next的左子树 root-&gt;right-&gt;next = root-&gt;next-&gt;left 将左子树next指向右子树 123456789101112131415class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root==NULL) return; if (root-&gt;next)&#123; if (root-&gt;right &amp;&amp; root-&gt;next-&gt;left) root-&gt;right-&gt;next = root-&gt;next-&gt;left; &#125; if (root-&gt;left &amp;&amp; root-&gt;right)&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; connect(root-&gt;left); connect(root-&gt;right); &#125;&#125;; 117. Populating Next Right Pointers in Each Node II题目大意 将上题中的满二叉树改为普通二叉树 思路 两个问题 水平方向上当前节点next需要指向的节点可能隔了好几个空节点，怎么办 可以考虑一直root-&gt;next循环，直到找到非空的节点 如何保证水平方向右边的next指针是已经建立好的（这样才可以循环找到非空节点） 先递归右子树，再递归左子树 12345678910111213141516171819202122232425262728class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root == NULL) return; int flag = 0; TreeLinkNode* tmp = root; // 因为二叉树不是完全二叉树，可能水平方向隔了很多个节点才有下一个节点，所以需要一直循环root-&gt;next // 直到找到下一个节点或者null TreeLinkNode* left = tmp-&gt;right ? tmp-&gt;right : tmp-&gt;left; while (tmp-&gt;next)&#123; TreeLinkNode* right = tmp-&gt;next-&gt;left ? tmp-&gt;next-&gt;left : tmp-&gt;next-&gt;right; if (left &amp;&amp; right)&#123; left-&gt;next = right; flag = 1; &#125; if (flag == 1) break; tmp = tmp-&gt;next; &#125; if (root-&gt;left &amp;&amp; root-&gt;right)&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; // 可能root右侧隔了很多个空节点才有节点，所以先调整好右边，在到左边 一直循环next找下去 connect(root-&gt;right); connect(root-&gt;left); &#125;&#125;; stack&amp;queue155.min stack 题目大意 实现一个栈，包括push、pop、top、和min方法，min方法是返回栈中最小值 思路 用一个数组存排序好的栈中的数，这种方法略笨重，时间复杂度也高； 两个栈ss和m_ss，ss用来存储栈数据，m_ss用来存储当前的最小值(用栈来实现很巧妙) m_ss入栈的时候永远是当前的最小值，如果新压入栈数大于栈顶元素则压入栈顶元素，否则压入该元素 出栈时，如果当前数是最小值，那么m_ss出栈了，m_ss栈顶位置是之前的最小值；如果当前数不是最小值，则m_ss出栈不影响之后的最小值。 代码 12345678910111213141516171819202122232425262728293031323334class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; ss.push(x); if (m_ss.empty() || m_ss.top() &gt; x) m_ss.push(x); else m_ss.push(m_ss.top()); &#125; void pop() &#123; assert(!ss.empty()); ss.pop(); m_ss.pop(); &#125; int top() &#123; assert(!ss.empty()); return ss.top(); &#125; int getMin() &#123; assert(!m_ss.empty()); return m_ss.top(); &#125;private: stack&lt;int&gt; ss; stack&lt;int&gt; m_ss;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 数组版本class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; ss.push(x); insert(x); &#125; void pop() &#123; int tmp = ss.top(); ss.pop(); remove(tmp); &#125; int top() &#123; if (!ss.empty()) return ss.top(); else return INT_MIN; &#125; int getMin() &#123; if (!ss.empty()) return minVec[0]; else return INT_MIN; &#125;private: void insert(int x)&#123; int low = findIndex(x); minVec.insert(minVec.begin()+low, x); &#125; void remove(int x)&#123; int low = findIndex(x); minVec.erase(minVec.begin()+low, minVec.begin()+low+1); &#125; int findIndex(int x)&#123; int low=0, high=minVec.size()-1, mid=0; while (low&lt;=high)&#123; mid = low + (high - low) / 2; if (minVec[mid] &lt; x) low = mid + 1; else high = mid - 1; &#125; return low; &#125; stack&lt;int&gt; ss; vector&lt;int&gt; minVec;&#125;; Dfs&amp;bfs22.Generate Parentheses 题目大意 给定一个数n，表示是括号的个数，输出包含n个括号的组合 思路 这种排列组合类的题，dfs是万能，需要考虑 左括号和右括号的个数 当前字符串中加入右括号时，右括号个数不能大于左括号个数 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; dfs(res, "", n, n); return res; &#125;private: void dfs(vector&lt;string&gt;&amp; res, string tmp, int left, int right)&#123; if (left==0 &amp;&amp; right==0)&#123; res.push_back(tmp); return; &#125; if (left &gt; 0) dfs(res, tmp+"(", left-1, right); if (right &gt; 0 &amp;&amp; right &gt; left) dfs(res, tmp+")", left, right-1); &#125;&#125;; 51. N-Queens52. N-Queens II 问题描述 $n\times n$的棋盘，放上n个皇后，要求每一行、每一列、45度和135度方向均不能存在两个皇后，问有多少种放法，以及输出每种放置方法。 回溯法 每一层放置一个皇后，遍历n个位置，如果该位置合法，进入下一行放置下一个皇后 dfs思路 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; chess(n, string(n, '.')); dfs(res, chess, 0, n); return res; &#125;private: void dfs(vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; chess, int row, int n)&#123; if (row == n)&#123; res.push_back(chess); return; &#125; for (int col=0; col!=n; ++col)&#123; if (isvalid(chess, row, col, n))&#123; chess[row][col] = 'Q'; dfs(res, chess, row+1, n); chess[row][col] = '.'; &#125; &#125; &#125; bool isvalid(vector&lt;string&gt;&amp; chess, int row, int col, int n)&#123; for (int i=0; i!=row; ++i)&#123; if (chess[i][col] == 'Q') return false; &#125; for (int x=row-1, y=col-1; x&gt;=0 &amp;&amp; y&gt;=0; --x, --y)&#123; if (chess[x][y] == 'Q') return false; &#125; for (int x=row-1, y=col+1; x&gt;=0 &amp;&amp; y&lt;n; --x, ++y)&#123; if (chess[x][y] == 'Q') return false; &#125; return true; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int totalNQueens(int n) &#123; int res=0; vector&lt;string&gt; chess(n, string(n, '.')); dfs(res, chess, 0, n); return res; &#125;private: void dfs(int&amp; res, vector&lt;string&gt;&amp; chess, int row, int n)&#123; if (row == n)&#123; res++; return; &#125; for (int col=0; col!=n; ++col)&#123; if (isvalid(chess, row, col, n))&#123; chess[row][col] = 'Q'; dfs(res, chess, row+1, n); chess[row][col] = '.'; &#125; &#125; &#125; bool isvalid(vector&lt;string&gt;&amp; chess, int row, int col, int n)&#123; for (int i=0; i!=row; ++i)&#123; if (chess[i][col] == 'Q') return false; &#125; for (int x=row-1, y=col-1; x&gt;=0 &amp;&amp; y&gt;=0; --x, --y)&#123; if (chess[x][y] == 'Q') return false; &#125; for (int x=row-1, y=col+1; x&gt;=0 &amp;&amp; y&lt;n; --x, ++y)&#123; if (chess[x][y] == 'Q') return false; &#125; return true; &#125;&#125;; trick54.Spiral Matrix 题目大意 给定一个二维数组，要求螺旋打印数组中的数 思路 每一圈的左上角的点都是(start, start)，start 2 &lt; m &amp;&amp; start 2&lt;n 每一圈，有四个方向，有相应的限制条件，在相应限制条件下打印即可 代码 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if (matrix.empty() || matrix[0].empty()) return res; int row=matrix.size(), col=matrix[0].size(); int start=0, endRow=0, endCol=0; while (start*2&lt;row &amp;&amp; start*2&lt;col)&#123; endRow = row - start - 1; endCol = col - start - 1; for (int i=start; i&lt;=endCol; ++i) res.push_back(matrix[start][i]); if (start &lt; endRow)&#123; for (int i=start+1; i&lt;=endRow; ++i) res.push_back(matrix[i][endCol]); &#125; if (start &lt; endRow &amp;&amp; start &lt; endCol)&#123; for (int i=endCol-1; i&gt;=start; --i) res.push_back(matrix[endRow][i]); &#125; if (start &lt; endRow-1 &amp;&amp; start &lt; endCol)&#123; for (int i=endRow-1; i&gt;start; --i) res.push_back(matrix[i][start]); &#125; start++; &#125; return res; &#125;&#125;; 169.Majority Element 题目大意 给定一个长度为n的数组，找出数组中出现次数大于n/2的数 思路 排序 majority element的次数 随机找个数，判断是否为majority element Bit Manipulation 计算每一位是否是majority 代码 12345678910111213141516171819// 2class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int result = nums[0], times = 1; for (int i=1; i!=nums.size(); ++i)&#123; if (result != nums[i])&#123; times--; if (times &lt; 0)&#123; result = nums[i]; times = 1; &#125; &#125; else times++; &#125; return result; &#125;&#125;; 123456789101112131415161718// 4class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int major = 0, n = nums.size(); for (int i = 0, mask = 1; i &lt; 32; i++, mask &lt;&lt;= 1) &#123; int bitCounts = 0; for (int j = 0; j &lt; n; j++) &#123; if (nums[j] &amp; mask) bitCounts++; if (bitCounts &gt; n / 2) &#123; major |= mask; break; &#125; &#125; &#125; return major; &#125; &#125;; 229.Majority Element II 题目大意 给定一个长度为n的数组，找出数组中出现次数大于n/3的数 要求线性时间复杂度，空间复杂度为O(1) 思路 Moore Majority Voting 使用res1和res2记录当前两个数，count1和count2记录当前两个数出现的次数 可行性分析 如果存在两个满足条件的数，那么剩下的数出现次数将少于n/3，所以最后剩下的两个数一定是次数大于n/3的数 如果只存在一个满足条件的数a，则a出现次数t大于n/3，最多能减少的次数为(n-t)/2 &lt; n/3，所以a必然能保留到最后(333331212) 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int res1=0, count1=0, res2=0, count2=0; for (int i=0; i!=nums.size(); ++i)&#123; if (nums[i] == res1) count1++; else if (nums[i] == res2) count2++; else if (count1 == 0)&#123; res1 = nums[i]; count1 = 1; &#125; else if (count2 == 0)&#123; res2 = nums[i]; count2 = 1; &#125; else&#123; count1--; count2--; &#125; &#125; count1 = 0; count2 = 0; for (int i=0; i!=nums.size(); ++i)&#123; if (nums[i] == res1) count1++; if (nums[i] == res2) count2++; &#125; if (count1 &gt; nums.size()/3) res.push_back(res1); if (count2 &gt; nums.size()/3 &amp;&amp; res2 != res1) res.push_back(res2); return res; &#125;&#125;; 347.Top K Frequent Elements 题目大意 给定一个数组，找出出现频率最多的k个数 思路 先统计每个数出现次数 使用优先级队列排序，使优先级队列的大小为(n-k) 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; cache1; vector&lt;int&gt; res, tmp; for (int i=0; i!=nums.size(); ++i)&#123; cache1[nums[i]]++; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; q; for (map&lt;int, int&gt;::iterator it=cache1.begin(); it!=cache1.end(); ++it)&#123; q.push(make_pair(it-&gt;second, it-&gt;first)); if (q.size() &gt; cache1.size()-k)&#123; res.push_back(q.top().second); q.pop(); &#125; &#125; return res; &#125;&#125;; 215.Kth Largest Element in an Array 题目大意 找到数组中第k大的元素 思路 堆 维护一个k大小的最小堆(优先级队列) 遍历完所有元素，堆顶元素即为k大的元素 partition 1234567891011class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for (int i=0; i!=nums.size(); ++i)&#123; q.push(nums[i]); if (q.size() &gt; k) q.pop(); &#125; return q.top(); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int s = 0, e = nums.size()-1, index = 0; while (true)&#123; index = partition(nums, s, e); if (index == nums.size()-k) break; else if (index &lt; nums.size()-k)&#123; s = index+1; &#125;else&#123; e = index-1; &#125; &#125; return nums[index]; &#125;private: int partition(vector&lt;int&gt;&amp; nums, int s, int e)&#123; int tmp = nums[s]; while (s &lt; e)&#123; // 注意快排时，交换以后s和e需要改变，否则遇到有重复数的数组会进入死循环 while(s &lt; e &amp;&amp; nums[e] &gt; tmp) --e; if (s &lt; e) nums[s++] = nums[e]; while(s &lt; e &amp;&amp; nums[s] &lt; tmp) ++s; if (s &lt; e) nums[e--] = nums[s]; &#125; nums[s] = tmp; return s; &#125;&#125;; 179.Largest Number 题目大意 给定一个数组，将数组中的数拼接成一个大数，求其中最大的数 思路 将数组中的数按照拼接的大小顺序排序 注意，拼接后的数可能会非常大，是一个大数问题，需要用字符串表示 12345678910111213141516171819class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; new_nums; string res = ""; for (int i=0; i!=nums.size(); ++i) new_nums.push_back(to_string(nums[i])); sort(new_nums.begin(), new_nums.end(), compare); for (int i=0; i!=new_nums.size(); ++i) res += new_nums[i]; while (res.size() &gt; 1 &amp;&amp; res[0] == '0') res.erase(0, 1); return res; &#125; // 给sort用的函数，必须是static或者在类外定义，否则sort无法访问 bool static compare(string a, string b)&#123; return (a+b) &gt; (b+a); &#125;&#125;; 264.Ugly Number II 题目大意 因子分解只有2、3和5的数称为丑数，给定n，求第n个丑数是多少。默认1为第一个丑数 思路 新的丑数都是由旧的丑数乘以2或3或5得到的 记录2或3或5乘到的位置，每次选取最小的即可 12345678910111213141516class Solution &#123;public: int nthUglyNumber(int n) &#123; if (n &lt;= 1) return 1; vector&lt;int&gt; dp(1, 1); int l2=0, l3=0, l5=0; for (int i=0; i!=n; ++i)&#123; int tmp = min(dp[l2]*2, min(dp[l3]*3, dp[l5]*5)); if (tmp == dp[l2]*2) l2++; if (tmp == dp[l3]*3) l3++; if (tmp == dp[l5]*5) l5++; dp.push_back(tmp); &#125; return dp[n-1]; &#125;&#125;; 315.Count of Smaller Numbers After Self 题目大意 给定一个数组，返回一个数组，每个位置表示在该数右边比该数小的个数 思路 暴力，O(n^2) 巧妙使用归并排序 学习到递归形式的归并排序，简单好写 每一趟归并排序时，数组两部分都是有序的，所以左侧的较大的数的逆序数是建立在较小数的基础上，比如a[2]是在a[1]的逆序数上开始进行累加，避免了重复计算 该题要求返回每个位置的逆序数，所以不能直接对原数组进行归并排序，采用了对原数组的index进行归并排序； 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); vector&lt;int&gt; res(n, 0), index(n, 0); for (int i=0; i!=n; ++i) index[i] = i; mergeCount(nums, res, index, 0, n); return res; &#125;private: void mergeCount(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; res, vector&lt;int&gt;&amp; index, int s, int n)&#123; if (s &lt; n-1)&#123; int count = 0, mid = s + (n - s) / 2; mergeCount(nums, res, index, s, mid); mergeCount(nums, res, index, mid, n); //cout &lt;&lt; "== " &lt;&lt; s &lt;&lt; " " &lt;&lt; n &lt;&lt; endl; int id1 = s, id2 = mid; // 避免需要另一个vector存储排序好的数组 vector&lt;int&gt; tmp; while (id1&lt;mid || id2&lt;n)&#123; if (id2 == n || (id1 &lt; mid &amp;&amp; nums[index[id1]] &lt;= nums[index[id2]]))&#123; tmp.push_back(index[id1]); //cout &lt;&lt; 'a' &lt;&lt; id1 &lt;&lt; " " &lt;&lt; index[id1] &lt;&lt; " " &lt;&lt; count &lt;&lt; endl; res[index[id1]] += count; id1++; &#125;else&#123; tmp.push_back(index[id2++]); count++; //cout &lt;&lt; 'b' &lt;&lt; id2 &lt;&lt; " " &lt;&lt; count &lt;&lt; endl; &#125; &#125; move(tmp.begin(), tmp.end(), index.begin()+s); &#125; &#125;&#125;; 数组中的逆序对 题目大意 返回数组中逆序对个数 思路 归并排序 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; int n = data.size(); vector&lt;int&gt; tmp(n, 0); return mergeCount(data, tmp, 0, n)%1000000007 ; &#125;private: long long mergeCount(vector&lt;int&gt;&amp; data, vector&lt;int&gt;&amp; tmp, int s, int n)&#123; int length = n - s; long long count = 0, left = 0, right = 0; if (length &gt; 1)&#123; int mid = s + length / 2; left = mergeCount(data, tmp, s, mid); right = mergeCount(data, tmp, mid, n); int s1 = mid-1, s2 = n-1, i=n-1; while (s1 &gt;= s &amp;&amp; s2 &gt;= mid)&#123; if (data[s1] &gt; data[s2])&#123; count = count + s2 - mid + 1; tmp[i--] = data[s1--]; &#125;else tmp[i--] = data[s2--]; &#125; while (s1 &gt;= s) tmp[i--] = data[s1--]; while (s2 &gt;= mid) tmp[i--] = data[s2--]; for (int k=s; k!=n; ++k) data[k] = tmp[k]; &#125; return left+right+count; &#125;&#125;; 补充 取余和取模 步骤 c = a / b r = a - c * b 区别 取余 c取的时候往0方向取 取模 c取的时候往负无穷方向取 1.Two Sum题目大意 给定一个整数数组和一个目标和，返回数组中加起来和是目标和的两个数的下标。 思路 如果暴力搜索的话，需要O(n^2)复杂度，可以遍历过程中，用map存储，key是值，value是下标。如果能够在map中找到(target-nums[i])，则将对应的下标和i返回即可。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; cache; vector&lt;int&gt; res; for (int i=0; i!=nums.size(); ++i)&#123; if (cache.find(target - nums[i]) != cache.end())&#123; res.push_back(cache[nums[i]]); res.push_back(i); return res; &#125; cache[nums[i]] = i; &#125; return res; &#125;&#125;; 191.Number of 1 Bits题目大意 给定一个32位无符号整数，求该整数二级制形式1的个数。 思路 遍历每一位，记录1的个数即可。 不要使用除操作，耗时较久，使用移位和与操作。 如果是有符号整数，可能会导致循环无法结束，可以左移1来遍历。 n &amp; (n-1)的操作能够将最右边的1变为0，可以将所有的1都变为0，需要的次数即为1的个数。 代码 123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0; while (n)&#123; if (n &amp; 1) ++sum; n = n &gt;&gt; 1; &#125; return sum; &#125;&#125;; 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0; while (n)&#123; ++sum; n = (n-1) &amp; n; &#125; return sum; &#125;&#125;; 12345678910111213// consider signed intclass Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0, flag = 1; while (flag)&#123; if (flag &amp; n) ++sum; flag = flag &lt;&lt; 1; &#125; return sum; &#125;&#125;; 231.Power of Two326.Power of Three342.Power of Four题目大意 给定一个整数，求是否是2、3、4的整数次方。 思路 基础思路 一直除2(3,4)，直到有余数，判断此时n是否为1即可，如果不为1，说明不是整数次幂； 不用循环的解法 2 n &amp; (n-1) == 0 则为整数幂 $2^{30}$%n == 0，因为$2^{30-k} 2^k = 2^{30}$，所以如果整除n，则为2的整数幂 3 $3^{19}$%n == 0，因为$3^{19-k} 3^k = 3^{19}$，所以如果整除n，则为3的整数幂 4 满足三个条件 n &gt; 0 n &amp; (n - 1) == 0 (n - 1) % 3 == 0：在满足1、2前提下，只会出现2的整数幂和4的整数幂，而$4^n - 1 = (2^k-1)(2^k+1)$ ，而连续出现的三个数必定有一个是整除3的，而肯定不是$2^k$，$4^n-1$一定整除3，同时，$2^{2k+1}-1$必定不能整除3(为什么) 代码 2 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return (n &gt; 0 &amp;&amp; (n &amp; (n-1) == 0)); &#125;&#125;; 3 12345678910class Solution &#123;public: bool isPowerOfThree(int n) &#123; if (n&lt;=0) return false; while (!(n%3))&#123; n = n / 3; &#125; return (n==1); &#125;&#125;; 1234567class Solution &#123;public: bool isPowerOfThree(int n) &#123; int a = pow(3,19); return ((n&gt;0) &amp;&amp; ( a % n == 0)); &#125;&#125;; 4 12345678910class Solution &#123;public: bool isPowerOfFour(int num) &#123; if (num &lt;= 0) return false; while (!(num % 4))&#123; num = num / 4; &#125; return (num == 1); &#125;&#125;; 123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return (num &gt; 0 &amp;&amp; !(num &amp; (num - 1)) &amp;&amp; ((num - 1) % 3 == 0)); &#125;&#125;; 523.Continuous Subarray Sum题目大意 给定一个非负的数组，找到连续的子数组的和为k的整数倍 思路 要求时间复杂度为O(n) 考虑如果0~i位置元素和除以k的余数为res，如果0~j位置元素和除以k的余数也为res，同时i+1&lt;j，那么i+1~j即为和可以整除k的子数组 考虑k为0的情况 1234567891011121314151617181920class Solution &#123;public: bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; cache; cache[0] = -1; int sum = 0, res = 0; for (int i=0; i!=nums.size(); ++i)&#123; sum += nums[i]; // 如果k==0，那么只有0才满足要求 if (k == 0) res = sum; else res = sum % k; if (cache.find(res) != cache.end())&#123; if (cache[res]+1 &lt; i) return true; &#125;else cache[res] = i; &#125; return false; &#125;&#125;; 135.Candy题目大意 1234567There are N children standing in a line. Each child is assigned a rating value.You are giving candies to these children subjected to the following requirements:* Each child must have at least one candy.* Children with a higher rating get more candies than their neighbors.What is the minimum candies you must give? 思路 一个人分多少糖果取决于左边和右边的人，而左右边的人又有所依赖； 考虑每次只保证一侧是合法的，遍历两次即可 第一遍，从左到右，如果右边大于左边则给右边糖果个数+1 第二遍，从右到左，如果左边大于右边则给左边糖果+1 12345678910111213141516class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int n = ratings.size(); vector&lt;int&gt; cache(n, 1); for (int i=1; i!=n; ++i)&#123; if (ratings[i] &gt; ratings[i-1]) cache[i] = cache[i-1] + 1; &#125; for (int i=n-2; i&gt;=0; --i)&#123; if (ratings[i] &gt; ratings[i+1] &amp;&amp; cache[i] &lt;= cache[i+1]) cache[i] = cache[i+1] + 1; &#125; return accumulate(cache.begin(), cache.end(), 0); &#125;&#125;; 骰子和概率题目大意 返回n个骰子随机投，每种和的概率 思路 dfs 使用两个数组记录，n个骰子和的概率是在n-1个骰子和概率基础上计算的 n个骰子，和为m的次数是n-1个骰子和为m-1、m-2…m-6的和 类似dp 1234567891011121314151617181920212223242526void printProb(int n)&#123; int maxSum = n * 6, flag = 0; vector&lt;vector&lt;int&gt;&gt; cache(2, vector&lt;int&gt;(maxSum+1, 0)); for (int i=1; i&lt;=6; ++i) cache[flag][i] = 1; flag = 1 - flag; for (int k=2; k&lt;=n; ++k)&#123; for (int i=1; i&lt;k; ++i) cache[flag][i] = 0; for (int i=k; i&lt;=k*6; ++i)&#123; cache[flag][i] = 0; for (int j=1; j&lt;=i &amp;&amp; j&lt;=6; ++j)&#123; cache[flag][i] += cache[1-flag][i-j]; &#125; &#125; flag = 1 - flag; &#125; int total = pow(6, n), p = 0; for (int i=n; i!=maxSum+1; ++i)&#123; cout &lt;&lt; i &lt;&lt; " " &lt;&lt; (double)cache[1-flag][i] / total &lt;&lt; endl; p += (double)cache[1-flag][i]; &#125; cout &lt;&lt; "total: " &lt;&lt; p &lt;&lt; endl;&#125; 扑克牌的顺子题目大意 判断抽取的牌是否为顺子，A为1，J为11，Q为12，K为13，大小王是0，可以替代任何数 思路 先排序，判断0的个数，和gap的个数，如果gap的个数大于0的个数，则返回false 12345678910111213141516171819class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; if (numbers.empty()) return false; sort(numbers.begin(), numbers.end()); int zeroNum = 0, gapNum = 0; for (int i=0; i!= numbers.size(); ++i)&#123; if (numbers[i] == 0) zeroNum++; if (i!=0 &amp; numbers[i-1]!=0)&#123; if (numbers[i-1] == numbers[i]) return false; else gapNum += numbers[i] - numbers[i-1] - 1; &#125; &#125; return zeroNum &gt;= gapNum; &#125;&#125;; 73.Set Matrix Zeroes题目大意 给定一个二维数组，将有0的位置的行和列置为0 思路 遍历每一行，记录每一个列出现0的位置，同时记录该行是否有0，如果有零，遍历完该行，将改行置为0 最后将记录的列置为0 12345678910111213141516171819202122232425class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return; int m=matrix.size(), n=matrix[0].size(), flag=0; set&lt;int&gt; zeros; for (int i=0; i!=m; ++i)&#123; for (int j=0; j!=n; ++j)&#123; if (matrix[i][j] == 0)&#123; flag = 1; zeros.insert(j); &#125; &#125; if (flag)&#123; for (int k=0; k!=n; ++k) matrix[i][k] = 0; &#125; flag = 0; &#125; for (set&lt;int&gt;::iterator it=zeros.begin(); it!=zeros.end(); ++it)&#123; for (int j=0; j!=m; ++j) matrix[j][*it] = 0; &#125; &#125;&#125;; 239.Sliding Window Maximum题目大意 给定一个数组和一个窗口大小，问当窗口在数组上滑动时，返回每个窗口最大值组成的数组。 思路 剑指offer上的原题啊 暴力法，暴力滑过各个窗口取得最大值，时间复杂度是O(nk)，每个窗口计算时重复比较了很多数 堆 用一个堆记录当前值的排序顺序，每滑动一个窗口，往堆中插入一个数，堆顶元素即使当前窗口的最大值 问题在于，如何弹出已经超过该窗口的元素。堆中元素包含下标，如果堆顶元素的小标超过了当前窗口的最小小标值，那么就pop掉。 时间复杂度O(nlogk) 双端队列 队列中存储的是降序排列的元素，自然队列头部是当前窗口的最大值，如果当前要插入的元素大于尾部数据，则弹出尾部数据，直到找到比该元素大的数插入； 问题在于，如何判断某个元素是否已经超过了该窗口，此时，可以考虑队列中存储下标，如果下标超过了当前窗口的最小下标，那么就需要pop掉； 12345678910111213141516171819struct cmp&#123; bool operator()(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b)&#123; return a.first &lt; b.first; &#125;&#125;;class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; q; vector&lt;int&gt; res; for (int i=0; i!=nums.size(); ++i)&#123; q.push(make_pair(nums[i], i)); while (q.top().second &lt; res.size()) q.pop(); if (i+1 &gt;= k) res.push_back(q.top().first); &#125; return res; &#125;&#125;; 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; q; vector&lt;int&gt; res; for (int i=0; i!=nums.size(); ++i)&#123; // 如果队首元素超过了结果的长度(第几个窗口)，那么需要弹出 if (!q.empty() &amp;&amp; q.front() &lt; res.size()) q.pop_front(); // 维护双端队列是一个降序，front位置永远是当前窗口的最大值 while (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i]) q.pop_back(); q.push_back(i); if (i&gt;=k-1) res.push_back(nums[q.front()]); &#125; return res; &#125;&#125;; 152. Maximum Product Subarray题目大意 给定一个数组，返回连续子数组的最大积 思路 只要中间没有零，那么连续子数组越长越好，同时恰好使得子数组负数个数为偶数，此时最大； front和back记录遍历过程中正向遍历和逆向遍历的每一步的最大值，除非遇到零。 123456789101112131415class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int front = 1, back = 1, res = INT_MIN; int n = nums.size(); for (int i=0; i!=n; ++i)&#123; front *= nums[i]; back *= nums[n-i-1]; res = max(res, max(front, back)); front = front == 0 ? 1 : front; back = back == 0 ? 1 : back; &#125; return res; &#125;&#125;; math233.Number of Digit One 题目大意 给定一个数n，求出1-n所有数中1出现的个数 思路 考虑每一位上为1的情况 例如考虑百位为1的情况，n为32198，a为321，b为98 如果百位(a%10) &gt;=2, 那么有(a/10+1)*m个1； 如果(a%10)==1，那么(a/10*m)+b+1个1； 如果(a%10)==0, 那么(a/10*m)个1； 综合起来(a+8)/10*m+(a%10==1?b+1:0); 123456789101112class Solution &#123;public: int countDigitOne(int n) &#123; int count = 0, a = 0, b = 0; for (long m=1; m&lt;=n; m*=10)&#123; a = n / m; b = n % m; count += (a+8)/10*m + ((a%10==1)?b+1:0); &#125; return count; &#125;&#125;; 69.Sqrt(x)题目大意 求一个数的开根号，返回floor(sqrt(x)) 思路 二分法 牛顿法 $f(x) = f(x_k) + f^-(x_k)(x - x_k)$ $x = x_k - \frac{f(x_k)}{f^-(x_k)}$ 1234567891011121314151617// binaryclass Solution &#123;public: int mySqrt(int x) &#123; long low = 0, high = x, mid = 0; while (low &lt;= high)&#123; mid = low + (high - low) / 2; // mid * mid 考虑越界问题 if (mid * mid &lt; x) low = mid + 1; else if (mid * mid &gt; x) high = mid - 1; else return mid; &#125; return high; &#125;&#125;; 1234567891011// newtonclass Solution &#123;public: int mySqrt(int x) &#123; long res = x; while (res*res &gt; x)&#123; res = (res + x / res) / 2; &#125; return res; &#125;&#125;; 50.Pow(x, n)题目大意 实现标准库中的pow运算。 思路 考虑一些边界条件以及优化 指数为负的情况； 底为零指数为负的情况，不能做除法； int的指数变负为正时，考虑最大的负数变为整数会越界； 提高效率，将$2^{2k+1}$装换为$2^k$的平方乘2 代码 12345678910111213141516171819202122232425262728class Solution &#123;public: double myPow(double x, int n) &#123; // float和double类型的比较不能直接比较 // 考虑底为零的情况 if ((x - 0.0) &lt; 0.0000001 &amp;&amp; (x - 0.0) &gt; -0.000000001) return x; double res = 1.0; // 考虑为负的情况 if (n &lt; 0)&#123; x = 1 / x; // 考虑越界 if (n == INT_MIN)&#123; res *= x; n += 1; &#125; n = -n; &#125; while (n)&#123; // &amp; 和 移位运算替代取余和除法 if (n &amp; 1) res *= x; n &gt;&gt;= 1; x *= x; &#125; return res; &#125;&#125;; 372.Super Pow题目大意 计算$a^b$%1337, b非常大，用vector的形式给出。 思路 ab % k = (a % k)(b % k) % k f(a,b)表示$a^b$%k, 则f( f( a, b / 10), 10) * f(a, b % 10) % k，这样就转化为一个递归问题了 123456789101112131415161718192021class Solution &#123;public: int superPow(int a, vector&lt;int&gt;&amp; b) &#123; if (a == 0) return 0; if (b.empty()) return 1; int x = b.back(); b.pop_back(); return mypow(superPow(a, b), 10) * mypow(a, x) % base; &#125;private: const int base = 1337; int mypow(int a, int k)&#123; // 相当于拆分到每个底相乘，每个底都对base取模 a %= base; int res = 1; for (int i=0; i!=k; ++i)&#123; res = (res * a) % base; &#125; return res; &#125;&#125;; 约瑟夫环题目大意 0-n-1个人围成一个圈，从0喊到m-1，m-1的人被淘汰。然后从下一个人开始继续，请问最后活下来的是哪个人 思路 推导 f(n,m)表示n个小朋友，第m个人出局剩下的最后一个人;g(n-1, m)表示淘汰了f(n,m)中第m个人后按照规则剩下的那个人； f(n,m) = g(n-1,m) = (f(n-1, m) + m) % n 下标差了m 递推公式f(n,m) = (f(n-1, m) + m)% n 123456789101112class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; int last = 0; for (int i=2; i&lt;=n; ++i) last = (last + m ) % i; return last; &#125;&#125;; 382.Linked List Random Node题目大意 一个非常大的链表，随机返回链表上的一个节点值，要求O(n) 思路 蓄水池算法。 需要选取k个随机数 选择前k个数，对于第i个来的数，以$\frac{k}{k+i}$的概率是否选择该数，然后再以$\frac{1}{k}$的概率替换池子中的一个数 直到i到最后一个数，池子里的数就是随机出来的k个数 12345678910111213141516171819202122232425class Solution &#123;ListNode* root;public: /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution(ListNode* head) &#123; root = head; &#125; /** Returns a random node's value. */ int getRandom() &#123; if (root == NULL) return -1; ListNode* tmp = root; int res = tmp-&gt;val, count = 1; tmp = tmp-&gt;next; while (tmp)&#123; if (rand() % (1 + count++) == 0)&#123; res = tmp-&gt;val; &#125; tmp = tmp-&gt;next; &#125; return res; &#125;&#125;; 29. Divide Two Integers题目大意 给定两个整数，输出除的结果，要求不能使用加、减和取余操作 思路 整体思路是判断结果正负号，将负数变为整数，使用移位和减法操作实现除法。 溢出 因为负数要换成正数，所以针对出现负数的情况讨论溢出问题 除数较小时使用移位操作加速计算 除数左移时候也需要考虑是否会溢出的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int divide(int dividend, int divisor) &#123; // 几种可能越界的情况 if (dividend == INT_MIN &amp;&amp; divisor == INT_MIN) return 1; else if (divisor == INT_MIN) return 0; if (dividend == INT_MIN &amp;&amp; divisor == -1) return INT_MAX; if (dividend == INT_MIN &amp;&amp; divisor == 1) return INT_MIN; int is_minus = 0, res = 0, count = 1; if (divisor &lt; 0)&#123; divisor = -divisor; is_minus = ~is_minus; &#125; if (dividend &lt; 0)&#123; // 考虑被除数的越界问题 if (dividend == INT_MIN) &#123; dividend += divisor; res++; &#125; dividend = - dividend; is_minus = ~is_minus; &#125; while (dividend &gt; 0)&#123; int t = divisor; count = 1; // 使用移位加速计算 while (dividend &gt;&gt; 1 &gt; t)&#123; t = t &lt;&lt; 1; count = count &lt;&lt; 1; &#125; dividend -= t; res += count; &#125; // 不能整除 取整 if (dividend &lt; 0) res--; // 负数 返回负数 if (is_minus) return -res; // 整数 直接返回 else return res; &#125;&#125;; 两个数相除返回字符串形式题目大意 两个整数相除，返回字符串形式，循环小数用括号+循环位替代。 4 / 2 -&gt; 2 , 2 / 4 -&gt; 0.5 , 1 / 3 -&gt; 0.(3) 思路 整数部分直接除取整，小数部分乘10除取整，余数再循环。 1234567891011121314151617181920212223242526272829303132333435string divide2int(int a, int b)&#123; string res = ""; int zs, xs, last, count = 0; if (a == INT_MIN &amp;&amp; b == -1)&#123; res = to_string(INT_MAX); return res; &#125; // get zhengshu zs = a / b; res += to_string(zs); a = a - b * zs; if (a == 0) return res; // 需要计算小数部分 last = a; res += '.'; map&lt;int, int&gt; cache; string tmp = ""; while (a &amp;&amp; count &lt; 10)&#123; // 有循环小数 if (cache.find(a) != cache.end())&#123; tmp = string(tmp.begin(), tmp.begin()+cache[a]) + '(' + string(tmp.begin()+cache[a], tmp.end()) + ')'; break; &#125; cache[a] = count; xs = a * 10 / b; a = a * 10 % b; count++; tmp += to_string(xs); last = a; &#125; res += tmp; return res;&#125; Binary Search34.Search for a Range题目大意 给定一个升序数组和一个目标值，找到目标所在的区间，如果不存在就返回[-1,-1] 思路 二分搜索，改变=的位置即可找到上界和下界； 使用low&lt;=high的条件，low是左边的位置，high是右边的位置 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, -1); if (nums.empty()) return res; int low = binarySearch(nums, target, 1); if (low &gt;=0 &amp;&amp; low &lt; nums.size() &amp;&amp; nums[low] == target) res[0] = low; else res[0] = -1; int high = binarySearch(nums, target, 0); if (high &gt;= 0 &amp;&amp; high &lt; nums.size() &amp;&amp; nums[high] == target) res[1] = high; return res; &#125;private: int binarySearch(vector&lt;int&gt;&amp; nums, int target, int left)&#123; int low=0, high=nums.size()-1, mid=0; while (low &lt;= high)&#123; mid = low + (high - low) / 2; if ((left &amp;&amp; nums[mid] &gt;= target) || (!left &amp;&amp; nums[mid] &gt; target)) high = mid - 1; else low = mid + 1; &#125; // low是高一位的点，high是低一位的点 if (left) return low; else return high; &#125;&#125;; 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, -1); if (nums.empty()) return res; int low = 0, high = nums.size()-1, mid; while (low &lt; high)&#123; mid = low + (high - low) / 2; if (nums[mid] &gt;= target) high = mid; else low = mid + 1; &#125; if (nums[low] != target) return res; res[0] = low; while (low &lt; nums.size() &amp;&amp; nums[low] == target) low++; res[1] = low-1; return res; &#125;&#125;; 153.Find Minimum in Rotated Sorted Array154.Find Minimum in Rotated Sorted Array II题目大意 在一个没有重复数字的循环排序数组里，找到最小的数； 在一个有重复数字的循环排序数组里，找到最小的数； 思路 使用二分查找； 将mid和high位置比较； 如果是有重复数字，将high自减； 代码 12345678910111213141516class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int low = 0, high = nums.size() - 1, mid = 0; while (low &lt; high)&#123; // 正常情况下，查找会用=的条件，然后low指向恰好大的位置，high指向恰好小的位置； mid = low + (high - low) / 2; if (nums[mid] &lt; nums[high]) //不能和low比较，因为mid取值时是取整，可能会取到和low相同的值,此时比值只会相等， //但是却有两种情况[1,2]和[2,1]，无法区分 high = mid; //此处不能+1,可能mid处是最小值 else low = mid + 1; // low如果不加1的话最后不能收敛 &#125; return nums[high]; &#125;&#125;; 1234567891011121314151617class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int low = 0, high = nums.size()-1, mid = 0; // 内置类型在函数内部不会进行初始化 while (low &lt; high)&#123; mid = low + (high - low) / 2; if (nums[mid] &lt; nums[high]) high = mid; else if (nums[mid] &gt; nums[high]) low = mid + 1; else --high; &#125; return nums[high]; &#125;&#125;; 162.Find Peak Element题目大意 给定一个山峰数组，即先升序后降序。求数组的山峰。 思路 二分 nums[mid] &lt; nums[mid+1] : low = mid + 1 (因为循环条件是low&lt;high，所以只有low==high时mid才会越界，此时已经跳出循环了) nums[mid] &gt; nums[mid+1] : high = mid 12345678910111213141516class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; // nums.push_back(INT_MIN); int low =0, high = nums.size()-1, mid; while (low &lt; high)&#123; mid = low + (high - low) / 2; // 只有low和high相等时才会出现mid=high的情况，此时已经跳出循环 if (nums[mid] &lt; nums[mid+1]) low = mid + 1; else high = mid; &#125; return low; &#125;&#125;; 33.Search in Rotated Sorted Array81.Search in Rotated Sorted Array II题目大意 在一个循环排序数组中，查找是否存在某个数。 思路 二分 nums[low] &lt;= nums[mid] 此时 low到mid是递增区间 如果 nums[low] &lt;= target &lt; nums[mid] : high = mid - 1 low = mid + 1 （此时，target位于mid+1和high之间） nums[low] &gt; nums[mid] 此时 mid到high是递增区间 如果 nums[mid] &lt; target &lt;= nums[high] : low = mid + 1 high = mid - 1; 如果有重复的数，导致 nums[mid] == nums[low] == nums[high] 无法判断，则low++ high— 继续循环 12345678910111213141516171819202122232425class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return -1; int low=0, high=nums.size()-1, mid; while (low &lt;= high)&#123; mid = low + (high - low) / 2; if (nums[mid] == target) return mid; // 在没有重复情况下，nums[mid]==nums[low]意味着收敛到low和mid之间了，不应该再去mid和high之间了 if (nums[mid] &gt;= nums[low])&#123; // 考虑target和边界相等的情况，此时target就是落在这个区间内 if (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) high = mid - 1; else low = mid + 1; &#125;else&#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) low = mid + 1; else high = mid - 1; &#125; &#125; return -1; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return false; int low=0, high=nums.size()-1, mid; while(low &lt;= high)&#123; mid = low + (high - low) / 1; if (nums[mid] == target) return true; if (nums[mid] == nums[low] &amp;&amp; nums[mid] == nums[high]) &#123; low++; high--; &#125; else if (nums[low] &lt;= nums[mid])&#123; if (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) high = mid - 1; else low = mid + 1; &#125;else&#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) low = mid + 1; else high = mid - 1; &#125; &#125; return false; &#125;&#125;; Bit Operation136.Single Number题目大意 给定一个数组，只有一个数出现一次，其他都出现两次，返回只出现一次的数 思路 异或 相同的数异或为0，最后只剩下单独的数 12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for (int i=0; i!=nums.size(); ++i)&#123; res ^= nums[i]; &#125; return res; &#125;&#125;; 137.Single Number II题目大意 给定一个数组，只有一个数出现一次，其他都出现三次，返回出现一次的数 思路 对每一位进行计数，只需要 00、01和10即可，循环为00-01-10-00 对于出现三次的位一定会被消除，所以，最后剩下的就是只出现一次的数 只有三种情况，只需要ones和twos两位即可满足计数要求 更新规则 ones ^ nums[i]，当nums[i]是1时，ones需要更新，此时，如果twos == 1，ones更新为0(10-00)，否则ones更新为1(00-01) twos ^ nums[i]，当nums[i]是1时，twos需要更新，此时，如果ones == 0，twos变为1，否则不变 对于出现次数是5的情况同样处理 1234567891011class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ones = 0, twos = 0; for (int i=0; i!=nums.size(); ++i)&#123; ones = ones^nums[i] &amp; ~twos; twos = twos^nums[i] &amp; ~ones; &#125; return ones; &#125;&#125;; 1234567891011121314class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int tmp=0, res=0; for (int i=0; i!=32; ++i)&#123; tmp = 0; for (auto num:nums)&#123; tmp += (num &gt;&gt; i) &amp; 1; &#125; res |= (tmp % 3) &lt;&lt; i; &#125; return res; &#125;&#125;; 260.Single Number III题目大意 给定一个数组，有两个数字出现次数是1次，其他数字均出现两次，求出现1次的两个数 思路 先异或，找到两个出现次数为1的数字的不同的位 找到两个数字某个不同的位(diff &amp; ~(diff - 1)) 根据这个位将原数组分为两部分，必然两个数会分开 两个数组分别异或，找到两个出现1次的数 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int diff = 0; vector&lt;int&gt; res(2, 0); for (int i=0; i!=nums.size(); ++i) diff ^= nums[i]; diff &amp;= ~(diff-1); for (int i=0; i!=nums.size(); ++i)&#123; if (nums[i] &amp; diff) res[0] ^= nums[i]; else res[1] ^= nums[i]; &#125; return res; &#125;&#125;; string151.Reverse Words in a String题目大意 给定一个包含词的字符串，将词顺序翻转 思路 三个指针i，j，l。i是头指针，j是要将nums[i]移动到的位置，l是上一次的位置，翻转的时候要用 首先要去除多余的空格 如果前面有word需要加空格 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void reverseWords(string &amp;s) &#123; int i=0, j=0, l=0, n=s.size(); int count=0; while (i&lt;n)&#123; while (i&lt;n &amp;&amp; s[i]==' ') i++; if (i==n) break; if (count) s[j++] = ' '; l = j; while (i&lt;n &amp;&amp; s[i]!=' ')&#123; s[j++] = s[i++]; &#125; reverse_str(s, l, j-1); count++; &#125; s.resize(j); reverse_str(s, 0, j-1); &#125;private: void reverse_str(string &amp;s, int i, int j)&#123; if (i&lt;0 || i &gt;= s.size() || j&lt;0 || j &gt;=s.size()) return; while (i &lt; j)&#123; char t = s[i]; s[i++] = s[j]; s[j--] = t; &#125; &#125;&#125;; 左旋转字符串题目大意 给定一个字符串和n，将字符串前n位左移。如给定abcde和2，则返回cdeab 思路 可以理解为，前n个字符是一个单词，后面的字符为另一个单词，相当于翻转单词的问题 12345678910111213141516171819class Solution &#123;public: string LeftRotateString(string str, int n) &#123; if (str.size()&gt;0 &amp;&amp; n&gt;0 &amp;&amp; n&lt;str.size())&#123; reverseString(str, 0, n-1); reverseString(str, n, str.size()-1); reverseString(str, 0, str.size()-1); &#125; return str; &#125;private: void reverseString(string &amp;input, int left, int right)&#123; while (left&lt;right)&#123; char tmp = input[left]; input[left++] = input[right]; input[right--] = tmp; &#125; &#125;&#125;; DP最长公共子序列题目大意 给定两个字符串，找到最长公共子序列。子序列的不一定需要是连续的 思路 动态规划，dp[i][j]记录s前i个字符串和t前j个字符串的最长公共子序列； dp[i][j]=dp[i-1][j-1] if(A[i-1]==B[j-1]) dp[i][j]=max(dp[i-1][j], dp[i][j-1]) if (A[i-1] != B[j-1]) 123456789101112131415161718192021222324class Solution &#123;public: /** * @param A: A string * @param B: A string * @return: The length of longest common subsequence of A and B */ int longestCommonSubsequence(string &amp;A, string &amp;B) &#123; // write your code here int m = A.size(), n = B.size(); vector&lt;vector&lt;int&gt; &gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for (int i=1; i&lt;=m; ++i)&#123; for (int j=1; j&lt;=n; ++j)&#123; // 注意下标和dp下标区别 if (A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; return dp[m][n]; &#125;&#125;; 最长公共子串题目大意 给定两个字符串s和t，求s和t的最大公共子串的长度。 思路 同上使用动态规划，dp[i][j]记录s前i个字符串和t前j个字符串的最长公共子串； dp[i][j]=dp[i-1][j-1] if(A[i-1]==B[j-1]) dp[i][j]=0 if (A[i-1] != B[j-1]) 同时，使用res记录全程最大的子串。 1234567891011121314151617181920212223class Solution &#123;public: /** * @param A: A string * @param B: A string * @return: the length of the longest common substring. */ int longestCommonSubstring(string &amp;A, string &amp;B) &#123; // write your code here int m = A.size(), n = B.size(), res = 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for (int i=1; i&lt;=m; ++i)&#123; for (int j=1; j&lt;=n; ++j)&#123; if (A[i-1] == B[j-1])&#123; dp[i][j] = dp[i-1][j-1] + 1; res = max(res, dp[i][j]); &#125; &#125; &#125; return res; &#125;&#125;; 322.Coin Change题目大意 给定一些钱币面值和总钱数，求能够凑出总钱数的最小钱币数。 思路 动态规划，dp[count] = min(dp[count-1], dp[count-2]…) + 1 1234567891011121314151617181920class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1, -1); dp[0] = 0; int coins_len = coins.size(), cur = INT_MAX, last; for (int i=1; i&lt;=amount; ++i)&#123; int tmp = INT_MAX; for (int j=0; j!=coins_len; ++j)&#123; last = i - coins[j]; if (last &gt;= 0 &amp;&amp; dp[last] &gt; -1)&#123; tmp = min(tmp, dp[last]); &#125; &#125; if (tmp != INT_MAX) dp[i] = tmp + 1; &#125; return dp[amount]; &#125;&#125;; 62.Unique Paths题目大意 给定一个m n的矩阵，求左上角到达右下角的路径数量有多少 思路 动态规划，dp[i][j] = dp[i-1][j] + dp[i][j-1] 123456789101112131415class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); for (int i=0; i!=m; ++i) dp[i][0] = 1; for (int j=0; j!=n; ++j) dp[0][j] = 1; for (int i=1; i!=m; ++i)&#123; for (int j=1; j!=n; ++j) dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; return dp[m-1][n-1]; &#125;&#125;; 416.Partition Equal Subset Sum题目大意 给定一个(非空、正数)数组，判断是否能将数组分为两个部分，两个部分和相等。 思路 使用动态规划，数组和为sum，则dp[i]记录是否有一部分元素和为i，返回dp[sum/2]即可。(如果数组有负数，那么dp数组就没有范围限制了) dp[0] = true, 如果dp[i-num[k]]为true，则dp[i] = true 123456789101112131415161718class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum &amp; 1) return false; sum = sum &gt;&gt; 1; vector&lt;bool&gt; dp(sum+1, false); dp[0] = true; for (int i=0; i!=nums.size(); ++i)&#123; // 必须从sum开始，否则会nums[i]会被重复使用，比如2、4、6。。。 for (int j=sum; j&gt;0; --j)&#123; if (j-nums[i] &gt;=0 &amp;&amp; dp[j-nums[i]]) dp[j] = true; &#125; &#125; return dp[sum]; &#125;&#125;; 698.Partition to K Equal Sum Subsets题目大意 给定一个数组，判断是否能分成和相等的k部分。 思路 使用dfs，先找到一组元素使得和为sum/k，然后再递归剩下的元素是否能分为k-1组，递归结束条件为k==1(存在k-1组和为sum / k的数组那么剩下的一组必然为sum / k) 123456789101112131415161718192021222324class Solution &#123;public: bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % k) return false; sum = sum / k; vector&lt;int&gt; visited(nums.size(), 0); return dfs(nums, visited, 0, 0, k, sum); &#125;private: bool dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; visited, int start, int sum, int k, int target)&#123; if (k==1) return true; // 新的part，从头开始考虑 if (sum == target) return dfs(nums, visited, 0, 0, k-1, target); // 找到和为target的数组，如果前面的不可以，则后面不需要再考虑这些数了 for (int i=start; i&lt;nums.size(); ++i)&#123; if (visited[i]) continue; visited[i] = 1; if (dfs(nums, visited, i+1, sum+nums[i], k, target)) return true; visited[i] = 0; &#125; return false; &#125;&#125;; 5.Longest Palindromic Substring题目大意 求字符串的最长回文字符串。 思路 动态规划 暴力法：遍历所有子串，判断是否为回文子串。在判断子串是否为回文子串过程中，有很多重复的判断，此处可以用动态规划 dp[i][j]表示i到j是否为回文串，此时dp[i][j]可以通过dp[i+1][j-1]和判断s[i] == s[j]来计算 提前计算dp[i][i]和dp[i][i+1]位置的对称性 奇数和偶数回文串两种情况 在此过程中，记录最长的回文串的开始位置和长度 Manacher算法 https://articles.leetcode.com/longest-palindromic-substring-part-ii/ 将字符串aaxsd变成^#a#a#x#s#d#$，#的目的是将奇数长度和偶数长度的回文字符串都变成奇数长度的回文字符串，^和$是为了防止越界问题。 使用p[i] 记录i位置回文串的单边长度，在计算过程中，可以利用对称性简化计算 中心位置是c，对称半径是r 如果i位于半径r内，可以通过对称位置计算 如果对称位置的回文长度没有超过r-i那么p[i] = p[mirror_i] 如果超过了，则p[i] = r-c，同时从r位置继续判断是否为回文串 如果在半径外，直接计算 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; int max_len = 1, start=0; int n=s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, (vector&lt;int&gt;(n))); for (int i=0; i!=n; ++i)&#123; dp[i][i] = 1; if (i+1&lt;n &amp;&amp; s[i]==s[i+1])&#123; dp[i][i+1] = 1; if (max_len &lt; 2)&#123; start = i; max_len = 2; &#125; &#125; &#125; for (int i=n-2; i&gt;=0; --i)&#123; for (int j=i+2; j&lt;n; ++j)&#123; if (dp[i+1][j-1] &amp;&amp; s[i]==s[j])&#123; dp[i][j] = 1; if (j - i &gt;= max_len)&#123; start = i; max_len = j - i + 1; &#125; &#125; &#125; &#125; return s.substr(start, max_len); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; string t = preprocess(s); int len = t.size(); vector&lt;int&gt; p(len); int c = 0, r = 0; for (int i=0; i!=len; ++i)&#123; int mirror = 2 * c - i; p[i] = r &gt; i ? min(r-i, p[mirror]) : 0; while (t[i+1+p[i]] == t[i-1-p[i]]) p[i]++; if (p[i] + i &gt; r)&#123; c = i; r = p[i] + i; &#125; &#125; int max_pos=0, max_len=0; for (int i=0; i!=len; ++i)&#123; if (max_len &lt; p[i])&#123; max_len = p[i]; max_pos = i; &#125; &#125; return s.substr((max_pos-1-max_len)/2, max_len); &#125;private: string preprocess(string s)&#123; string res = "@"; for (int i=0; i!=s.size(); ++i)&#123; res += "#"; res += s[i]; &#125; res += "#$"; return res; &#125;&#125;; 300.Longest Increasing Subsequence题目大意 给定一个数组，找到最长的递增子序列。 思路 动态规划，$O(n^2)$时间复杂度，$O(n^2)$空间复杂度 dp[i]表示前 i 个数的最长递增子序列 每次更新时，遍历0到 i-1的数，如果比nums[j]大，则可以构成新的递增子序列，序列长度为dp[j]+1，将最大值作为dp[i] 遍历过程中记录最大值 $O(nlogn)$时间复杂度，$O(n)$空间复杂度 遍历过程中维护一个S数组，数组维护的是各个长度LIS的最小尾部 遍历数组，找到S中不小于nums[i]的最小值， 如果找到了，则替换该值， 如果比S中最大值还大，直接append即可 最后，S的长度就是最长递增子序列的长度 12345678910111213141516171819class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int n = nums.size(), len, max_len=1; vector&lt;int&gt; dp(n, 1); for (int i=1; i&lt;n; ++i)&#123; len = 0; for (int j=0; j&lt;i; ++j)&#123; if (nums[i] &gt; nums[j])&#123; len = max(len, dp[j]); &#125; &#125; dp[i] = len + 1; max_len = max(dp[i], max_len); &#125; return max_len; &#125;&#125;; 12345678910111213141516// nlognclass Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; vector&lt;int&gt;::iterator it = nums.begin(), tmp; for (int i=0; i!=nums.size(); ++i)&#123; tmp = lower_bound(nums.begin(), it, nums[i]); *tmp = nums[i]; if (tmp == it)&#123; it++; &#125; &#125; return it - nums.begin(); &#125;&#125;; 674. Longest Continuous Increasing Subsequence题目大意 给定一个数组，找到最长的连续升序序列 思路 遍历，因为是连续序列，所以尽可能记录升序序列的长度，如果断了就重新计数，在此过程中记录最大值即可 123456789101112131415class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int max_len=1, len=1, n = nums.size(); for (int i=0; i&lt;n-1; ++i)&#123; if (nums[i] &lt; nums[i+1]) len++; else len = 1; max_len = max(max_len, len); &#125; return max_len; &#125;&#125;; 198.House Robber题目大意 给定一个正数数组，要求相邻的数不能同时取得，问选取的数和最大是多少。 思路 dp[i] = max(dp[i-1], dp[i-2]+nums[i])动态规划值 只需要用a、b两个数，存储奇数和偶数位置的最大结果 a = max(a+nums[i], b) &amp;&amp; b = max(b+nums[i], b) 1234567891011121314class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int a = 0, b = 0; for (int i=0; i!=nums.size(); ++i)&#123; if (i%2)&#123; a = max(b, a+nums[i]); &#125;else&#123; b = max(a, b+nums[i]); &#125; &#125; return max(a, b); &#125;&#125;; 123456789101112131415161718class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int n = nums.size(); vector&lt;int&gt; dp(n+1); dp[1] = nums[0]; for (int i=2; i&lt;=n; ++i)&#123; if (i-1&gt;=0)&#123; dp[i] = max(dp[i], dp[i-1]); &#125; if (i-2&gt;=0)&#123; dp[i] = max(dp[i], dp[i-2]+nums[i-1]); &#125; &#125; return dp[n]; &#125;&#125;; 213. House Robber II题目大意 给定一个正数数组，要求相邻的数以及首尾的数不能同时取得，问选取的数和最大是多少。 思路 乍看上去，首尾的情况不太好处理。如果分两次遍历，一次掐头，一次 去尾。取两次的最大值即可。 12345678910111213141516171819202122class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int n = nums.size(); // 对于数组长度为1的情况后面的函数无法处理，需要简单处理下边界 if (n == 1) return nums[0]; return max(find(nums, 0, n-1), find(nums, 1, n)); &#125;private: int find(vector&lt;int&gt;&amp; nums, int s, int e)&#123; int a = 0, b = 0; for (int i=s; i&lt;e; ++i)&#123; if (i%2)&#123; a = max(a+nums[i], b); &#125;else&#123; b = max(b+nums[i], a); &#125; &#125; return max(a, b); &#125;&#125;; 337. House Robber III题目大意 小区的布局变成了二叉树的形式，父亲和孩子不能同时被偷。问最多能偷多少。 思路 相同的思路，每个位置有被偷或者不被偷两种情况。res[0] = left[1] + right[1] + root-&gt;val和res[1] = max(left[0], left[1]) + max(right[0], right[1]) 1234567891011121314151617class Solution &#123;public: int rob(TreeNode* root) &#123; pair&lt;int, int&gt; res = dfs(root); return max(res.first, res.second); &#125;private: pair&lt;int, int&gt; dfs(TreeNode* root)&#123; if (root==NULL) return make_pair(0, 0); pair&lt;int, int&gt; res; pair&lt;int, int&gt; left = dfs(root-&gt;left); pair&lt;int, int&gt; right = dfs(root-&gt;right); res.first = left.second + right.second + root-&gt;val; res.second = max(left.first, left.second) + max(right.first, right.second); return res; &#125;&#125;; 121. Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: 1234Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) 题目大意 给定一个数组，下标为i的数表示股票在第i天的价格。如果最多只能操作一次（买、卖一次），请问最多能挣多少钱。 思路 从头到尾遍历，dp[i-1][0]为前 i-1 天的最低价位，如果第i天价位不高于dp[i-1][0], 则dp[i][0] = prices[i]； 否则，计算出第i天卖出的最大利润 profit=prices[i] - dp[i-1][0]，前i天能达到的最大利润为dp[i][1] = max(profit, dp[i-1][1])。 其实因为这个情况很简单，所以可以考虑不用数组去做，只需要一个记录之前的股票最小值，以及之前的利润最大值即可。 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int res=0, last=prices[0]; for (int i=0; i&lt;prices.size(); ++i)&#123; if (last &lt; prices[i])&#123; res = max(res, prices[i] - last); &#125;else&#123; last = prices[i]; &#125; &#125; return res; &#125;&#125;; 122. Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目大意 可以完成尽可能多次的交易，请问最大获益是多少。 思路 这种情况很简单，用贪心去做，只要能赚钱我就交易即可。 即，只要上一天的价格低于当天的价格，就在上一天买入在当天卖出。 两种情况： 若第三天的价格高于当天价格，那么在今天买入第三天卖出，效果和贪心是一样的； 若第三天价格低于当天价格，那么就应该在当天卖出；所以应该用贪心的思路做。 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int res=0, last=prices[0]; for (int i=0; i&lt;prices.size(); ++i)&#123; if (last &lt; prices[i])&#123; res += prices[i]-last; last = prices[i]; &#125;else&#123; last = prices[i]; &#125; &#125; return res; &#125;&#125;; 123. Best Time to Buy and Sell Stock III题目大意 只能完成两次交易，那么最大收益是多少。 思路 第一种思路： 想了很久，画了一条曲线，其实两次交易相当于在中间找到一个局部最高点，在这个最高点后面又找到一个局部最低点，而我们可以去遍历所有的数，将每个数作为最高点（前一次卖出）和最低点（后一次买入）的分割点，在遍历的过程中记录收益的最大值即可。 思路很简单，分割以后，分别用题I的解法去做就可以了。但是，此时会重复遍历很多次，第i天为分割点，为了找到第一次交易的最大收益，需要遍历前i天，而这前i天中有i-1天是上一次已经遍历过的了，所以这种方法会超时。 第二种思路： 如上面的分析，这种重复的情况可以用一个dp数组去存储第i天为分割点时，前i天的股票最大收益和后n-i+1天的最大收益，这样就不需要进行重复计算了，时间效率大大提高。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(), res=0; vector&lt;int&gt; left_dp(n), right_dp(n), left_max(n), right_max(n); // 从前往后遍历第一次卖得位置 for (int i=0; i&lt;n; ++i)&#123; if (i&gt;0 &amp;&amp; left_dp[i-1] &lt; prices[i])&#123; left_max[i] = max(left_max[i-1], prices[i]-left_dp[i-1]); left_dp[i] = left_dp[i-1]; &#125;else&#123; if (i&gt;0) left_max[i] = left_max[i-1]; left_dp[i] = prices[i]; &#125; &#125; // 从后往前遍历第二次买的位置 for (int i=n-1; i&gt;=0; --i)&#123; if (i&lt;n-1 &amp;&amp; right_dp[i+1] &gt; prices[i])&#123; right_max[i] = max(right_max[i+1], right_dp[i+1] - prices[i]); right_dp[i] = right_dp[i+1]; &#125;else&#123; if (i&lt;n-1) right_max[i] = right_max[i+1]; right_dp[i] = prices[i]; &#125; &#125; // 根据第一次卖得位置和第二次买的位置求得最佳的分割点 for (int i=0; i!=n; ++i)&#123; res = max(res, left_max[i]+right_max[i]); &#125; return res; &#125;&#125;; 188. Best Time to Buy and Sell Stock IV题目大意 最多k次交易，请问最大收益是多少。 思路 不会做。参考大神的思路，使用循环引用的动态规划。 must_sell[i][k] 表示 第i天必须卖出且至多交易k次的最大收益。global_max[i][k] 表示 截止到第i天至多交易k次的最大收益。 状态转移方程： must_sell[i][k] = max(global_max[i-1][k-1] + profit, must_sell[i-1][k] + profit) (第i天卖出且至多交易k次的最大收益为：前i-1天至多交易k-1次的最大收益 和 第i-1天必须卖出至多交易k次的最大收益 的较大值 加上第i天卖出的收益。） global_max[i][k] = max(global_max[i-1][k], must_sell[i][k]) (前i天至多交易k次的最大收益为：前i-1天至多交易k次的最大收益 和 第i天必须卖出至多交易k次的最大收益 的较大者。) 123456789101112131415161718192021222324252627282930class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(), res=0; if (n == 0 || k == 0) return 0; // 当可以交易的次数足够多 if (k &gt; n / 2)&#123; for (int i=1; i!=n; ++i)&#123; if (prices[i-1] &lt; prices[i])&#123; res+= prices[i] - prices[i-1]; &#125; &#125; return res; &#125; // must_sell[i][k] 必须卖出prices[i]且交易次数最多是k的 最大收益 vector&lt;vector&lt;int&gt;&gt; must_sell(n, vector&lt;int&gt;(k+1)); // global_sell[i][k] 进行到prices[i](不一定卖出)且交易次数最多是k的 最大收益 vector&lt;vector&lt;int&gt;&gt; global_sell(n, vector&lt;int&gt;(k+1)); for (int i=1; i&lt;n; ++i)&#123; int profit = prices[i] - prices[i-1]; for (int kk=1; kk&lt;k+1; ++kk)&#123; must_sell[i][kk] = max(global_sell[i-1][kk-1] + profit, must_sell[i-1][kk] + profit); global_sell[i][kk] = max(global_sell[i-1][kk], must_sell[i][kk]); &#125; &#125; return global_sell[n-1][k]; &#125;&#125;;c 72. Edit Distance题目大意 计算两个字符串之间的编辑距离。word1通过删除、插入和替换三种操作变为word2，操作需要的次数即为编辑距离。 思路 动态规划 if str[i-1]==str[j-1]: dp[i][j] = dp[i-1][j-1] if str[i-1]!=str[j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 123456789101112131415161718192021class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(), n = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1)); for (int i=0; i&lt;=m; ++i) dp[i][0] = i; for (int i=0; i&lt;=n; ++i) dp[0][i] = i; for (int i=1; i&lt;=m; ++i)&#123; for (int j=1; j&lt;=n; ++j)&#123; if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else&#123; dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
