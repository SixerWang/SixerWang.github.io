<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer笔记]]></title>
    <url>%2F2018%2F08%2F13%2Fsword2offer%2F</url>
    <content type="text"><![CDATA[1. 二维数组中的查找题目大意 一个二维数组，每一行都是递增的，每一列也是递增的。给定一个数，判断该二维数组中是否含有该数。 思路 从右上角开始，如果当前数大于target则往左边走一步，如果小于，则往下走一步，直到找到或者找不到该数为止。 123456789101112131415161718class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; if (array.empty()) return false; int m = array.size(), n = array[0].size(); int i = 0, j = n - 1; while (i &lt; m &amp;&amp; j &gt;= 0)&#123; if (array[i][j] == target) return true; if (array[i][j] &lt; target) ++i; else --j; &#125; return false; &#125;&#125;; 相关题目 74. Search a 2D Matrix 按行递增 2. 替换空格题目大意 将字符串中的空格替换为 %20 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void replaceSpace(char *str,int length) &#123; if (str == NULL || length &lt;= 0) return; int cur_len=0, blank_num=0; int i=0; while(str[i]!='\0')&#123; cur_len++; if (str[i] == ' ') blank_num++; i++; &#125; // strlen 不会将'\0'计算在内 int total_len = cur_len + blank_num*2; if (total_len &gt; length) return; int p1 = cur_len, p2 = total_len; while(p2&gt;=0 &amp;&amp; p2&gt;=p1)&#123; if (str[p1] != ' ') str[p2--] = str[p1--]; else&#123; str[p2--] = '0'; str[p2--] = '2'; str[p2--] = '%'; p1--; &#125; &#125; &#125;&#125;; 3. 从尾到头打印链表思路 使用栈或者使用递归 123456789101112131415class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; result; tailToHead(head, result); return result; &#125;private: void tailToHead(ListNode* cur, vector&lt;int&gt; &amp;result)&#123; if (cur == NULL) return; tailToHead(cur-&gt;next, result); result.push_back(cur-&gt;val); &#125;&#125;; 4. 重建一颗二叉树题目大意 根据前序和中序遍历的结果，恢复一棵二叉树，二叉树不含重复节点。 123456789101112131415161718192021class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt;&amp; pre,vector&lt;int&gt; vin) &#123; if (vin.empty()) return NULL; int val = pre[0]; TreeNode* root = new TreeNode(val); vector&lt;int&gt;::iterator it = vin.begin(); for (; it!=vin.end(); ++it)&#123; if (*it == val) break; &#125; pre = vector&lt;int&gt;(pre.begin()+1, pre.end()); vector&lt;int&gt; left(vin.begin(), it); vector&lt;int&gt; right(it+1, vin.end()); root-&gt;left = reConstructBinaryTree(pre, left); root-&gt;right = reConstructBinaryTree(pre, right); return root; &#125;&#125;; 5. 两个栈实现一个队列思路 stack2存储从stack1中pop出来的数，这样stack2的栈顶就是最开始push进stack1的数。 123456789101112131415161718192021222324252627class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; if (stack2.empty() &amp;&amp; !stack1.empty())&#123; while (!stack1.empty())&#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; if (!stack2.empty())&#123; int res = stack2.top(); stack2.pop(); return res; &#125; return -1; &#125; private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 6. 旋转数组中的最小数字题目大意 在一个旋转排序数组中寻找最小的数(456123) 思路 和最后一个数比 high下标的处理 重复数的处理 123456789101112131415161718class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; if (rotateArray.empty()) return -1; int low=0, high=rotateArray.size()-1, mid=0; while(low &lt; high)&#123; mid = low + (high - low) / 2; if (rotateArray[mid] &lt; rotateArray[high]) high = mid; else if (rotateArray[mid] &gt; rotateArray[high]) low = mid + 1; else high--; &#125; return rotateArray[low]; &#125;&#125;; 7. 斐波那契数思路 注意不要用递归，因为递归有很多的重复计算。 123456789101112131415class Solution &#123;public: int Fibonacci(int n) &#123; if (n == 0) return 0; if (n &lt;= 2) return 1; int last_one = 1, last_two = 1, res = 0; for (int i=2; i&lt;n; ++i)&#123; res = last_one + last_two; last_two = last_one; last_one = res; &#125; return res; &#125;&#125;; 8. 跳台阶12345678910111213class Solution &#123;public: int jumpFloor(int number) &#123; int last_one = 1, last_two = 1; for (int i=2; i&lt;=number; ++i)&#123; int t = last_one; last_one = last_one + last_two; last_two = t; &#125; return last_one; &#125;&#125;; 9. 变态跳台阶题目大意 每次可以跳1-n级台阶，问跳到n级台阶，一共有多少种跳法。 思路 列举n的几种情况可知，每次都是前一次的两倍的种数。 1234567891011class Solution &#123;public: int jumpFloorII(int number) &#123; int last = 1; for (int i=2; i&lt;=number; ++i)&#123; last *= 2; &#125; return last; &#125;&#125;; 10. 矩形覆盖题目大意 使用n个2 1的小矩形覆盖2 n的大矩形，一共有多少种方法。 123456789101112131415class Solution &#123;public: int rectCover(int number) &#123; if (number == 0) return 0; if (number == 1) return 1; int last_one = 1, last_two = 1, res = 0; for (int i=2; i&lt;=number; ++i)&#123; res = last_one + last_two; last_two = last_one; last_one = res; &#125; return res; &#125;&#125;; 11. 二进制中1的个数题目大意 给定一个32位无符号整数，求该整数二级制形式1的个数。 思路 遍历每一位，记录1的个数即可。 不要使用除操作，耗时较久，使用移位和与操作。 如果是有符号整数，可能会导致循环无法结束，可以左移1来遍历。 n &amp; (n-1)的操作能够将最右边的1变为0，可以将所有的1都变为0，需要的次数即为1的个数。 12345678910111213class Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0; while (n)&#123; if (n &amp; 1) ++sum; n = n &gt;&gt; 1; &#125; return sum; &#125;&#125;; 123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0; while (n)&#123; ++sum; n = (n-1) &amp; n; &#125; return sum; &#125;&#125;; 1234567891011121314// consider signed intclass Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0, flag = 1; while (flag)&#123; if (flag &amp; n) ++sum; flag = flag &lt;&lt; 1; &#125; return sum; &#125;&#125;; 12. 数的整数次方题目大意 实现标准库中的pow运算。 思路 考虑一些边界条件以及优化 指数为负的情况； 底为零指数为负的情况，不能做除法； int的指数变负为正时，考虑最大的负数变为整数会越界； 提高效率，将$2^{2k+1}$装换为$2^k$的平方乘2 1234567891011121314151617181920212223242526272829class Solution &#123;public: double myPow(double x, int n) &#123; // float和double类型的比较不能直接比较 // 考虑底为零的情况 if ((x - 0.0) &lt; 0.0000001 &amp;&amp; (x - 0.0) &gt; -0.000000001) return x; double res = 1.0; // 考虑为负的情况 if (n &lt; 0)&#123; x = 1 / x; // 考虑越界 if (n == INT_MIN)&#123; res *= x; n += 1; &#125; n = -n; &#125; while (n)&#123; // &amp; 和 移位运算替代取余和除法 if (n &amp; 1) res *= x; n &gt;&gt;= 1; x *= x; &#125; return res; &#125;&#125;; 13. 使得数组的奇数位于偶数前面题目大意 给定一个数组，调整数的顺序，使得偶数都在奇数后面，且奇数和偶数内部的相对位置不变。 思路 遍历数组，将两个奇数之间的偶数往后挪动一个位置，挪出的位置放置后一个奇数。 1234567891011121314151617class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; if (array.size() &lt;= 1) return; for (int i=0; i!=array.size(); ++i)&#123; // 如果是偶数奇数的情况，讲两个奇数之间的偶数往后移动一位，放置奇数 if (i!=0 &amp;&amp; (array[i]&amp;1) &amp;&amp; !(array[i-1]&amp;1))&#123; int tmp = array[i], j; for (j=i; j&gt;0 &amp;&amp; !(array[j-1]&amp;1); --j)&#123; array[j] = array[j-1]; &#125; array[j] = tmp; &#125; &#125; &#125;&#125;; 14. 链表中的倒数第k个结点思路 使用快慢指针，对于k越界情况的处理。 12345678910111213141516171819class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if (pListHead == NULL) return NULL; ListNode* fast = pListHead, *low = pListHead; for (int i=0; i&lt;k; ++i)&#123; if (fast) fast = fast-&gt;next; else return NULL; &#125; while (fast)&#123; low = low-&gt;next; fast = fast-&gt;next; &#125; return low; &#125;&#125;; 15. 翻转链表123456789101112131415class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; if (pHead == NULL || pHead-&gt;next == NULL) return pHead; ListNode *p = NULL, *q = pHead, *t = NULL; while (q)&#123; t = q-&gt;next; q-&gt;next = p; p = q; q = t; &#125; return p; &#125;&#125;; 16. 合并排序链表思路 如果某条链表已经排序完，剩下链表的合并可以放到while内部也可以放到外面，外面效率更高。 123456789101112131415161718192021222324252627class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; ListNode fake(0); ListNode*cur= &amp;fake; while (pHead1 &amp;&amp; pHead2)&#123; if (pHead1-&gt;val &lt; pHead2-&gt;val)&#123; cur-&gt;next = pHead1; pHead1 = pHead1-&gt;next; &#125; else &#123; cur-&gt;next = pHead2; pHead2 = pHead2-&gt;next; &#125; cur = cur-&gt;next; &#125; if (pHead1)&#123; cur-&gt;next = pHead1; &#125; if (pHead2)&#123; cur-&gt;next = pHead2; &#125; return fake.next; &#125;&#125;; 17. 树的子结构题目大意 给定两棵二叉树A和B，判断B是不是A的子结构。认为空树不是任意一棵树的子结构。 注意此题和subtree of another tree不同，A的子树B要求B的根节点是A中的某个结点，且叶子结点是A的叶子结点。 子结构只需要在B的结构在A中出现过即可。 思路 遍历A的每个节点作为B的根节点，如果遍历完所有节点仍然没有找到A的子结构是B，那么就返回false 12345678910111213141516class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if (!pRoot1 || !pRoot2) return false; if ((!pRoot1 &amp;&amp; pRoot2) || (pRoot1 &amp;&amp; !pRoot2)) return false; return (isSame(pRoot1, pRoot2) || HasSubtree(pRoot1-&gt;left, pRoot2) || HasSubtree(pRoot1-&gt;right, pRoot2)); &#125;private: bool isSame(TreeNode* p1, TreeNode* p2)&#123; if (!p2) return true; if ((!p1 &amp;&amp; p2) || (p1 &amp;&amp; !p2)) return false; return (p1-&gt;val == p2-&gt;val) &amp;&amp; isSame(p1-&gt;left, p2-&gt;left) &amp;&amp; isSame(p1-&gt;right, p2-&gt;right); &#125;&#125;; 18. 二叉树的镜像思路 左子树右子树交换，且左子树和右子树的子树再继续交换。 123456789101112class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (!pRoot) return; TreeNode* t = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = t; Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); &#125;&#125;; 19. 顺时针打印矩阵题目大意 给定一个二维矩阵，返回顺时针打印的结果。 思路 传入左上角和右下角的坐标，每次打印这一圈的结果。这样一圈一圈的将矩阵打印出来。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; vector&lt;int&gt; result; if (matrix.empty()) return result; int m = matrix.size(), n = matrix[0].size(); int x1 = 0, y1 = 0, x2 = m - 1, y2 = n - 1; while (x1 &lt;= x2 &amp;&amp; y1 &lt;= y2)&#123; myPrint(matrix, result, x1++, y1++, x2--, y2--); &#125; return result; &#125;private: void myPrint(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, vector&lt;int&gt; &amp;result, int x1, int y1, int x2, int y2)&#123; for (int i=y1; i&lt;=y2; ++i)&#123; result.push_back(matrix[x1][i]); &#125; for (int i=x1+1; i&lt;=x2; ++i)&#123; result.push_back(matrix[i][y2]); &#125; if (x2 &gt; x1)&#123; for (int i=y2-1; i&gt;=y1; --i)&#123; result.push_back(matrix[x2][i]); &#125; &#125; if (y1 &lt; y2)&#123; for (int i=x2-1; i&gt;x1; --i)&#123; result.push_back(matrix[i][y1]); &#125; &#125; &#125;&#125;; 20. 包含min函数的栈题目大意 定义一个栈的数据结构，使得可以以O(1)的时间复杂度得到栈中最小元素是多少。 思路 用一个minStack记录每个位置栈中的最小元素 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: void push(int value) &#123; ss.push(value); if (minStack.empty() || value &lt; minStack.top())&#123; minStack.push(value); &#125;else&#123; minStack.push(minStack.top()); &#125; &#125; void pop() &#123; if (!ss.empty())&#123; ss.pop(); minStack.pop(); &#125; &#125; int top() &#123; if (!ss.empty())&#123; return ss.top(); &#125; return -1; &#125; int min() &#123; if (!minStack.empty())&#123; return minStack.top(); &#125; return -1; &#125;private: stack&lt;int&gt; ss; stack&lt;int&gt; minStack;&#125;; 21. 栈的弹出顺序是否合理题目大意 给定两个数组，第一个数组表示入栈的顺序，第二个数组表示出栈的顺序。试判断出栈数组是否合理。 思路 模拟出栈过程，如果栈顶元素不是当前出栈元素，则入栈一直到栈顶元素为出栈元素为止；如果入栈元素都入栈了还找不到出栈元素，则不是一个合理的出栈顺序。 123456789101112131415161718class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; stack&lt;int&gt; tmp; int index = 0; for (int i=0; i!=popV.size(); ++i)&#123; while (index &lt; popV.size() &amp;&amp; (tmp.empty() || tmp.top() != popV[i]))&#123; tmp.push(pushV[index++]); &#125; if (!tmp.empty() &amp;&amp; tmp.top()==popV[i]) tmp.pop(); else return false; &#125; return true; &#125;&#125;; 22. 层次遍历二叉树123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; res; if (root == NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty())&#123; int k = q.size(); for (int i=0; i&lt;k; ++i)&#123; TreeNode* t = q.front(); q.pop(); res.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; &#125; return res; &#125;&#125;; 23. 判断是否是合法的搜索二叉树后序遍历序列题目大意 给定一个序列，判断是否是合法的搜索二叉树的后序遍历序列。 思路 根据后序找到根节点，判断左子树是否都小于根节点，右子树是否多大于根节点。再递归判断左子树和右子树 12345678910111213141516171819202122232425262728class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if (sequence.empty()) return false; int n = sequence.size(), i=0, j=0; bool res = true; for (; i&lt;n-1; ++i)&#123; if (sequence[i] &gt; sequence[n-1]) break; &#125; j = i; for (; j&lt;n-1; ++j)&#123; if (sequence[j] &lt; sequence[n-1]) return false; &#125; if (i &gt; 0)&#123; vector&lt;int&gt; left(sequence.begin(), sequence.begin()+i); res &amp;= VerifySquenceOfBST(left); &#125; if (i &lt; n-1)&#123; vector&lt;int&gt; right(sequence.begin()+i+1, sequence.end()); res &amp;= VerifySquenceOfBST(right); &#125; return res; &#125;&#125;; 24. 二叉搜索树与双向链表题目大意 给定一棵二叉搜索树，将其转换为一个双向链表，要求不能创建新的节点。 思路 递归，转换为三个节点的二叉搜索树 123456789101112131415161718192021222324class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; TreeNode* last = NULL; transfer(pRootOfTree, &amp;last); while (last &amp;&amp; last-&gt;left)&#123; last = last-&gt;left; &#125; return last; &#125;private: void transfer(TreeNode *root, TreeNode **last)&#123; if (!root) return; transfer(root-&gt;left, last); root-&gt;left = *last; if (*last)&#123; (*last)-&gt;right = root; &#125; *last = root; transfer(root-&gt;right, last); &#125;&#125;; 25. 二叉树中和为某一值的路径题目大意 找出二叉树中所有路径和为给定值的路径，路径的开始和结束分别是是根节点和叶子节点。 思路 递归 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; tmp; if (!root) return result; myFindPath(root, expectNumber, result, tmp); return result; &#125;private: void myFindPath(TreeNode* root, int sum, vector&lt;vector&lt;int&gt; &gt;&amp; res, vector&lt;int&gt;&amp; tmp)&#123; if (!root) return; if (root-&gt;val == sum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)&#123; tmp.push_back(root-&gt;val); res.push_back(tmp); tmp.pop_back(); return; &#125; tmp.push_back(root-&gt;val); if (root-&gt;left)&#123; myFindPath(root-&gt;left, sum-root-&gt;val, res, tmp); &#125; if (root-&gt;right)&#123; myFindPath(root-&gt;right, sum-root-&gt;val, res, tmp); &#125; tmp.pop_back(); &#125;&#125;; 26. 复杂链表复制题目大意 带有random指针的链表的复制 思路 使用cache记录复制前后节点的对应关系 插空 拆分法 123456789101112131415161718192021222324252627class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; RandomListNode copyHead(0); RandomListNode *p1 = pHead, *p2 = &amp;copyHead; map&lt;RandomListNode*, RandomListNode*&gt; cache; while(p1)&#123; p2-&gt;next = new RandomListNode(p1-&gt;label); cache[p1] = p2-&gt;next; p2 = p2-&gt;next; p1 = p1-&gt;next; &#125; p1 = pHead; p2 = copyHead.next; while(p1)&#123; if (p1-&gt;random)&#123; p2-&gt;random = cache[p1-&gt;random]; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; return copyHead.next; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if (pHead == NULL) return pHead; RandomListNode* p = pHead; while (p)&#123; RandomListNode* t = p-&gt;next; p-&gt;next = new RandomListNode(p-&gt;label); p = p-&gt;next; p-&gt;next = t; p = p-&gt;next; &#125; RandomListNode *p1 = pHead, *copy = pHead-&gt;next, *p2 = copy; while(p1)&#123; if (p1-&gt;random)&#123; p1-&gt;next-&gt;random = p1-&gt;random-&gt;next; &#125; p1 = p1-&gt;next-&gt;next; &#125; p1 = pHead; while(p1)&#123; p1-&gt;next = p2-&gt;next; p1 = p1-&gt;next; if (p1)&#123; p2-&gt;next = p1-&gt;next; p2 = p2-&gt;next; &#125; &#125; return copy; &#125;&#125;; 27. 字符串全排列题目大意 没有重复字符的字符串全排列 有重复字符的字符串全排列 没有重复字符的字符全组合(不一定用上所有字符,且不考虑组合之间的字母顺序，如12和21属于同一种) 有重复字符的字符全组合 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;string&gt; Permutation(string str) &#123; int n = str.size(); vector&lt;int&gt; visited(n, 0); vector&lt;string&gt; res; if (n == 0) return res; sort(str.begin(), str.end()); string tmp = ""; dfs(str, res, visited, tmp); return res; &#125;private: void dfs(string str, vector&lt;string&gt;&amp; res, vector&lt;int&gt;&amp; visited, string tmp)&#123; if (tmp.size() == str.size())&#123; res.push_back(tmp); return; &#125; for (int i=0; i!=str.size(); ++i)&#123; if (visited[i] == 1) continue; if (i!=0 &amp;&amp; visited[i-1] == 0 &amp;&amp; str[i-1] == str[i]) continue; visited[i] = 1; dfs(str, res, visited, tmp+str[i]); visited[i] = 0; &#125; &#125;&#125;; 28. 数组中出现次数超过一半的数题目大意 如果数组中存在一个数，出现次数超过数组长度的一半，则输出该数；如果不存在则输出0 思路 计数法 记录当前数出现的次数，如果下一个数与当前数不等，次数则减1 如果存在该数，则最后记录的数就是出现次数超过一半的数 需要遍历一遍数组，判断该数出现的次数 按位计数法 对每一位进行统计，如果该位出现1的次数超过数组长度的一半，设置最后返回的结果该位为1； 最后判断位计数的结果是否是真的出现了超过数组长度一半的次数 123456789101112131415161718192021222324class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.empty()) return 0; int num = numbers[0], times = 1; for (int i=1; i&lt;numbers.size(); ++i)&#123; if (times == 0)&#123; num = numbers[i]; &#125; if (num != numbers[i])&#123; times--; &#125;else&#123; times++; &#125; &#125; times = 0; for (int i=0; i&lt;numbers.size(); ++i)&#123; if (numbers[i] == num) times++; &#125; return times &gt; numbers.size() / 2 ? num : 0; &#125;&#125;; 123456789101112131415161718192021222324class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; int mask = 1, bitCount = 0, res = 0; for (int i=0; i&lt;32; ++i)&#123; for (int j=0; j&lt;numbers.size(); ++j)&#123; if (numbers[j] &amp; mask)&#123; bitCount++; &#125; &#125; if (bitCount &gt; numbers.size()/2)&#123; res |= mask; &#125; bitCount = 0; mask = mask &lt;&lt; 1; &#125; for (int i=0; i&lt;numbers.size(); ++i)&#123; if (res == numbers[i]) bitCount++; &#125; return bitCount &gt; numbers.size() / 2 ? res : 0; &#125;&#125;; 补充 给定一个长度为n的数组，找出数组中出现次数超过n/3的数(https://leetcode.com/problems/majority-element-ii/description/) 29. 最小的k个数题目大意 经典的题目，找到数组中最小的k个数 思路 使用最大堆 使用快排思想的partition(牛客网的IDE很坑爹，k存在=-1的测试样例) 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; res; if (k &gt; input.size()) return res; priority_queue&lt;int&gt; q; for (int i=0; i&lt;input.size(); ++i)&#123; q.push(input[i]); if (q.size() &gt; k) q.pop(); &#125; for (int i=0; i&lt;k; ++i)&#123; res.push_back(q.top()); q.pop(); &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; // 略坑，k的输入是可能小于0的，据我观察这个小于0的值就是-1 // 1. 直接在外面判断 k &lt;= 0 // 2. 在外面判断k==input.size() 将mid == k-1 改为mid==k也可以通过 // 因为 k=-1,而mid最小是可以到达-1的，因此可以通过。所以猜测k的最小值是-1 if (k &gt; input.size() || k &lt;= 0) return vector&lt;int&gt;(); int mid = 0, n = input.size(); int low = 0, high = n - 1; while (1)&#123; mid = partition(input, low, high); if (mid == k-1)&#123; break; &#125;else if (mid &lt; k-1)&#123; low = mid + 1; &#125;else&#123; high = mid - 1; &#125; &#125; return vector&lt;int&gt;(input.begin(), input.begin()+k); &#125;private: int partition(vector&lt;int&gt; &amp;nums, int low, int high)&#123; int t = nums[low]; while (low &lt; high)&#123; while (low &lt; high &amp;&amp; nums[high] &gt; t) high--; if (low &lt; high)&#123; nums[low++] = nums[high]; &#125; while (low &lt; high &amp;&amp; nums[low] &lt; t) low++; if (low &lt; high)&#123; nums[high--] = nums[low]; &#125; &#125; nums[low] = t; return low; &#125;&#125;; 30. 连续子数组的最大和给定一个有正有负的整数数组，要求连续子数组的最大和是多少。 12345678910111213141516class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; int result = INT_MIN, sum = 0; for (int i=0; i&lt;array.size(); ++i)&#123; if (sum &gt; 0)&#123; sum += array[i]; &#125;else&#123; sum = array[i]; &#125; result = max(result, sum); &#125; return result; &#125;&#125;; 31. 从1到n整数中1出现的次数题目大意 统计从1到n整数中1出现的次数。 思路 123456789101112131415class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int base = 1, a = 0, b = 0; int res = 0; for (; base&lt;=n; base *= 10)&#123; a = n / base; b = n % base; res += (a + 8) / 10 * base + (a % 10 == 1 ? b+1 : 0); &#125; return res; &#125;&#125;; 32. 将数组的数拼接成最小的数题目大意 将数组中的数拼接组成一个数，要求返回数字形式最大的。 123456789101112131415bool cmp(int a, int b)&#123; return to_string(a) + to_string(b) &lt; to_string(b) + to_string(a);&#125;class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; sort(numbers.begin(), numbers.end(), cmp); string result = ""; for (int i=0; i&lt;numbers.size(); ++i)&#123; result += to_string(numbers[i]); &#125; return result; &#125;&#125;; 33. 计算从小到大顺序的第n个丑数题目大意 丑数定义：只包含质因子 2、3、5的数。默认认为1是第一个丑数 思路 新的丑数 肯定是某个丑数 乘以2 或 乘以3 或 乘以5的结果，所以记录乘2、乘3、乘5的在丑数序列中的位置，每次取得最小的作为新的丑数即可。 1234567891011121314151617class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt; 1) return 0; vector&lt;int&gt; cache(index); cache[0] = 1; int index2 = 0, index3 = 0, index5 = 0; for (int i=1; i&lt;index; ++i)&#123; cache[i] = min(cache[index2] * 2, min(cache[index3] * 3, cache[index5] * 5)); if (cache[i] == cache[index2] * 2) index2++; if (cache[i] == cache[index3] * 3) index3++; if (cache[i] == cache[index5] * 5) index5++; &#125; return cache[index-1]; &#125;&#125;; 34. 第一次只出现一次的字符题目大意 找到字符串中第一次只出现一次的字符 思路 先统计字符串中每个字符出现的次数，再重新遍历字符串，第一个字符出现次数为1的字符即为所求字符。 123456789101112131415class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; map&lt;char, int&gt; cache; for (int i=0; i!=str.size(); ++i)&#123; cache[str[i]]++; &#125; for (int i=0; i!=str.size(); ++i)&#123; if (cache[str[i]] == 1) return i; &#125; return -1; &#125;&#125;; 35. 数组中的逆序对题目大意 给定一个数组，统计数组中的逆序对数量，一个逆序对定义为：后面的数比前面的数小则成为一对逆序对。 思路 普通思路是遍历整个数组，每次都会去和前面的每个数比较，在比较的过程中记录逆序对的个数。该方法的时间复杂度是 $O(n^2)$ 使用归并排序的方法，在归并的过程中，统计逆序对个数。因为归并排序时，前后两个数组是有序的，所以当前一个数组的某个数比后一个数组某个数大时，那么后一个数组该数以及该数之前的数都可以构成逆序对，可以快速进行计算。时间复杂度为 $O(nlogn)$ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; int n = data.size(); vector&lt;int&gt; tmp(n, 0); return mergeSort(data, tmp, 0, n) % 1000000007; &#125;private: long mergeSort(vector&lt;int&gt; &amp;data, vector&lt;int&gt; &amp;tmp, int s, int e)&#123; // 如何tmp不使用引用就会超时，不懂是为什么 // 在每次申请临时tmp时，申请e-s长度的tmp而不是data.size()长度的tmp即可通过 // 可能是因为data太大的原因。 // 其实也是，能复用tmp就尽量复用吧，复制耗时比较多 int length = e - s, m = 0; long left = 0, right = 0, count = 0; if (length &gt; 1)&#123; m = s + (e - s) / 2; left = mergeSort(data, tmp, s, m); right = mergeSort(data, tmp, m, e); int s1 = m-1, s2 = e-1, cur = e-1; //vector&lt;int&gt; tmp(length, 0); while (s1 &gt;= s &amp;&amp; s2 &gt;= m)&#123; if (data[s1] &gt; data[s2])&#123; count += s2 - m + 1; tmp[cur--] = data[s1--]; &#125;else tmp[cur--] = data[s2--]; &#125; while (s1 &gt;= s) tmp[cur--] = data[s1--]; while (s2 &gt;= m) tmp[cur--] = data[s2--]; for (int i=s; i!=e; ++i) data[i] = tmp[i]; &#125; return left + right + count; &#125;&#125;; 36. 两个链表的第一个公共节点题目大意 给定两个链表，找到链表的第一个公共节点 思路 将两个链表各自的首尾相连，各自在各自的链表上前进，当两个指针相遇时，就是第一个公共节点。 需要判断是否有公共部分： 提前在外面判断，即判断两个链表最后一个节点是否相同即可 在while内部判断，需要进行两次判断，一次判断是否是第一个公共节点，一个判断是否存在公共节点，我们假设在两个链表后面插入一个空节点，空节点相当于两条链表的公共节点，如果相遇在空节点上，则没有公共节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; if (pHead1 == NULL || pHead2 == NULL) return NULL; ListNode *low = pHead1, *high = pHead2; while (low != high)&#123; low = low-&gt;next; high = high-&gt;next; if (low == high) return low; // 如果相遇到为空的点，那么两个链表不存在公共节点 // 空节点说明到达了尾部，要跳过空节点，进入到头节点 // 注意，不能将该步骤移到while的开始部分，while需要两次判断low和high是否相等 // 第一次是判断是不是公共节点，第二次是判断是不是有公共节点 if (low == NULL) low = pHead1; if (high == NULL) high = pHead2; &#125; return low; &#125;&#125;;class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; if (!pHead1 || !pHead2) return NULL; ListNode *p1 = pHead1, *p2 = pHead2; while(p1-&gt;next)&#123; p1 = p1-&gt;next; &#125; while (p2-&gt;next)&#123; p2 = p2-&gt;next; &#125; if (p1 != p2) return NULL; p1 = pHead1; p2 = pHead2; while (p1 != p2)&#123; if (p1-&gt;next)&#123; p1 = p1-&gt;next; &#125;else&#123; p1 = pHead1; &#125; if (p2-&gt;next)&#123; p2 = p2-&gt;next; &#125;else&#123; p2 = pHead2; &#125; &#125; return p1; &#125;&#125;; 37. 数字在排序数组中出现的次数题目大意 排序数组，很容易就想到用二分法。根据二分法的判断条件不同，使得最后high指针分别停留在数字区间的两端，这样将两次的high指针指向的位置相减就是区间数字的个数。 12345678910111213141516171819202122class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int low = 0, high = data.size() - 1, mid = 0; int start = 0; while (low &lt;= high)&#123; mid = low + (high - low) / 2; if (data[mid] &lt; k) low = mid + 1; else high = mid - 1; &#125; start = high; low = 0; high = data.size() - 1; while (low &lt;= high)&#123; mid = low + (high - low) / 2; if (data[mid] &lt;= k) low = mid + 1; else high = mid - 1; &#125; return high - start; &#125;&#125;; 38. 二叉树的最大深度题目大意 二叉树的深度指的就是最大深度；可能也会求二叉树的最小深度。 1234567891011class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if (!pRoot) return 0; if (!pRoot-&gt;left) return 1 + TreeDepth(pRoot-&gt;right); if (!pRoot-&gt;right) return 1 + TreeDepth(pRoot-&gt;left); return 1 + max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right)); &#125;&#125;; 39. 判断一棵树是否为平衡二叉树题目大意 判断一棵树是否为平衡二叉树。 思路 平衡二叉树的定义： 左子树和右子树的高度差不超过1 左子树和右子树也是平衡二叉树 根据概念定义，有两个需要递归判断的部分，一个是左子树和右子树的高度差，一个是左子树和右子树是不是均为平衡二叉树。 在判断左子树和右子树高度时，可以考虑使用缓存，因为有大量的重复计算。 1234567891011121314151617181920212223class Solution &#123;public: bool IsBalanced_Solution(TreeNode* pRoot) &#123; if (!pRoot) return true; int left = getHeight(pRoot-&gt;left); int right = getHeight(pRoot-&gt;right); return abs(left - right) &lt;= 1 &amp;&amp; IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right); &#125;private: int getHeight(TreeNode* root)&#123; if (!root) return 0; if (cache.find(root) != cache.end())&#123; return cache[root]; &#125; int left = getHeight(root-&gt;left); int right = getHeight(root-&gt;right); int result = max(left, right) + 1; cache[root] = result; return result; &#125; map&lt;TreeNode*, int&gt; cache;&#125;; 40. 数组中只出现一次的数字题目大意 给定一个数组，只有两个数字出现过一次，其他数字都出现过两次，找出只出现一次的两个数。 思路 将数组分为两个部分，一部分包含其中一个只出现过一次的数字，这样可以通过异或的方式得到只出现一次的数字。 找到两个只出现过一次的数字的不同的位，根据该不同的位去划分两个数组即可。 123456789101112131415161718class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int flag = 0; for (int i=0; i&lt;data.size(); ++i)&#123; flag ^= data[i]; &#125; flag = flag &amp; (flag ^ (flag - 1)); for (int i=0; i&lt;data.size(); ++i)&#123; if (data[i] &amp; flag)&#123; *num1 ^= data[i]; &#125;else&#123; *num2 ^= data[i]; &#125; &#125; &#125;&#125;; 41. 和为S的连续正序列题目大意 给定一个整数，返回所有连续和为该整数的正整数序列。 思路 连续整数序列因为是对称的，所以序列和可以简化为 N * 平均值。 序列长度为偶数时，平均值的小数位是0.5((sum % n) * 2 == n)，当序列长度为奇数时，平均值为整数(sum % n == 0)。 根据序列长度可以找到序列的第一个整数是多少。 遍历可能的序列长度，[2, sum / 2 + 1](3是特殊情况，所以是闭区间) 根据求和公式 $s = (1+n) * \frac{n}{2}$ 得到 $n = \sqrt{2n}$，所以区间为[2, $\sqrt{2n}$] 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; tmp; for (int i = sum / 2 + 1; i &gt;= 2 ; --i) &#123; if (i &amp; 1) tmp = is_odd(sum, i); else tmp = is_even(sum, i); if (!tmp.empty()) res.push_back(tmp); &#125; return res; &#125;private: vector&lt;int&gt; is_odd(int sum, int i) &#123; vector&lt;int&gt; res; float mid = sum / float(i); if (sum / i - mid &lt; 0.000000001 &amp;&amp; sum / i - mid &gt; -0.0000000001) &#123; int start = sum / i - (i - 1) / 2; if (start &lt;= 0) return res; for (int k = 0; k &lt; i; ++k) res.push_back(start++); &#125; return res; &#125; vector&lt;int&gt; is_even(int sum, int i) &#123; vector&lt;int&gt; res; float mid = sum / float(i); if (mid - sum / i - 0.5 &lt; 0.0000000001 &amp;&amp; mid - sum / i - 0.5 &gt; -0.0000000001) &#123; int start = sum / i - i / 2 + 1; if (start &lt;= 0) return res; for (int k = 0; k &lt; i; ++k) res.push_back(start++); &#125; return res; &#125;&#125;; 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (sum &lt;= 2) return result; int start; // 优化1：根据求和公式计算上边界 for (int count=sqrt(2*sum); count&gt;=2; --count)&#123; vector&lt;int&gt; tmp; // 优化2：精简每次的判断条件 if (count % 2 &amp;&amp; (sum % count) == 0)&#123; start = sum / count - count / 2; &#125; else if ((count % 2) == 0 &amp;&amp; (sum % count) * 2 == count)&#123; start = sum / count - count / 2 + 1; &#125; else continue; if (start &lt;= 0) continue; for (int i=0; i&lt;count; ++i)&#123; tmp.push_back(start++); &#125; result.push_back(tmp); &#125; return result; &#125;&#125;; 42. 和为S的两个数题目大意 给定一个排序数组和一个整数sum，要求乘积最小的和为sum的两个数 思路 和相同的两个数，两个数字差值越大乘积越小，所以直接low、high指针从头尾开始找，找到的第一对满足条件的两个数则为最终结果 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; if (array.empty()) return vector&lt;int&gt;(); vector&lt;int&gt; res(2); int low = 0, high = array.size()-1; while (low &lt; high)&#123; if (array[low] + array[high] == sum)&#123; res[0] = array[low++]; res[1] = array[high--]; break; &#125;else if (array[low] + array[high] &lt; sum)&#123; low++; &#125;else&#123; high--; &#125; &#125; return res[0] + res[1] == sum ? res : vector&lt;int&gt;(); &#125;&#125;; 43. 左旋转字符串题目大意 给定一个字符串，向左旋转n位。如给定xyzabc，左旋转3位得到abcxyz 思路 和反转词序的题思路相同，可以将xyz部分和abc部分做了一次翻转。 123456789101112131415161718192021class Solution &#123;public: string LeftRotateString(string str, int n) &#123; int len = str.size(); if (len &lt;= n) return str; reverseStr(str, 0, n-1); reverseStr(str, n, len-1); reverseStr(str, 0, len-1); return str; &#125;private: void reverseStr(string &amp;str, int s, int e)&#123; char t; while (s &lt; e)&#123; t = str[s]; str[s++] = str[e]; str[e--] = t; &#125; &#125;&#125;; 44. 翻转单词顺序思路 先翻转单词内部的字母顺序，再翻转整个字符串的顺序 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string ReverseSentence(string str) &#123; int cur1 = 0, cur2 = 0, last = 0; int len = str.size(); int count = 0; while(cur2 &lt; len)&#123; if (str[cur2] == ' ')&#123; cur2++; continue; &#125; if (count &gt; 0) str[cur1++] = ' '; last = cur1; while (cur2 &lt; len &amp;&amp; str[cur2] != ' ')&#123; str[cur1++] = str[cur2++]; &#125; count++; reverseStr(str, last, cur1-1); &#125; reverseStr(str, 0, len-1); return str; &#125;private: void reverseStr(string &amp;str, int s, int e)&#123; while (s &lt; e)&#123; char t = str[s]; str[s++] = str[e]; str[e--] = t; &#125; &#125;&#125;; 45. 扑克牌顺子题目大意 给定一些牌，0可以表示任意一张牌，问这些牌是否能凑成顺子。 思路 考虑0的个数，以及需要填充的gap的个数，判断0是否能填充这些gap 如果有两种非零牌相同，那么必然无法凑成顺子了。 12345678910111213141516171819class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; if (numbers.empty()) return false; sort(numbers.begin(), numbers.end()); int zero=0, gap=0; for (int i=0; i!=numbers.size(); ++i)&#123; if (numbers[i] == 0) zero++; if (i!=0 &amp;&amp; numbers[i-1] != 0)&#123; if (numbers[i-1] == numbers[i]) return false; else gap += numbers[i] - numbers[i-1] - 1; &#125; &#125; return zero &gt;= gap; &#125;&#125;; 46. 约瑟夫环题目大意 0-n-1个人围成一个圈，从0喊到m-1，m-1的人被淘汰。然后从下一个人开始继续，请问最后活下来的是哪个人 思路 推导 f(n,m)表示n个小朋友，第m个人出局剩下的最后一个人;g(n-1, m)表示淘汰了f(n,m)中第m个人后按照规则剩下的那个人；f(n,m) = g(n-1,m) = (f(n-1, m) + m) % n 下标差了m递推公式f(n,m) = (f(n-1, m) + m)% n 12345678910111213class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (n == 0 || m == 0) return -1; int last = 0; for (int i=2; i&lt;=n; ++i)&#123; last = (last + m) % i; &#125; return last; &#125;&#125;; 123456789101112131415161718192021222324class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (n == 0 || m == 0) return -1; map&lt;int, int&gt; cache; for (int i=0; i&lt;n-1; ++i)&#123; cache[i] = i+1; &#125; cache[n-1] = 0; int cur = 0, last = 0; for (int i=0; i&lt;n-1; ++i)&#123; for (int j=1; j&lt;m; ++j)&#123; last = cur; cur = cache[cur]; &#125; cache[last] = cache[cur]; cur = cache[last]; &#125; return cur; &#125;&#125;; 47. 1+2+…+n题目大意 求1+2…+n，要求不能使用循环、乘除和判断语句 思路 可以考虑使用递归，用短路原则结束递归。 12345678class Solution &#123;public: int Sum_Solution(int n) &#123; n &amp;&amp; (n += Sum_Solution(n-1)); return n; &#125;&#125;; 48. 不用加减乘除做加法题目大意 在不用+、-、*、\的基础上实现加法操作 思路 两个数num1和num2相加 n1 = num1&amp;num2的结果表示两个数该位上都是1，则需要进位，可以用左移操作替代 n2 = num1^num2的结果表示两个数位上只有一个位置是1 n1 &amp; n2 如果为零，说明不需要再进位了，那么n1 | n2就是最终求和的结果；否则一直继续1和2步骤 1234567891011121314class Solution &#123;public: int Add(int num1, int num2) &#123; int carry = 0; while (num1 &amp; num2)&#123; carry = (num1 &amp; num2) &lt;&lt; 1; num1 = num1 ^ num2; num2 = carry; &#125; return num1 | num2; &#125;&#125;; 49. atoi题目大意 atoi，不是合法数值的返回0 123456789101112131415161718192021222324class Solution &#123;public: int StrToInt(string str) &#123; if (str.empty()) return 0; int res = 0, cur = 0, sign = 1; while(cur &lt; str.size() &amp;&amp; str[cur] == ' ') cur++; if (cur &lt; str.size() &amp;&amp; (str[cur] == '+' || str[cur] == '-'))&#123; sign = (str[cur] == '-') ? -1 : 1; cur++; &#125; while (cur &lt; str.size())&#123; if (str[cur]&lt;'0' || str[cur]&gt;'9') return 0; int tmp = str[cur] - '0'; if (sign == 1 &amp;&amp; (res &gt; INT_MAX / 10 || res == INT_MAX / 10 &amp;&amp; tmp &gt;= INT_MAX % 10)) return INT_MAX; if (sign == -1 &amp;&amp; (res &gt; INT_MAX / 10 || res == INT_MAX / 10 &amp;&amp; tmp &gt;= INT_MAX % 10 + 1)) return INT_MIN; res = res * 10 + tmp; cur++; &#125; return res * sign; &#125;&#125;; 50. 数组中的重复数字题目大意 在一个长度为n的数组中，数字的大小都在0到n-1之间。其中有若干个数字是重复的，重复的次数并不知道。 思路 注：只有一个重复数字的数组，找到重复数字的方法总结： 如果可以改变原数组 排序 做标记 如果可以使用额外的空间 hash 既要求不能改变原数组，又要求空间复杂度O(1)，且时间复杂度小于O(n^2) 判断循环链表的入口 1234567891011121314151617181920class Solution &#123;public: bool duplicate(int numbers[], int length, int* duplication) &#123; // we can't use minus to flag 0 int cur = 0, index = 0; for (int i=0; i&lt;length; ++i)&#123; index = numbers[i]; if (index &gt;= length) index -= length; if (numbers[index] &gt;= length)&#123; *duplication = index; return true; &#125; cur = index; numbers[index] = length + numbers[index]; &#125; return false; &#125;&#125;; 51. 构建乘积数组题目大意 给定一个数组A，返回数组B，B[i] = A[1] A[2]…A[i-1] A[i+1]… 不可以使用除法。 思路 如果暴力的话就是$n^2$复杂度了。可以考虑两个数组，一个数组存储左边所有数的乘积，一个数组存储右边所有数的乘积，这样两个数组对应位置相乘就是最后的B数组了。 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; int n = A.size(); if (n &lt;= 1) return A; vector&lt;int&gt; forward(n), backward(n); forward[0] = 1; backward[n - 1] = 1; for (int i = 1; i &lt; n; ++i) &#123; forward[i] = forward[i - 1] * A[i-1]; cout &lt;&lt; forward[i] &lt;&lt; " "; &#125; for (int i = n - 2; i &gt;= 0; --i) &#123; backward[i] = backward[i + 1] * A[i+1]; &#125; for (int i = 0; i &lt; n; ++i) forward[i] *= backward[i]; return forward; &#125;&#125;; 52. 正则表达式匹配题目大意 匹配符号包括’.’和’*’,分别匹配任意字符和他之前的字符匹配任意次(包括0次) 思路 暴力匹配？？？ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool match(char* str, char* pattern) &#123; char tmp; while (*str != '\0')&#123; // 如果当前是.或者相等，则同时++ if (*pattern == '.' || *str == *pattern)&#123; tmp = *pattern; str++; pattern++; continue; &#125; // 如果不等，但是当前pattern是*，则判断是不是和前面一个相同或者是不是前一个pattern是. if (*pattern == '*')&#123; if (tmp == '.' || *str == tmp)&#123; tmp = *str; str++; continue; &#125;else&#123; pattern++; continue; &#125; &#125; // 如果当前就是匹配不上，判断下一个是不是*，如果是则跳过两个pattern if (*(pattern+1) == '*')&#123; pattern = pattern + 2; &#125;else return false; &#125; if (*pattern == '\0' || (*(pattern+1) == '*' &amp;&amp; *(pattern+2) == '\0') || *pattern=='*') return true; return false; &#125;&#125;; 53. 表示数值的字符串题目大意 判断一个字符串是否能表示数字，例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 思路 判断+- Ee .出现的位置是否合法，具体见code 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isNumeric(char* string) &#123; int cursor = 0; int eCount = 0, dotCount = 0; while (*string != '\0')&#123; if (*string == '+' || *string =='-')&#123; // +- 只会出现在开头或者eE的后面 if (!(cursor == 0 || (*(string-1) == 'e' || *(string-1) == 'E'))) return false; &#125; else if ((*string == 'e') || (*string == 'E'))&#123; // eE 不会出现在开头，不能同时出现两次，且不能出现在最后 if (cursor != 0 &amp;&amp; eCount == 0 &amp;&amp; *(string+1) != '\0')&#123; eCount++; &#125;else return false; &#125; else if (*string == '.')&#123; // . 不会出现在开头，不能出现两次，不能出现在eE后面 if (cursor != 0 &amp;&amp; dotCount == 0 &amp;&amp; eCount == 0)&#123; dotCount++; &#125;else return false; &#125; // 不能出现除了 +- eE . 数字之外的字符 else if (*string &gt; '9' || *string &lt; '0') return false; cursor++; string++; &#125; return true; &#125;&#125;; 54. 字符流中第一个不重复的字符题目大意 两个接口，一个接口可以向字符流中插入字符，一个接口返回当前字符流中第一个不重复的字符。 思路 两个要求，我们得知道字符流来的顺序，第二我们得知道哪些字符已经不是出现两次了。 map存储字符出现的次数，queue存储字符流，队头是第一个不重复的字符。 每当字符流来的时候，我们需要将队头出现不止一次的字符pop掉直到维持队头是第一个不重复的字符。 1234567891011121314151617181920class Solution&#123;public: //Insert one char from stringstream void Insert(char ch) &#123; count[ch]++; q.push(ch); while (!q.empty() &amp;&amp; count[q.front()] &gt; 1) q.pop(); &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; return q.empty() ? '#' : q.front(); &#125;private: map&lt;char, int&gt; count; queue&lt;char&gt; q;&#125;; 55. 链表中环的入口节点题目大意 给定一个链表，如果有环，返回环的入口节点，否则输出null。 思路 经典题，但是low和high必须同时从头节点开始，且判断是否有环时 while的条件不能是 low!=high 12345678910111213141516171819202122class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == NULL) return pHead; ListNode* low = pHead, *high = pHead; while (high)&#123; low = low-&gt;next; high = high-&gt;next; if (high) high = high-&gt;next; if (low == high) break; &#125; if (high == NULL) return NULL; low = pHead; while (low != high)&#123; low = low-&gt;next; high = high-&gt;next; &#125; return low; &#125;&#125;; 56. 删除排序链表中的重复节点题目大意 给定一个排序链表，删除链表中的重复节点。比如1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5的结果是1-&gt;2-&gt;5. 思路 新建头节点 如果cur和cur-&gt;next相等，则一直删除重复节点直到不等为止，然后last指向第一个不等节点，继续循环 如果不等，则last指向当前节点，并将last和cur指针向后移动一位。 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; ListNode head(0); head.next = pHead; ListNode *last = &amp;head, *cur = pHead, *t; while (cur &amp;&amp; cur-&gt;next)&#123; if (cur-&gt;val == cur-&gt;next-&gt;val)&#123; int val = cur-&gt;val; while (cur &amp;&amp; cur-&gt;val == val)&#123; t = cur; delete cur; cur = t-&gt;next; &#125; last-&gt;next = cur; &#125;else&#123; last = cur; cur = cur-&gt;next; &#125; &#125; return head.next; &#125;&#125;; 57. 二叉树的下一个节点题目大意 给定一个二叉树的某个节点，返回中序遍历的后一个节点。每个节点不仅有左子树、右子树，还有指向父节点的指针。 思路 是否有右子树 有，则后一个节点是右子树的最深处的左节点 没有 如果是父节点的左子树，那么父节点就是后一个节点 如果没有父节点，那么该节点是中序遍历的最后一个节点 如果是父节点的右子树，找到父节点的父节点的右子树，如果没有右子树就继续向上找，直到找到父节点的右子树为止，否则该节点是中序遍历的最后一个节点 1234567891011121314151617181920212223242526272829303132333435/*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; if (!pNode) return pNode; if (!pNode-&gt;right)&#123; if (!pNode-&gt;next) return pNode-&gt;next; if (pNode-&gt;next-&gt;left == pNode) return pNode-&gt;next; pNode = pNode-&gt;next; while (pNode)&#123; if (pNode-&gt;next &amp;&amp; pNode == pNode-&gt;next-&gt;left) return pNode-&gt;next; if (!pNode-&gt;next) return pNode-&gt;next; pNode = pNode-&gt;next; &#125; &#125; TreeLinkNode *cur = pNode-&gt;right; while (cur &amp;&amp; cur-&gt;left)&#123; cur = cur-&gt;left; &#125; return cur; &#125;&#125;; 123456789101112131415161718192021222324252627282930class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; // 如果NULL if (!pNode) return pNode; // 如果为根节点或者有右子树，则一定是返回右子树的最左边的子节点 if (!pNode-&gt;next || pNode-&gt;right)&#123; TreeLinkNode *t = pNode-&gt;right; while (t &amp;&amp; t-&gt;left)&#123; t = t-&gt;left; &#125; return t; &#125; // 如果是父节点的左节点，直接返回父节点 if (pNode == pNode-&gt;next-&gt;left)&#123; return pNode-&gt;next; // 如果是父节点的右节点，需要一直往上找到第一个父节点，父节点的儿子是左节点 &#125;else&#123; while (pNode-&gt;next-&gt;next)&#123; if (pNode-&gt;next == pNode-&gt;next-&gt;next-&gt;left) return pNode-&gt;next-&gt;next; pNode = pNode-&gt;next; &#125; return NULL; &#125; &#125;&#125;; 58. 判断二叉树是否对称12345678910111213141516class Solution &#123;public: bool isSymmetrical(TreeNode* pRoot) &#123; if (!pRoot) return true; return isSame(pRoot-&gt;left, pRoot-&gt;right); &#125;private: bool isSame(TreeNode *left, TreeNode *right)&#123; if (!left &amp;&amp; !right) return true; if (!left || !right) return false; return left-&gt;val == right-&gt;val &amp;&amp; isSame(left-&gt;left, right-&gt;right) &amp;&amp; isSame(left-&gt;right, right-&gt;left); &#125;&#125;; 59. 之字形打印字符串思路 reverse 耗时 直接下标索引 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; res; if (!pRoot) return res; queue&lt;TreeNode*&gt; q; q.push(pRoot); TreeNode* cur; int flag = 1; while (!q.empty())&#123; vector&lt;int&gt; tmp; int k = q.size(); for (int i=0; i&lt;k; ++i)&#123; cur = q.front(); q.pop(); tmp.push_back(cur-&gt;val); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125; if (flag % 2)&#123; res.push_back(tmp); &#125;else&#123; reverse(tmp.begin(), tmp.end()); res.push_back(tmp); &#125; flag++; &#125; return res; &#125; &#125;; 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (!pRoot) return result; queue&lt;TreeNode*&gt; q; q.push(pRoot); TreeNode *tmp; int k = 0, isOdd = 1; while (!q.empty())&#123; k = q.size(); vector&lt;int&gt; t(k); for (int i=0; i&lt;k; ++i)&#123; tmp = q.front(); q.pop(); if (isOdd)&#123; t[i] = tmp-&gt;val; &#125;else&#123; t[k-i-1] = tmp-&gt;val; &#125; if (tmp-&gt;left) q.push(tmp-&gt;left); if (tmp-&gt;right) q.push(tmp-&gt;right); &#125; result.push_back(t); isOdd = isOdd ^ 1; &#125; return result; &#125; &#125;; 60. 层次遍历二叉树123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (!pRoot) return result; queue&lt;TreeNode*&gt; q; q.push(pRoot); while (!q.empty())&#123; int k = q.size(); vector&lt;int&gt; t; for (int i=0; i&lt;k; ++i)&#123; TreeNode* tmp = q.front(); q.pop(); t.push_back(tmp-&gt;val); if (tmp-&gt;left) q.push(tmp-&gt;left); if (tmp-&gt;right) q.push(tmp-&gt;right); &#125; result.push_back(t); &#125; return result; &#125; &#125;; 61. 序列化二叉树题目大意 序列化、反序列化一棵二叉树 思路 层次遍历序列化 序列化 层次遍历，相邻节点用,隔开，空节点用#表示。 反序列化 新建一个节点塞进队列中，依次读取序列化结果，读取出的两个就是队列头部节点的左子树和右子树 递归的前序遍历 序列化 序列化当前节点，左节点、右节点 反序列化 反序列化当前节点，左子树和右子树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 层次遍历/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: char* Serialize(TreeNode *root) &#123; if (root == NULL) return NULL; string str; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty())&#123; int k = q.size(); for (int i=0; i&lt;k; ++i)&#123; TreeNode *tmp = q.front(); q.pop(); if (tmp == NULL) str += '#'; else&#123; str += to_string(tmp-&gt;val); q.push(tmp-&gt;left); q.push(tmp-&gt;right); &#125; str += ','; &#125; &#125; int length = str.size(); char *res = new char[length+1]; for (int i=0; i&lt;length; ++i)&#123; res[i] = str[i]; &#125; res[length] = '\0'; return res; &#125; TreeNode* Deserialize(char *str) &#123; if (str == NULL) return NULL; TreeNode* res=NULL; queue&lt;TreeNode*&gt; q; while (*str != '\0')&#123; if (q.empty())&#123; res = new TreeNode(get(&amp;str)); q.push(res); str++; continue; &#125; TreeNode *root = q.front(), *left = NULL, *right = NULL; q.pop(); if (*str != '#')&#123; left = new TreeNode(get(&amp;str)); q.push(left); &#125;else str++; str++; if (*str != '#')&#123; right = new TreeNode(get(&amp;str)); q.push(right); &#125;else str++; str++; root-&gt;left = left; root-&gt;right = right; &#125; return res; &#125;private: int get(char **p)&#123; int res = 0; while (**p != ',')&#123; res = 10 * res + (**p - '0'); (*p)++; &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: char* Serialize(TreeNode *root) &#123; if (root == NULL) return NULL; string str; mySerialize(root, str); int length = str.size(); char *res = new char[length + 1]; for (int i=0; i&lt;length; ++i) res[i] = str[i]; res[length] = '\0'; return res; &#125; TreeNode* Deserialize(char *str) &#123; if (str == NULL) return NULL; TreeNode *res = myDeserialize(&amp;str); return res; &#125;private: void mySerialize(TreeNode *root, string &amp;str)&#123; if (root == NULL)&#123; str += '#'; //str += ','; return; &#125; str += to_string(root-&gt;val); str += ','; mySerialize(root-&gt;left, str); mySerialize(root-&gt;right, str); &#125; TreeNode* myDeserialize(char **cur)&#123; if (**cur == '#')&#123; (*cur)++; return NULL; &#125; int num = 0; while (**cur != '\0' &amp;&amp; **cur != ',')&#123; num = 10 * num + (**cur - '0'); (*cur)++; &#125; if (**cur == '\0') return NULL; if (**cur == ',') (*cur)++; TreeNode *root = new TreeNode(num); root-&gt;left = myDeserialize(cur); root-&gt;right = myDeserialize(cur); return root; &#125;&#125;; 62. 二叉搜索树的第k个节点题目大意 给定一棵二叉搜索树，找到从小到大的第k个节点。 思路 中序遍历 1234567891011121314151617181920212223class Solution &#123;public: TreeNode* KthNode(TreeNode* pRoot, int k) &#123; if (!pRoot) return NULL; TreeNode* res = NULL; findK(pRoot, &amp;res, k); return res; &#125;private: void findK(TreeNode *root, TreeNode **res, int &amp;k)&#123; if (!root) return; findK(root-&gt;left, res, k); k--; if (k == 0)&#123; *res = root; return; &#125; findK(root-&gt;right, res, k); &#125; &#125;; 63. 数据流中的中位数题目大意 一个数据流中，求当前数据流的中位数。 思路 二分法 插入时用二分法查找，维持已有数据流的顺序 获取中位数时，根据已有数据流的长度，索引中位数 两个优先级队列 思路比较巧妙，使用一个大顶堆，使用一个小顶堆，而大顶堆存中位数前一半的数，小顶堆存储中位数后一半的数； 这样，如果是偶数个数，那么大顶堆和小顶堆堆顶的平均数就是中位数；如果是奇数个数，那么较多的那个堆的堆顶元素就是中位数 每次插入时，均需要调整堆的高度，使得两个堆的高度差最多只差一个 12345678910111213141516171819202122232425class Solution &#123;public: void Insert(int num) &#123; if (p.empty() || num &lt;= p.top()) p.push(num); else q.push(num); if (p.size() + 1 == q.size()) &#123; p.push(q.top()); q.pop(); &#125; if (p.size() == q.size() + 2)&#123; q.push(p.top()); p.pop(); &#125; &#125; double GetMedian() &#123; return (p.size() == q.size()) ? (p.top() + q.top()) / 2 : p.top(); &#125;private: priority_queue&lt;double, vector&lt;double&gt;, less&lt;double&gt;&gt; p; priority_queue&lt;double, vector&lt;double&gt;, greater&lt;double&gt;&gt; q;&#125;; 64. 滑动窗口的最大值题目大意 给定一个数组和一个窗口大小，依次在数组滑动，返回每个窗口的最大值。 思路 暴力法，暴力滑过各个窗口取得最大值，时间复杂度是O(nk)，每个窗口计算时重复比较了很多数 堆 用一个堆记录当前值的排序顺序，每滑动一个窗口，往堆中插入一个数，堆顶元素即使当前窗口的最大值 问题在于，如何弹出已经超过该窗口的元素。堆中元素包含下标，如果堆顶元素的小标超过了当前窗口的最小小标值，那么就pop掉。 时间复杂度O(nlogk) 双端队列 队列中存储的是降序排列的元素，自然队列头部是当前窗口的最大值，如果当前要插入的元素大于尾部数据，则弹出尾部数据，直到找到比该元素大的数插入； 问题在于，如何判断某个元素是否已经超过了该窗口，此时，可以考虑队列中存储下标，如果下标超过了当前窗口的最小下标，那么就需要pop掉； 1234567891011121314151617181920212223242526struct cmp&#123; bool operator()(pair&lt;int, int&gt; &amp;q, pair&lt;int, int&gt; &amp;p)&#123; return q.first &lt; p.first; &#125;&#125;; class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; vector&lt;int&gt; res; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; q; for (int i=0; i&lt;num.size(); ++i)&#123; q.push(make_pair(num[i], i)); if (i &gt;= size-1)&#123; // 因为size是 unsigned int 所以不能为i-size不会小于0，小于0则溢出 // 所以不能使用 &lt;= i-size 的条件 while (!q.empty() &amp;&amp; q.top().second &lt; i-size+1) q.pop(); res.push_back(q.top().first); &#125; &#125; return res; &#125;&#125;; 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; vector&lt;int&gt; res; deque&lt;int&gt; q; for (int i=0; i&lt;num.size(); ++i)&#123; while (!q.empty() &amp;&amp; num[q.back()] &lt; num[i]) q.pop_back(); q.push_back(i); while (!q.empty() &amp;&amp; q.front() &lt; res.size()) q.pop_front(); if (i &gt;= size - 1)&#123; res.push_back(num[q.front()]); &#125; &#125; return res; &#125;&#125;; 65. 矩阵中路径 题目大意 给定一个字符矩阵，给定一个字符串，判断是否存在某个路径能够组成该字符串，要求路径不能覆盖重复的位置。 思路 dfs遍历，以矩阵每个节点为开始节点，dfs遍历是否存在路径。用一个visited矩阵记录是否已经走过该节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243 class Solution &#123;public: bool hasPath(char* matrix, int rows, int cols, char* str) &#123; if (str == NULL || (rows ==0 &amp;&amp; cols == 0)) return false; vector&lt;vector&lt;char&gt; &gt; maze(rows, vector&lt;char&gt;(cols)); vector&lt;vector&lt;int&gt; &gt; visited(rows, vector&lt;int&gt;(cols)); for (int i=0; i&lt;rows; ++i)&#123; for (int j=0; j&lt;cols; ++j)&#123; maze[i][j] = *matrix; matrix++; &#125; &#125; for (int i=0; i&lt;rows; ++i)&#123; for (int j=0; j&lt;cols; ++j)&#123; visited[i][j] = 1; if (maze[i][j] == *str &amp;&amp; isPath(maze, visited, i, j, str)) return true; visited[i][j] = 0; &#125; &#125; return false; &#125;private: bool isPath(vector&lt;vector&lt;char&gt; &gt; &amp;maze, vector&lt;vector&lt;int&gt; &gt; &amp;visited, int i, int j, char* str)&#123; if (*(str+1) == '\0')&#123; return true; &#125; for (int k=0; k&lt;4; ++k)&#123; int x = i + dir[k][0]; int y = j + dir[k][1]; if (x &gt;=0 &amp;&amp; x &lt; maze.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; maze[0].size() &amp;&amp; visited[x][y]==0 &amp;&amp; *(str+1) == maze[x][y])&#123; visited[x][y] = 1; if (isPath(maze, visited, x, y, str+1)) return true; visited[x][y] = 0; &#125; &#125; return false; &#125; int dir[4][2] = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;&#125;; 66. 机器人的运动范围 题目大意 机器人从(0,0)开始，每次可以往上下左右四个方向走动。每次到的位置不能是横坐标和纵坐标的数位之和超过k的位置。求机器人能达到多少格子。 思路 dfs，同时设置sum的条件。 123456789101112131415161718192021222324252627282930313233343536373839 class Solution &#123;public: int movingCount(int threshold, int rows, int cols) &#123; if (threshold &lt; 0) return 0; int res = 1; vector&lt;vector&lt;int&gt; &gt; visited(rows, vector&lt;int&gt;(cols)); visited[0][0] = 1; calCount(visited, threshold, rows, cols, 0, 0, res); return res; &#125;private: void calCount(vector&lt;vector&lt;int&gt; &gt; &amp;visited, int threshold, int rows, int cols, int x, int y, int &amp;res)&#123; for (int d=0; d&lt;4; ++d)&#123; int xx = x + dir[d][0]; int yy = y + dir[d][1]; if (xx &gt;= 0 &amp;&amp; xx &lt; rows &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; cols &amp;&amp; visited[xx][yy] == 0)&#123; int sum = 0; while (xx) &#123; sum += xx % 10; xx = xx / 10; &#125; while (yy)&#123; sum += yy % 10; yy = yy / 10; &#125; xx = x + dir[d][0]; yy = y + dir[d][1]; visited[xx][yy] = 1; if (sum &lt;= threshold)&#123; res++; calCount(visited, threshold, rows, cols, xx, yy, res); &#125; &#125; &#125; &#125; int dir[4][2] = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;&#125;;]]></content>
      <categories>
        <category>算法题</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自然语言处理基础知识框架]]></title>
    <url>%2F2018%2F08%2F10%2Fnlp-guideline%2F</url>
    <content type="text"><![CDATA[秋招在即，虽然生活艰难，还是需要好好复习。总结一份自己的NLP知识框架。 传统机器学习 逻辑回归 基本概念 逻辑回归的梯度下降公式推导 L1和L2正则的区别 逻辑回归与极大似然估计 逻辑回归与最大熵模型 关系 如何推导 逻辑回归为什么要用sigmoid 逻辑回归与特征离散化、特征交叉 fm 和 ffm算法 决策树 ID3算法 特征选择标准：信息增益 特征选择标准的特点 具体算法 C4.5算法 信息增益比 信息增益比特点 具体算法 CART 二叉树 特征选择标准 决策树：基尼系数 回归树：最小二乘法 具体算法 剪枝 预剪枝 后剪枝 K-近邻 K值选择 距离度量 决策方法 实现方法 kd树 支持向量机 目标函数 对偶问题求解公式推导 核函数 lr和svm的异同 朴素贝叶斯 集成学习 聚类 统计自然语言处理算法 最大熵模型 模型形式 特征约束 最大熵 指数形式 原问题是有约束的最大化问题 通过拉格朗日方程转换为无约束优化问题 最大熵模型和逻辑回归关系 EM算法 基本概念 可以从抛硬币问题开始回忆 E步和M步 两个点 初值敏感 Q函数很重要 EM的收敛性证明 应用场景 聚类算法 HMM的参数训练 语言模型 基本概念 平滑方法 有时间关注基于Transformer的LM HMM 关于马尔科夫过程 一阶马尔科夫链 转移概率矩阵 齐次马氏链 遍历性 HMM的模型定义 三个问题 已知模型-&gt;输出状态概率 前向算法 后向算法 前向和后向算法结合 已知模型和输出状态-&gt;概率最大的隐藏状态 维特比算法 只知道输出状态-&gt;估计模型参数 参数估计问题 EM算法 E步 M步 应用 CRF 为什么要引入条件随机场(CRF和HMM的异同点) HMM是生成式，CRF是判别式 输出序列的相关性 额外的特征 标注偏置 条件随机场的定义 线性链条件随机场 参数化形式 简化形式 矩阵形式 预测算法 改写目标函数，将特征函数合并 维特比算法 学习算法(同最大熵的学习算法) 改进的迭代尺度法 拟牛顿法 word2vec, GloVec Skip-gram CBOW GloVec LDA,SVD 深度学习基础 正向传播 反向传播 常见激活函数 sigmoid tanh ReLU Leaky ReLU maxout 优化算法 SGD Momentum Adagrad RMSprop Adam 常见NLP模型算法与数据结构常见框架语言 c++ python 其他基础知识 数据库 设计模式 计算机网络 操作系统]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R-NET Machine Reading Comprehension With Self-Matching Networks]]></title>
    <url>%2F2018%2F07%2F11%2Fr-net%2F</url>
    <content type="text"><![CDATA[R-NET: MACHINE READING COMPREHENSION WITH SELF-MATCHING NETWORKS Introduction两个数据集 SQuAD SQuAD全称是Stanford Question Answering Dataset，是斯坦福大学提出的基于维基百科的阅读理解数据集，非常权威。 MS-MS-MARCO MS-MS-MARCO的全称是Microsoft MAchine Reading COmprehension dataset，主要来自于Bing搜索。主要区别在于问题的答案可能不仅仅来自给定的文本。 模型的主要构成 R-Net主要分为四个部分 使用循环神经网络进行语义编码层，分别对问题和答案进行语义编码 使用gated attention-based rnn来形成 question-aware的paragraph，将question的语义信息通过attention形式赋予到paragraph上，使得paragraph最后的语义编码是知道问题内容的；在该结构中，提出了门机制，挑选出对回答问题相关性强的语义信息部分 Self-match layer，提高paragraph内部每个部分对全局信息的理解 pointer-network，用于预测答案的位置 Detail结构图 细节1.QUESTION AND PASSAGE ENCODER令Question的embedding结果为Q=\{e_t^Q\}_{t=1}^m，Passage的embedding结果为P = \{e_t^P\}_{t=1}^n。考虑到未登录词(OOV)的问题，令Q和P的character-level的embedding结果分别为Q_c = \{c_t^Q\}_{t=1}^m 和 P_c = \{c_t^P\}_{t=1}^n。正常情况，Q和P的字符个数会远远大于词的个数，最后character-level的embeddings却和词的embedding长度保持一致，文中交代是将字符embedding的结果通过双向RNN，取最后的隐藏层输出作为character-level的embedding结果的。 最终encode的结果是： \begin{align*} u_t^Q = BiRNN_Q(u_{t-1}^Q, [e_t^Q, c_t^Q]) \\ u_t^P = BiRNN_P(u_{t-1}^P, [e_t^P, c_t^P]) \end{align*}2.GATED ATTENTION-BASED RECURRENT NETWORKS分为两个步骤，先将question的语义赋予到passage上，得到带有question语义的passage语义编码c_t，再将c_t与原来的passage语义编码结合得到question-aware的passage。 c_t = att(u^Q, [u_t^P, v_{t-1}^P]) 其中 v_t^P 是t时刻最后的passage的语义编码。因为每一时刻的 c_t 计算都需要依赖前一时刻时刻最终的 v_{t-1}^P s_j^t = V_Ttanh(W_u^Qu_j^Q + W_U^Pu_t^P + W_v^Pv_{t-1}^P) Q中第j个词对P中第t个词的影响是多少 a_i^t = exp(a_i^t) / sum_{j=1}^mexp(a_j^t) 过softmax，求权重，在attention计算中经常使用 c_t = \sum_{i=1}^m a_i^tu_i^Q 得到passage每个位置带有对question理解得语义编码 $v_t$的计算引入了门机制 g_t = sigmoid(W_g[u_t^p, c_t]) v_t^P = RNN(v_{t-1}^p, g_t\bigodot[u_t^p, c_t]) $v_t$即为第二层最终的结果。 3.SELF -MATCHING ATTENTION因为在考虑每个答案时，并没有注意到全文其他位置的信息，所以引入了self-match的机制。在self-match实现时，思路非常类似上面的gated attention-based rnn，只是将passage的attention对象从question换成了passage自己。 令$h_t^P$是加入了self-match信息的最终编码 u_t^P = BiRNN_P(u_{t-1}^P, [e_t^P, c_t^P])而 $c_t = att(v^P, v_t^P)$就是具体self-match的实现 \begin{align*} s_j^t &= V_Ttanh(W_v^Pv_j^P + W_v^Pv_t^P) \\ a_i^t &= exp(a_i^t) / sum_{j=1}^mexp(a_j^t) \\ c_t &= \sum_{i=1}^m a_i^tv_i^P \\ \end{align*}是不是整个过程非常类似，同时$u_t^P$的计算会继续使用2中提出的门机制。 4.OUTPUT LAYER该层通过pointer netword输出最终的answer的位置，本来很简单，但是貌似r-net中弄的比较复杂。 \begin{align*} s_j^t &= V_Ttanh(W_h^Ph_j^P + W_h^ah_{t-1}^a) \\ a_i^t &= exp(a_i^t)/ \sum_{j=1}^nexp(a_j^t) \\ p_t &= argmax(a_1^t, …, a_n^t) \\ \end{align*}其中$h_t^a$表示pointer network中rnn部分的hidden state c_t = \sum_{i=1}^n\alpha_i^th_j^P h_t^a = RNN(h_{t-1}^a, c_t) 从论文推测，此处的rnn的timestep是2，分别是answer的开始和结束的位置。 pointer network初始的hidden state r^Q = att(u^Q, V_r^Q) \begin{align*} s_j &= V_Ttanh(W_u^Qu_j^Q + W_r^Qv_r^Q) \\ a_i &= exp(a_i^t)/ \sum_{j=1}^mexp(a_j^t) \\ r^Q &= \sum_{i=1}^m\alpha_iu_i^Q \\ \end{align*} 将question进行加权作为pointer network的输入。 总结 character embedding，如果只用subword还是不能解决OOV的问题，character能够完全解决OOV，但是效果不一定会好；将character embedding作为一维特征是比较好的思路 attention的方式没什么创新，加入了门机制，本质上其实是增加了参数，使得网络更加复杂了。有没有文中所说的信息筛选的效果值得思考 self-match 三层均采用了相同的attention的计算方式]]></content>
      <categories>
        <category>paper_reading</category>
      </categories>
      <tags>
        <tag>机器阅读理解，SQuAD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Hybrid Framework for Text Modeling with Convolutional RNN]]></title>
    <url>%2F2018%2F06%2F27%2Fconv-rnn%2F</url>
    <content type="text"><![CDATA[A Hybrid Framework for Text Modeling with Convolutional RNN 总体本文主要提出了一种结合RNN和CNN的混合结构的模型，能够集合RNN和CNN各自的长处。在该混合结构基础上，文章又提出了sentence classification model(就是文本分类)和基于attention的answer selection model(基于文档的问答)。 本文的主要贡献: 提出了conv-RNN的混合结构 在此基础上进行扩展，提出了answer selection和sentence classification两个问题上更好的模型 在比较有名的数据集上进行了测试，取得了较好的效果。 模型conv-rnn的基础结构 word embedding层 将词变为词向量 双向RNN层 第二层是双向RNN层，$r_t$是$r_t^f$ 和 $r_t^b$ 进行concat；$h_s^b$ 和 $h_s^f$是两个方向的语义编码，在answer selection model中的attention机制会用到 CNN层 使用n个$2d 1$的卷积核，将上一层的输出提取为 $n s$ 的feature map pooling层 对每个卷积核卷积后的feature map进行max-pooling，得到最终的输出 $R^n$ 总结：其实就是很简单的rnn再过cnn的网络结构 Sentence Classification Model 结构非常简单，在conv-rnn基础上，将双向RNN的前向和后向隐藏层输出和最终输出concat到一起，后面再接上一层softmax的分类层即可。难以想象是一篇去年的KDD的文章 Answer Selection Model 几个创新点 输入加入了overlap的feature，问题中每个词和答案中的每个词相似度是多少，构成一维特征 没有使用传统的余弦相似度，使用的是Geometric mean of Euclidean and Sigmoid Dot (GESD) $X_sim = \frac{1}{1+||x-y||} \times \frac{1}{1+exp(-\gamma(xy^T + c))}$ 引入attention机制，将question双向RNN的hidden state计算attention向量$A_q$，让$A_q$参与到answer部分GPU的计算中。 总结上面的网络其实组合起来也不算复杂，但是却取得了很好的效果。其中answer selection model中创新点较多，有很多值得参考的地方，比如overlap的feature，GESD等等。]]></content>
      <categories>
        <category>paper_reading</category>
      </categories>
      <tags>
        <tag>短文本相似度，文本分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Attention Is All U Need]]></title>
    <url>%2F2018%2F06%2F12%2Fattention-is-all-U-need%2F</url>
    <content type="text"><![CDATA[IntroductionRNN, LSTM, GRU在语言模型和机器翻译等领域都达到了state-of-the-art的水平。RNN模型存在不能并行计算和长距离依赖的问题。现在，attention机制几乎成为了RNN模型的标配。 本文提出了Transformer的新结构，完全避开了循环的结构，仅仅依赖于attention机制来获取input和output之间的依赖。简而言之，Transformer是又快又好。 Background传统的减少串行计算的方法操作的数目和计算位置之间的距离有关，而Transformer是常数级别的计算量。 Self-attention 根据序列的不同位置计算对序列的表达，已经别广泛地运用到了很多NLP领域。 Model Architecture在传统的encoder-decoder中，encoder对input进行编码生成语义C，decoder将C解码为我们需要的目标Y。 Transformer的encoder和decoder都采用了stacked self-attention and point-wise, fully connected layers。 Encoder and Decoder Stacks Encoder encoder由6层(N=6)堆叠而成，每一层由两个sublayer构成。第一个sublayer是Multi-Head Attention，第二个sublayer是Feed Forward。两个sublayer都会引入residual和layer normalization。 简单来说，公式就是 LayerNorm(x + sublayer(x))。为了可以实现residual，我们设置所有的output的维度为512($d_{model} = 512$) Decoder decoder也是由6层(N=6)堆叠而成，每一层除了encoder部分的两个sublayer，还加入了一个Multi-Head Attention用来处理encoder部分的输出。第一个Multi-Head Attention进行了细微修改，加入了mask，用来保证每个位置预测结果时只会将该位置之前的结果纳入计算(已经预测过的位置)。 Attention Scaled Dot-Product Attention 如上面左图所示，直接上公式： Attention(Q, K, V) = softmax(\frac{QK^T}{\sqrt d_k})Vquery对每个key点乘，然后做一个缩放操作，然后做softmax乘以V。相当于计算每个K的相似度，根据相似度计算V的加权平均。 有两种用的比较多的attention计算方法，一种是additive attention(使用前向网络计算)，一种是dot-product。两种的理论实践复杂度很接近，但是dot-product时间和空间效率更高。 在$d_k$范围比较大的时候，additive attention的效果更好，因为dot-product在计算softmax时，如果值较大会导致softmax具有小的梯度，所以需要进行除以$\sqrt d_k$的缩放。 补充 softmax的梯度： \begin{align*} softmax(x_i) & = Z(x_i) = \frac{e^{x_i}}{\sum _je^{x_j}} \\ \frac{\partial Z(x_i)}{\partial x_i} &= \frac{e^{x_i} \sum _je^{x_j} - e^{x_i} e^{x_j} }{(\sum _je^{x_j})^2} = Z(x_i)(1 - Z(x_j) )\\ \frac{\partial Z(x_i)}{\partial x_j} &= \frac{- e^{x_i} e^{x_j} }{(\sum _je^{x_j})^2} = -Z(x_i) Z(x_j) \end{align*} Multi-Head Attention 作者发现并行使用不同的线性层处理K, Q, V, 并且再并行通过attention model效果会比较好。Multi-head attention allows the model to jointly attend to information from different representation subspaces at different positions 上公式： MultiHead(Q, K, V) = Concat(head1, head2, ..., headh)W_O \\ where\ headi = Attention(QW_i^Q, KW_i^K, VW_i^V)其中 W_O \in R^{hd_v\times d_v}, W_i^Q \in R^{d_m \times d_k},W_i^K \in R^{d_m \times d_k},W_i^V \in R^{d_m \times d_v},我们设置了h=8个并行的结构，同时使得 d_k = d_v = d_{model} / 8 = 64​。因为每个head的维度被降低了，所以总得计算量和之前是很相似的。 Applications of Attention in our Model Transformer有三种使用Multi-Head Attention的方式： queris来自于decoder的上一层decoder的输出，keys和value来自于encoder部分的输出 encoder部分是self-attention, 所有的query，key，value均来自于上一层的输出。每个位置都可以attend到所有的位置。 decoder部分和encoder部分一样，只不过为了保证自回归性，需要引入mask保证不计算非法的值。 Position-wise Feed-Forward Networks每个attention sublayer后面都会接一个全连接的前向网络，公式为： FFN(x) = max(0, xW_1+b_1)W_2 + b_2另一种解释是两层卷积核size为1的卷积。输入和输出均为d_{model}=512,d_{ff} = 2048。 Embeddings and Softmax输入和输出需要embedding layer，共享权重，同时将这些权重乘以 $\sqrt {d_{model}}$ Positional Encoding因为模型不适用循环神经网络或者卷积，所以需要某种机制来包含词之间的位置信息。 不太懂具体是怎么计算的，懂了再补充。 Why Self-Attention比较self-attention和rnn、cnn。]]></content>
      <categories>
        <category>paper_reading</category>
      </categories>
      <tags>
        <tag>机器翻译</tag>
        <tag>transformer</tag>
        <tag>self-attention</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈集成学习]]></title>
    <url>%2F2018%2F05%2F31%2Fensembel-learning%2F</url>
    <content type="text"><![CDATA[1. 集成学习集成学习(ensenble learning)是指通过构建并结合多个学习器来完成学习任务。一般来说，多个“弱学习器”结合起来的效果往往好于单个强学习器的效果，所以集成学习的应用非常广泛，比如著名的集成树模型系列。 集成学习按照个体学习器是否相同，可以分为同质集成和异质集成。同质集成的个体学习器是相同，比如都是决策树，个体学习器也往往被称为基学习器。异质集成中的个体学习器由不同的学习算法生成，比如不同的分类器(如决策树、lr和svm)投票出最终的结果。 集成学习另一种比较普通的分类方法是根据个体学习器之间的组合方式，一种是串行的方式，称为boosting方法，如Adaboost；一种是并行的方法，称为bagging方法，如随机森林。 1.1 从偏差和方差说起此处所提到的偏差和方差是有一定指代范围的，偏差指的是在训练集上的效果好坏，比如计算的正例的概率都集中在1附近，模型刻画能力较好，那么偏差就较小；方差指的是在不同测试集上的预测效果的浮动程度，比如在不同测试集上正例预测的概率范围都很接近，那么方差就较小。用打靶子来比喻的话，低偏差就是训练的时候每一枪都打到了靶中心周围，而低方差就是不管是训练还是比赛的时候，每次打的位置都比较接近。 偏差相当于刻画了模型在训练集上的效果，方差刻画了模型在不同测试集上的泛化能力，一个欠拟合的模型很明显是偏差大的，一个过拟合的模型很明显是方差大的。 1.2 boostingboosting方法是集成学习中的第一大类别，这类算法的一般工作机制为：先在训练集上训练出一个个体学习器，然后根据个体学习器的在训练集上的效果，重新分配训练样本的权重，比如对错误分类样本增大权重，在此基础上训练新的个体学习器。直到个体学习器的个数达到了目标的个数，停止训练，将n个个体学习器线性加和作为最终的结果。boosting是一种串行的集成学习算法，主要的目的是降低偏差。 前向分步算法我们考虑一个加法模型，在我们训练了很多基学习器以后，使用线性相加的形式作为最后的模型。 f(x) = \sum_{m=1}^M\beta_mb(x;\gamma_m)$f(x)$是最终的模型，$\beta_m$是每个基学习器的权重，$b(x;\gamma_m)$是基学习器，$\gamma_m$是基学习器的参数。 在给定损失函数$L(yi, \sum{m=1}^Mb(x_i;\gamma_m))$的条件下，即转换为极小化损失函数的问题： \mathop{min}\limits_{\gamma_m, \beta_m} L(y, \sum_{m=1}^M\beta_mb(x;\gamma_m))这种情况非常难以求解，于是，可以转换为从前到后每次求解一个基学习器的权值和参数。 具体算法 输入：训练数据集 $((x_1, y_1),…,(x_n, y_n))$，损失函数 $L(y, f(x))$，基学习器 $b(x, \gamma)$ 输出：学习器 $f(x)$ 初始化 $f_0(x) = 0$ 对0,…,M 更新 f_m(x) = f_{m-1} + \beta_mb(x;\gamma_m) 极小化损失函数 (\gamma_m, \beta_m) = \mathop{argmin}\limits_{\gamma_m, \beta_m} L(y, f_{m-1}(x) + \beta_mb(x;\gamma_m)) 得到加法模型 Adaboost我对于Adaboost算法的理解，就是从前向分步算法推导出来的，所以此处给出前向分步算法推导出Adaboost算法。 算法最终的分类器为 f(x) = \sum_{m=1}^M \alpha_mG_m(x)损失函数是指数损失 L(y, f(x)) = exp(-yf(x))根据前向分布算法 \begin{align*} (G(x), \alpha_m) &= \mathop{argmin}\limits_{G(x), \alpha_m} \sum_iL(y_i, f_{m-1}(x_i) + \alpha_mG(x_i)) \\ &= \mathop{argmin}\limits_{G(x), \alpha_m} \sum_iexp(-y_if_{m-1}(x_i)-y_i\alpha_mG(x_i)) \\ &= \mathop{argmin}\limits_{G(x), \alpha_m} \sum_iw_{mi}exp(-y_i\alpha_mG(x_i)) \end{align*}其中 w_{mi} = exp(-y_if_{m-1}(_i))，可以认为是每个样本的权重。 下面求解$\alpha_m$ \begin{align*} \sum_{i=1}^N w_{mi}exp(-y_i\alpha G(x_i)) &= \sum_{y_i=G(x_i)}e^{-\alpha} + \sum_{y_i!=G(x_i)}e^{\alpha} \\ &= (e^\alpha - e^{-\alpha})\sum_{i=1}^Nw_{mi}I(y_i\neq G(x_i)) +e^{-\alpha}\sum_{i=1}^Nw_{mi} \end{align*}求导，令导数为0得到 \alpha_m = \frac{1}{2}log\frac{1-e_m}{e_m}其中 e_m = \frac{\sum_{i=1}^Nw_{mi}I(y_i\neq G(x_i)) }{\sum_{i=1}^Nw_{mi}}所以，我们可以算得下一个基分类器训练时每个样本的权重，以及该基分类器在最终的模型中所占的权重，这样就得到了完整的Adaboost的算法形式。 下面具体详细地阐述Adaboost算法 模型为加法模型、损失函数为指数损失函数、学习算法为前向分布算法的学习方法 最终的分类器 $f(x) = \sum_{m=1}^M\alpha_mG_m(x)$ 涉及到两个主要问题 $\alpha_m$：每个基分类器的权值是多少 $w_{mi}$：每个基分类器训练时，各个训练样本的权值是多少 一旦有了这两个参数，可以计算loss，进行训练，同时计算下一个训练样本的权值分布 过程 第m个分类器的分类误差率 e_m = \sum_{i=1}^Nw_{mi}I(y_i\neq G_m(x_i)) 第m个分类器的loss \sum_{i=1}^Nw_{mi}exp[-y_i\alpha_m G(x_i)] 对loss求导可以得到 \alpha_m = \frac{1}{2}log\frac{1-e_m}{e_m} 当 e_m \leq \frac{1}{2} 时，em越小 \alpha_m 的权值越大 训练样本权值更新 w_{m+1, i} = \frac{w_{mi}}{Z_m}exp(-\alpha_my_iG_m(x_i)) 如果分类正确，则减小样本的权值 如果分类错误，则增大样本的权值 继续如上过程训练 1.3 baggingbagging是集成学习中的第二大类方法，是并行式集成学习的代表。bagging方法的基础是自助采样法(bootstrap sampling)，我们从样本中抽取一个样本，再把该样本放回原训练集中，再进行第二次采样。根据此方法可以采样得到一个容量为m的子训练样本，原训练样本中有些在子训练样本中从未出现过，有些会重复出现。我们采样出T个这样的容量为m的子训练样本，通过T次的子训练样本可以训练得到T个基分类器。最后T个基分类器结合得到最终的结果(比如投票法)。当我们想得到泛化能力强的集成模型，我们希望每个基分类器尽量独立，也就是具有差异性。通过bagging方法得到的T的基分类器因为训练样本的差异性，模型本身也具有差异性，所以集成以后效果会比较好。 random forest随机森林是bagging的一个变体，随机森林在以决策树为基础构建bagging集成学习的基础上，在决策树的训练过程中引入了随机属性选择。 具体地，随机森林的基分类器是决策树，每个基分类器的训练样本来自于bagging方法的采样。同时，在每个基分类器的训练过程中，还会随机选择k个属性作为当前基分类器的划分属性集合。这样，对于每个基分类器来说，不仅训练样本不同，用于划分的属性集合也不同，增加了每个基分类器之间的差异性，同时，因为每次不需要考虑所有的属性，计算量减少了，提高了训练效率。 1.4 两种集成方法对比boosting方法和bagging方法的区别主要体现在两个方面： 一个是体现在每个基分类器的组合形式上，前者是串行，后者是并行。串行的方式，必须得等待前面的基分类器训练完，基于该分类器的结果才可以训练下一个基分类器，和循环神经网络类似，不能进行并行计算提高效率；并行的bagging方法因为每个基分类器之间的训练之间没有相互依赖关系，所以可以进行并行计算提高效率。 另一个方面是两种方法主要的效果上，前者是主要降低偏差，后者主要降低方差。boosting方法希望在训练集上的误差越小越好，每次的基分类器都是以降低偏差为目标；bagging方法训练样本是有差异的或者因为特征子集也不尽相同，所以每个基分类器是有差异的，这些有差异的基分类器相当于模拟了在不同测试集上的表现，基分类器之间会相互弥补，达到降低方差的效果。 2. 典型的集成树模型2.1 gradient boost对于前向分步算法，一个比较关键的问题是，在优化求解m个基学习器时，优化目标是什么。当计算使用指数损失函数作为loss的分类问题时，每个基学习器的优化目标很容易地进行求解，此时就是Adaboost算法；当计算使用平方误差损失作为loss的回归问题时，每个基学习器的优化目标同样很容易求解，就是boosting tree的形式，此时可以直接化解为残差的形式，即每个基学习器优化的是上一个基学习器和目标的残差。 此处可以证明一下平方损失函数作为loss时残差优化目标的推导： L(y, f_{m-1}(x) + \beta_mb(x;\gamma_m)) = (y - f_{m-1}(x) - \beta_mb(x;\gamma_m))^2 = (r - \beta_mb(x;\gamma_m))^2其中 $r = y - f_{m-1}(x)$即为残差形式。 接下来，对于除了以上的两种情况以外的一般损失函数来说，每一步的优化目标并不容易确定，所以，提出了每次的优化目标是损失函数的负梯度在当前模型的值。即优化 -[\frac{\partial L(y, f(x_i))}{\partial f(x_i)}]_{f(x) = f_{m-1}(x)}2.2 GBDTGBDT全称是gradient boosting decision tree。使用的是gradient boosting方法，基学习器是CART树。 对于GBDT回归算法，和上面gradient boosting方法完全类似，基学习器时CART树，使用的loss是平方损失，所以每一个基学习器的优化目标是上一个CART树与优化目标的残差。 比如，我们要用GBDT预测人的年龄，目标是30岁。那么，第一个树的目标是30岁，如果预测的值是20岁，那么第二个树的目标则为30-20=10岁，依次类推下去。 2.3 xgboost计划看一下陈天奇的论文再做进一步总结。 xgboost和GBDT的主要不同体现在优化的目标上，GBDT优化的是梯度，相当于是一阶导数，而xgboost对loss进行了二阶泰勒展开，同时加上了正则化项作为优化目标，正则化项包括叶子节点个数以及叶子节点输出值的L2值。 3. 典型集成模型对比rf、GBDT、xgboost、lightGBM 1. random forest 优点 训练速度、准确率都较好 能够处理高维数据，不用进行特征筛选，训练后能看到特征的重要性 可以进行并行训练 缺点 在噪声大的训练数据上容易过拟合 2. GBDT 优点 灵活处理各种数据 较少调参时间内准确度较高 缺点 boosting方法，串行，难以并行训练 3. xgboost和GBDT GBDT是基学习器是回归树，而xgboost支持线性分类器 GBDT的优化目标只利用了一阶导数，而xgboost利用了一阶导数和二阶导数 shrinkage。在每个基分类器计算完后，会将叶子节点权值乘以一个参数，为了削弱每颗树的影响，为了让后面有更大的学习空间 xgboost加入了正则化项，防止了过拟合 列抽样，和随机森林一样支持列抽样，防止过拟合，减少计算 缺失值的处理 xgboost进行了并行计算，在特征选择的过程中用了排序方法 4. 为什么rf需要设置树的深度较深，而xgboost并不需要 rf是bagging方法，主要是降低方差，所以希望单个模型偏差较低，所以倾向于偏差低的单个模型 xgboost是boosting方法，主要是为了降低偏差，所以希望单个模型方差较低，方差较低就希望单个模型不要太复杂，所以倾向于树的深度浅一些。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈逻辑回归]]></title>
    <url>%2F2018%2F05%2F15%2Flogistic-regression%2F</url>
    <content type="text"><![CDATA[从线性回归说起 线性回归 $y = w^Tx + b$ x表示n维的特征向量，通过线性相加得到y值，可以使用使用最小二乘求解。 逻辑回归与线性回归的联系与区别 对数几率角度理解 逻辑回归是，通过线性回归的方法去预测对数几率，即：$ln\frac{y}{1-y} = w^Tx+b$ 求解得到 $y = \frac{1}{e^{-(w^Tx+b)}+1}$ 线性回归形式预测的是几率大小，逻辑回归将可能性大小映射到0-1之间 将 $y = w^Tx + b$ 认为y是预测的对数几率的大小，经过一个sigmoid将对数几率变为0-1之间。 也就是说sigmoid将对数几率变为了y的概率 逻辑回归与线性可分 逻辑回归从线性回归来，这个线性回归预测的结果是对数几率，大于0是为正例，小于0时为负例，本质上没有改变线性分类超平面（$y = w^Tx + b$ 构成的超平面）。 通过构造特征，映射到高维，映射到高维的线性可分。 逻辑回归的公式推导 loss 使用的是神奇的负的对数似然作为loss $J = -\frac{1}{m}\sum_i (y_iln(h(w^Tx^i) + (1-y_i)ln(1-h(w^Tx^i)))$ 对应的是二分类形式的交叉熵 梯度下降公式推导 补充 $\sigma’(x) = \sigma(x)(1-\sigma(x))$ $(1-\sigma(x))’ = -\sigma’(x)(1-\sigma(x))$ 令$\theta_i = y_iln(h(w^Tx^i) + (1-y_i)ln(1-h(w^Tx^i) $ \begin{align*} \frac{\partial J}{\partial w_j} &= -\frac{1}{m}\sum_i\frac{\partial \theta_i}{\partial w_j} \\ \frac{\partial \theta_i}{\partial w_j} &= y_i\frac{1}{h(w^Tx^i)}h’ (w^Tx^i)x_j^i + (1-y_i)\frac{1}{1-h(w^Tx^i)}(-h'(w^Tx^i))x_j^i \\ &= y_i\frac{1}{h(w^Tx^i)}h (w^Tx^i)(1-h(w^Tx^i))x_j^i + (1-y_i)\frac{1}{1-h(w^Tx^i)}(h(w^Tx^i)(h (w^Tx^i)-1))x_j^i \\ &=(y_i-h(w^Tx^i))x_j^i \\ \frac{\partial J}{\partial w_j} &= -\frac{1}{m}\sum_i\frac{\partial \theta_i}{\partial w_j} = -\frac{1}{m}\sum_i(y_i-h(w^Tx^i))x_j^i \\ \end{align*} 在此基础上，根据梯度下降公式 w_j = w_j - \alpha \frac{\partial J}{\partial w_j} 逻辑回归的正则化 l1和l2 L1：$||w||_1 = (\sum_i |w_i|)$ L2: $||w||_2 = \sqrt(\sum_iw_i^2)$ l1和l2的区别以及为什么 l1会使得参数变得稀疏，l2会使得参数变得更接近0 最终的loss为：$J = loss + ||w||_p$ 图形解释 一圈一圈的是loss的等高线(loss值)，方形和圆形分别是l1和l2的等高线，基于梯度下降思想，需要更加接近圆心，才会loss更小。 对于l1来说，弧形会最先与轴上的点相交，对于l2来说，因为是圆弧，所以会先与圆相切 那么结论就出来了，与轴上点相交时，w1的值就为零了，而与圆弧相交则使得w1和w2变得较小。 可能loss的等高线并不是弧形，这点其实需要思考，该部分不够严谨，对于l1的图来说，其实是存在与弧线相切的线的，比如在靠近圆心的位置，此时，w1和w2并不为零，所以可能理解有偏差，仅供参考 从参数更新公式理解 参数更新公式为 $w = w - \alpha \frac{\partial J}{\partial w}$ $\alpha$是学习率，偏导项是梯度，可以分为两个部分，一个部分是原本的loss，一个部分是正则化项的梯度。对于l1和l2正则来说，前半部分都是相同的，只有后半部分不一样 对于l1正则化来说， ​ ​ \begin{align*} \frac{\partial ||w||_1}{\partial w} &= 1 \ \ if \ w > 0 \\ \frac{\partial ||w||_1}{\partial w} &= -1 \ \ if \ w < 0 \end{align*} 根据参数更新公式$w = w - \alpha \frac{\partial J}{\partial w}$，当w大于0时，正则化项的梯度为1，会使w往0的方向靠近，当w小于0时，正则化项的梯度为-1，同样会使得w往0的方向靠近，直至为0 对于l2正则化来说 \frac{\partial ||w||_2}{\partial w} = 2w 同样根据参数更新公式$w = w - \alpha \frac{\partial J}{\partial w}$，$w = (1 - 2\alpha)w $ ，在原有w基础上乘以一个系数，会使得w接近于0，而不是变为0 逻辑回归与极大似然估计本质上来说，逻辑回归就是极大似然估计。因为逻辑回归的损失函数是负的对数似然函数，本质上的优化，也是使得对数似然函数尽可能大，也就是极大似然法的思想。 逻辑回归与最大熵模型逻辑回归可以认为是特殊形式的最大熵模型。 逻辑回归 \begin{align*} P(y=1|x) &= \frac{1}{e^{-w^Tx+b}+1} \\ P(y=0|x) &= \frac{e^{-w^Tx+b}}{e^{-w^Tx+b}+1} \end{align*}最大熵模型 \begin{align*} P(y|x) &= \frac{1}{Z(x)} \times e^{\sum_iw_if_i(x,y)} \\ Z(x) &= \sum_y e^{\sum_iw_if_i(x,y)} \end{align*}如果令 \begin{equation} f_i(x, y)=\left\{ \begin{aligned} & -x_i & y = 1 \\ & 0 & y = 0 \end{aligned} \right. \end{equation}则可以由最大熵模型推导得到 \begin{align*} P(y=0|x) &= \frac{1}{Z(x)} \times e^{\sum_iw_if_i(x,0)} = \frac{1}{e^{\sum_iw_if_i(x,0)}+ e^{\sum_iw_if_i(x,1)}} = \frac{1}{1+e^{-w^Tx}}\\ P(y=1|x) &= \frac{1}{Z(x)} \times e^{\sum_iw_if_i(x,y)} = \frac{e^{\sum_iw_if_i(x,1)}}{e^{\sum_iw_if_i(x,1)}+ e^{\sum_iw_if_i(x,1)}} = \frac{e^{-w^Tx}}{1+e^{-w^Tx}}\\ \end{align*}根据上面的推导，我们可以得到逻辑回归的形式，也就是特殊形式的最大熵模型(特征函数以及y是特征的) 特征交叉和特征离散化逻辑回归只能解决线性可分问题，所以对于一个现实问题，要想取得比较好的效果，一般会进行特征交叉以及特征离散化。特征离散化是将连续特征(离散特征也可以)的每个特征值都变为一维，类似变成了ont-hot向量。 特征交叉是指某些特征之间是具有联系的，有时候可以将特征与特征联合进行考虑，即交叉得到新的特征。具体见fm和ffm算法。 具体特征交叉和离散化在CTR中的应用 逻辑回归的优缺点没有找到详细的解释，有大概几点，有详细解释再补充吧。 优点 计算快 结果是概率形式，可以知道可能性大小 可以并行化计算，工业上用的比较多 缺点 容易欠拟合，分类或者回归的精度不高 特征空间大效果不好]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2018%2F05%2F08%2Fleetcode%2F</url>
    <content type="text"><![CDATA[LinkedList链表翻转、两个链表代表的数求和（两种形式）、找到链表的倒数第k个节点（删除链表的倒数第k个节点） 445. Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: 12Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 题目大意 给定两个非空的链表，链表的每个节点代表非负整数的一位，链表的靠前的位置代表着高位。返回两个链表所代表的数相加的结果，结果以链表形式返回。 如果不能改变输入的链表即不能翻转链表该如何操作。 思路 翻转链表，按顺序加起来，然后构造链表即可；(但是题目要求不允许改变链表)； 空间换时间，遍历两个链表用数组存起来，使用数组相加，同时生成结果链表，生成结果链表的时候可以逆序直接生成结果链表； 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; vector&lt;int&gt; vec1, vec2, vec3; ListNode *res = NULL, *p = NULL; while (l1 != NULL)&#123; vec1.push_back(l1-&gt;val); l1 = l1-&gt;next; &#125; while (l2 != NULL)&#123; vec2.push_back(l2-&gt;val); l2 = l2-&gt;next; &#125; int len1 = vec1.size(), len2 = vec2.size(), c = 0; for (int i=len1-1, j=len2-1; i&gt;=0 || j&gt;=0 || c &gt; 0; --i, --j)&#123; int sum = c; if (i &gt;= 0) sum += vec1[i]; if (j &gt;= 0) sum += vec2[j]; c = sum / 10; p = new ListNode(sum % 10); p-&gt;next = res; res = p; &#125; return res; &#125;&#125;; 翻转链表，熟悉下链表翻转 123456789101112131415161718192021222324252627282930313233343536373839// reverse the linked listclass Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *l1_r = reverse(l1); ListNode *l2_r = reverse(l2); int c = 0; ListNode *res = NULL, *p = NULL; while ((l1_r!=NULL) || (l2_r!=NULL) || c&gt;0)&#123; int sum = c; if (l1_r != NULL) &#123; sum += l1_r-&gt;val; l1_r = l1_r-&gt;next; &#125; if (l2_r != NULL) &#123; sum += l2_r-&gt;val; l2_r = l2_r-&gt;next; &#125; c = sum / 10; p = new ListNode(sum % 10); p-&gt;next = res; res = p; &#125; return res; &#125; ListNode* reverse(ListNode* node)&#123; if (node == NULL || node-&gt;next == NULL) return node; ListNode *p = NULL, *q = node; while (q != NULL)&#123; ListNode *tmp = q-&gt;next; q-&gt;next = p; p = q; q = tmp; &#125; return p; &#125; &#125;; 2.Add Two Numbers题目大意 用一个链表给出一个非负数，链表的头是数的低位，尾部是高位，求两个链表所代表数的和的链表形式。 思路 比445简单多了，直接遍历链表相加，返回即可。 考虑 如果是有符号数，得考虑大小再做减法 代码 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *head, *p, *q; head = new ListNode(0); p = head; int sum = 0, carry = 0; while (l1 || l2 || carry)&#123; sum =carry; if (l1)&#123; sum += l1-&gt;val; l1 = l1-&gt;next; &#125; if (l2)&#123; sum += l2-&gt;val; l2 = l2-&gt;next; &#125; carry = sum / 10; sum = sum % 10; p-&gt;next = new ListNode(sum); p = p-&gt;next; &#125; /* if (!head-&gt;next || !head-&gt;next-&gt;next) return head-&gt;next; p = NULL; q = head-&gt;next; delete head; while (q)&#123; ListNode* tmp = q-&gt;next; q-&gt;next = p; p = q; q = tmp; &#125; return p; */ return head-&gt;next; &#125;&#125;; 19.Remove Nth Node From End of List题目大意 删除链表的倒数第n个节点 思路 使用双指针法，第一个指针访问第n个节点，然后同时移动两个指针，当第一个指针到达尾部时，第二个指针指向的就是倒数第n个节点。 需要考虑边界条件 head节点为空 n大于链表节点数目 当链表只有一个节点且需要删除当前节点的情况(有指向head的头结点时会更好处理) 使用一个指向head的头节点会比较好处理一些。 代码 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 考虑head为空 if (!head) return head; ListNode *bak, *low = head, *fast = head; for (int i=0; i&lt;n; ++i)&#123; if (!fast) return head; fast = fast-&gt;next; &#125; if (fast == NULL)&#123; bak = head-&gt;next; delete head; return bak; &#125; while(fast-&gt;next)&#123; fast = fast-&gt;next; low = low-&gt;next; &#125; fast = low-&gt;next; low-&gt;next = low-&gt;next-&gt;next; delete fast; return head; &#125;&#125;; 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 考虑head为空 if (!head) return head; ListNode *pre; pre = new ListNode(0); pre-&gt;next = head; ListNode *low = pre, *fast = pre; for (int i=0; i!=n; ++i)&#123; // 考虑n超过范围 if (!fast) return head; fast = fast-&gt;next; &#125; // fast肯定不会为空，只是保险 while (fast &amp;&amp; fast-&gt;next)&#123; low = low-&gt;next; fast = fast-&gt;next; &#125; fast = low-&gt;next; low-&gt;next = low-&gt;next-&gt;next; // 记得释放删除节点的内存 delete fast; low = pre-&gt;next; delete pre; return low; &#125;&#125;; 92.Reverse Linked List II题目大意 给定一个单链表，翻转m到n的位置，链表从1开始标号。要求in-place and one-pass。 思路 使用额外空间： fast指针先指到m位置，遍历到n，将值push到栈中； low从m位置开始，依次将栈中值pop出来存储到对应的节点位置 直接操作 pre指向(m-1)位置，pStart指向m位置，那么依次开始逆序 tmp = pStart-&gt;next; pStart-&gt;next = tmp-&gt;next; tmp-&gt;next = pre-&gt;next; pre-&gt;next = tmp; 代码 12345678910111213141516171819202122class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (head == NULL) return head; ListNode preHead(0); ListNode *pre = &amp;preHead; pre-&gt;next = head; ListNode *p=pre, *pstart=NULL, *t=NULL; for (int i=0; i&lt;m-1; ++i) p = p-&gt;next; pstart = p-&gt;next; for (int i=0; i&lt;n-m; ++i)&#123; t = pstart-&gt;next; pstart-&gt;next = t-&gt;next; t-&gt;next = p-&gt;next; p-&gt;next = t; &#125; return pre-&gt;next; &#125;&#125;; 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (!head || !head-&gt;next) return head; n -= m; ListNode *root=NULL, *pre=NULL, *pStart=NULL; ListNode preNode(0); root = &amp;preNode; root-&gt;next = head; pre = root; while (--m)&#123; pre = pre-&gt;next; &#125; pStart = pre-&gt;next; while (n--)&#123; ListNode *t = pStart-&gt;next; pStart-&gt;next = t-&gt;next; t-&gt;next = pre-&gt;next; pre-&gt;next = t; &#125; return root-&gt;next; &#125;&#125;; 21.Merge Two Sorted Lists题目大意 将两条排序好的链表合并，要求返回的新链表的节点是由旧链表而来。 思路 归并排序的思路 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *pre = NULL; ListNode prenode(0); pre = &amp;prenode; ListNode *cur = pre; while (l1 &amp;&amp; l2)&#123; if (l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if (l1)&#123; cur-&gt;next = l1; &#125; if (l2)&#123; cur-&gt;next = l2; &#125; return pre-&gt;next; &#125;&#125;; 23.Merge k Sorted Lists题目大意 合并k条排好序的链表 思路 普通思路 转换为k次两个链表的合并 时间复杂度为$O(k^2n)$ 复杂度为$O(log(k)n)$ 比较k个链表的当前最小值时，使用堆排序维护顺序，这样的话就不需要重复进行排序了 代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode *tmp=NULL; for (int i=0; i!=lists.size(); ++i)&#123; tmp = mergeTwoLists(tmp, lists[i]); &#125; return tmp; &#125;private: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)&#123; if (!l1 &amp;&amp; !l2) return l1; ListNode* pre=NULL; ListNode preHead(0); pre = &amp;preHead; ListNode* head = pre; while (l1 &amp;&amp; l2)&#123; if (l1-&gt;val &gt; l2-&gt;val)&#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125;else &#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; head = head-&gt;next; &#125; if (l1) head-&gt;next = l1; if (l2) head-&gt;next = l2; return pre-&gt;next; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233// priority_queue的比较struct cmp&#123; bool operator()(ListNode* a, ListNode* b)&#123; // 小顶堆 return (a-&gt;val &gt; b-&gt;val); &#125;&#125;;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode *pre=NULL, *cur=NULL, *tmp=NULL; ListNode preHead(0); pre = &amp;preHead; cur = pre; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; q; for (int i=0; i!=lists.size(); ++i)&#123; if (lists[i])&#123; q.push(lists[i]); &#125; &#125; while (!q.empty())&#123; tmp = q.top(); q.pop(); cur-&gt;next = tmp; cur = cur-&gt;next; if (tmp-&gt;next) q.push(tmp-&gt;next); &#125; return pre-&gt;next; &#125;&#125;; 138.Copy List with Random Pointer 题目大意 给定一条带有随机指针的链表，随机指针随机指向链表中的某个节点，要求返回该链表的深拷贝。 思路 1 先对仅仅对链表的普通关系进行复制，同时用一个map存储原来链表节点和复制链表节点的对应关系 再遍历一遍普通链表，对非空的random指针在复制链表中复制，指向的节点有map确定 2 对原有链表复制一个节点插入到当前节点后面 复制random pointer 拆分 代码 1234567891011121314151617181920212223242526class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode* pre=NULL; RandomListNode preHead(0); pre = &amp;preHead; RandomListNode *cur1=head, *cur2 = pre; map&lt;RandomListNode*, RandomListNode*&gt; cache; while (cur1)&#123; cur2-&gt;next = new RandomListNode(cur1-&gt;label); cache[cur1] = cur2-&gt;next; cur1 = cur1-&gt;next; cur2 = cur2-&gt;next; &#125; cur1 = head; cur2 = pre-&gt;next; while (cur1)&#123; if (cur1-&gt;random)&#123; cur2-&gt;random = cache[cur1-&gt;random]; &#125; cur1 = cur1-&gt;next; cur2 = cur2-&gt;next; &#125; return pre-&gt;next; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738// method 2class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; if (!head) return head; RandomListNode *cur = head, *tmp=NULL, *cur1=NULL, *res=NULL; // step 1 while (cur)&#123; tmp = cur-&gt;next; cur-&gt;next = new RandomListNode(cur-&gt;label); cur = cur-&gt;next; cur-&gt;next = tmp; cur = cur-&gt;next; &#125; // step 2 cur = head; while (cur)&#123; if (cur-&gt;random)&#123; cur-&gt;next-&gt;random = cur-&gt;random-&gt;next; &#125; cur = cur-&gt;next-&gt;next; &#125; // step 3 res = head-&gt;next; cur1 = head-&gt;next; cur = head; while (cur)&#123; tmp = cur1-&gt;next; if (tmp)&#123; cur1-&gt;next = tmp-&gt;next; cur1 = cur1-&gt;next; &#125; cur-&gt;next = tmp; cur = cur-&gt;next; &#125; return res; &#125;&#125;; 160.Intersection of Two Linked Lists 题目大意 给定两个有公共部分的单链表，找出单链表的交叉点 思路 将两个单链表当做循环链表 如果两个链表长度相同，那么两个指针相遇的位置即为交叉点 如果长度不同，一个大圈一个小圈，循环遍历，一定有某个时刻会相遇到交叉点 123456789101112131415161718class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *l1=headA, *l2=headB; if (l1==NULL || l2==NULL) return NULL; while (l1!=l2)&#123; l1 = l1-&gt;next; l2 = l2-&gt;next; if (l1 == l2) return l1;// 如果相遇到为空的点，那么两个链表不存在公共节点 // 空节点说明到达了尾部，要跳过空节点，进入到头节点 // 注意，不能将该步骤移到while的开始部分，while需要两次判断low和high是否相等 // 第一次是判断是不是公共节点，第二次是判断是不是有公共节点 if (l1 == NULL) l1 = headA; if (l2 == NULL) l2 = headB; &#125; return l1; &#125;&#125;; 141.Linked List Cycle142.Linked List Cycle II题目大意 判断一个链表是否有环 如果一个链表有环，找到环的入口 思路 有环 使用快慢指针 如果相遇则有环，否则fast到达尾部(NULL) 入口 相遇位置为(km) 开始节点到入口(n-m) 相遇位置到入口需要走的路径长度为(m - (km-(n-m))) = n - km 所以必然会相遇在入口节点 123456789101112131415161718// 141class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (head==NULL) return false; ListNode *fast=head, *slow=head; while (fast!=NULL)&#123; if (fast-&gt;next!=NULL) fast = fast-&gt;next-&gt;next; else return false; slow = slow-&gt;next; if (slow == fast) return true; &#125; return false; &#125;&#125;; 12345678910111213141516171819202122232425// 142class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head==NULL) return head; ListNode *slow=head, *fast=head; while (fast!=NULL)&#123; if (fast-&gt;next!=NULL) fast = fast-&gt;next-&gt;next; else return NULL; slow = slow-&gt;next; if (slow == fast) break; &#125; if (fast == NULL) return fast; fast = head; while (fast!=slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; 287. Find the Duplicate Number题目大意 给定一个包含n+1个整数（[1,n]）的数组，假设只有一个重复数字，要求找到这个重复的数字。 思路 本身这个题目不算难，用hash或者排序都可以做，但是要求不能改变原数组、空间复杂度为O(1)、时间复杂度低于o(n^2)，这样就不好做了。 142. Linked List Cycle II类似于这道题的解法。 双指针方法 设置low指针和fast指针，low每次走一步，fast每次走两步； 存在环必然会相遇，设相遇时low走了k步，环的长度为r，则2k-k = nr； 环入口到相遇位置距离为m，数组开始位置到环入口位置的距离为s，则k - s =m, nr - s = m, s = (n-1)r + (r-m) 由上式可知，相遇后，如果fast再从0位置开始，low在相遇位置开始，low和fast都以一步为步长前进，则会相遇到环入口，而环入口上一个位置则为重复的数。 指针从不同位置开始，结果会略微不同，需要注意。 1234567891011121314151617181920212223242526class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; /* 整数是1到n，而重复的指针下一步会指到相同的位置， *所以必然会形成一个循环，因此可以通过步长不同的指针去找到这个循环 *如果是这样开始的话，2k-k-1=nr, k-s=m, nr-1-s=m, -&gt; s = (n-1)r+(r-m)+1 * 所以fast需要从0开始，而不能从nums[0]开始 */ while (low != fast)&#123; low = nums[low]; fast = nums[nums[fast]]; cout &lt;&lt; low &lt;&lt; " " &lt;&lt; fast &lt;&lt; endl; &#125; /*可以证明，low在第一次meet的位置，fast从第一个位置开始 *同时以一步移动，最后会相遇在相同的那个数 */ fast = 0; while (low != fast)&#123; low = nums[low]; fast = nums[fast]; cout &lt;&lt; low &lt;&lt; " " &lt;&lt; fast &lt;&lt; endl; &#125; return fast; &#125;&#125;; BinaryTree572.Subtree of Another Tree题目大意 给定两棵二叉树s和t，判断t是否是a的子树。 思路 二叉树问题基本都可以用递归解决 isSubtree：看看s和t是否是相同的，是就return true，否则，判断s-&gt;left和t或者s-&gt;right和t是否是相同的； isSame：如果s-&gt;val == t-&gt;val 则递归判断left和right，否则直接返回false； 代码 123456789101112131415161718192021class Solution &#123;public: bool isSubtree(TreeNode* s, TreeNode* t) &#123; if (!s &amp;&amp; !t) return true; if ((s &amp;&amp; !t) || (!s &amp;&amp; t)) return false; if (isSame(s, t)) return true; else&#123; return isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t); &#125; &#125;private: bool isSame(TreeNode* s, TreeNode* t)&#123; if (!s &amp;&amp; !t) return true; if ((s &amp;&amp; !t) || (!s &amp;&amp; t)) return false; if (s-&gt;val == t-&gt;val) return isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right); else return false; &#125;&#125;; 144.Binary Tree Preorder Traversal145.Binary Tree Postorder Traversal题目大意 前序和后序遍历二叉树 思路 基础的二叉树前序、中序和后序遍历没什么好说的，但是这两个题目提供了新的思路，值得思考 前序遍历 不再沿着左子树一直搜索下去，每次将右节点和左节点入栈，下一次循环时，左节点出栈继续该过程，因此也达到了先序遍历的目的 中序不适合此种方式，因为栈中没有存储所有的左子节点，所以没办法等到最后一个最深处的左子节点被访问以后再访问父节点，所以无法完成中序遍历 后序遍历 以往的思路是，对当前节点做一个标记，如果是第二次访问，则该访问该节点，否则 不访问该节点，继续入栈，但是如果节点本身无法做标记就没办法做了； 思路是 先序遍历是 root-left-right，如果root-right-left这样遍历的话，结果反过来就是left-right-root，就是后序遍历的结果(可以递归去思考为什么reverse就是后序的结果) root-right-left有两种思路 原来的先序遍历，先入栈右节点 1中提到的先序遍历，同样先入栈左节点 补充一种做法：使用pre节点记录回溯时上一次访问的节点（两种情况，一种是遇到叶子节点会回溯，一种是第二次访问某个节点需要继续向上回溯），如果是当前节点的右节点，说明该节点是第二次访问，访问该节点，出栈即可。 代码 preorder 123456789101112131415161718// new way to preoder binary treeclass Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; ss; ss.push(root); while (!ss.empty())&#123; root = ss.top(); res.push_back(root-&gt;val); ss.pop(); if (root-&gt;right) ss.push(root-&gt;right); if (root-&gt;left) ss.push(root-&gt;left); &#125; return res; &#125;&#125;; 12345678910111213141516void nPreOrder(Node *bt)&#123; if (bt == NULL) return; stack&lt;Node*&gt; s; // 如果栈为空但是bt不为空则需要继续遍历 while (!ss.empty() || bt)&#123; while (bt != NULL)&#123; cout &lt;&lt; bt-&gt;val &lt;&lt; " "; s.push(bt); bt = bt-&gt;lchild; &#125; if (s.empty()) return; bt = s.top(); bt = bt-&gt;rchild; s.pop(); &#125;&#125; postorder 12345678910111213141516171819class Solution2 &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if (!root) return result; stack&lt;TreeNode*&gt; ss; ss.push(root); while (!ss.empty())&#123; root = ss.top(); result.push_back(root-&gt;val); ss.pop(); if (root-&gt;left) ss.push(root-&gt;left); if (root-&gt;right) ss.push(root-&gt;right); &#125; reverse(result.begin(), result.end()); return result; &#125;&#125;; 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if (!root) return result; stack&lt;TreeNode*&gt; ss; while (!ss.empty() || root)&#123; while (root)&#123; result.push_back(root-&gt;val); ss.push(root); root = root-&gt;right; &#125; if (!ss.empty())&#123; root = ss.top(); ss.pop(); &#125; if(root) root = root-&gt;left; &#125; reverse(result.begin(), result.end()); return result; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; // 用来记录上次访问的节点是什么，从而判断当前节点是不是第一次访问 TreeNode* pre=NULL; while (root || !s.empty())&#123; while (root)&#123; s.push(root); root = root-&gt;left; &#125; if (s.empty()) break; root = s.top(); if (root-&gt;right &amp;&amp; root-&gt;right != pre)&#123; root = root-&gt;right; &#125;else&#123; // 包含两种情况，1. 是叶子节点 2. 是第二次访问的节点 res.push_back(root-&gt;val); pre = root; s.pop(); root = NULL; &#125; &#125; return res; &#125;&#125;; 二叉树路径和为某一值112.Path Sum 题目大意 给定一棵二叉树和某个值，判断二叉树是否存在某条路径使得路径和为给定值。路径的起点为根节点，终点为叶子节点。 思路 递归 非递归 非递归的方法，因为在遍历完左子树和右子树时才能pop掉当前节点，所以和后序遍历很相似 三种后序遍历方法 标记节点是第几次访问，如果是第二次访问，则visit该节点。如果节点无法标记做没法做 使用left-right-root的reverse是root-right-left，稍微修改先序遍历代码，得到root-right-left的访问结果，再翻转即可 使用pre节点，记录回溯时刻当前节点的上一次访问的节点，如果是右子树，那么是第二次访问，visit，否则是第一次访问，继续保留在栈中 显然，这个问题只能用第三种方法做。 代码 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; stack&lt;TreeNode*&gt; ss; TreeNode* pre=NULL; int s = 0; while (root || !ss.empty())&#123; while (root)&#123; s += root-&gt;val; ss.push(root); root = root-&gt;left; &#125; if (ss.empty()) break; root = ss.top(); if ((!root-&gt;left &amp;&amp; !root-&gt;right) &amp;&amp; s==sum) return true; if (root-&gt;right &amp;&amp; root-&gt;right != pre)&#123; root = root-&gt;right; &#125;else&#123; pre = root; s -= root-&gt;val; ss.pop(); root = NULL; &#125; &#125; return false; &#125;&#125;; 12345678class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (!root) return false; if ((root-&gt;val == sum) &amp;&amp; (!root-&gt;left &amp;&amp; !root-&gt;right)) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; 113.Path Sum II 题目大意 给定一颗二叉树和给定值，要求找到所有的和为给定值的路径，路径定义和上题一样 思路 有了上题基础，直接递归思路，设置两个引用参数，用于存储路径即可 代码 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; if (!root) return res; findPath(res, tmp, root, sum); return res; &#125;private: void findPath(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, TreeNode* root, int sum)&#123; if (!root) return; if ((root-&gt;val == sum) &amp;&amp; (!root-&gt;left &amp;&amp; !root-&gt;right))&#123; tmp.push_back(root-&gt;val); res.push_back(tmp); tmp.pop_back(); return; &#125; tmp.push_back(root-&gt;val); findPath(res, tmp, root-&gt;left, sum-root-&gt;val); findPath(res, tmp, root-&gt;right, sum-root-&gt;val); tmp.pop_back(); &#125;&#125;; 437. Path Sum III 题目大意 给定二叉树和给定值，求和为给定值的路径个数，路径的起始和结束不一定是跟节点和叶子节点，但是肯定是自上而下的。 思路 这道题和求解Binary Tree Maximum Path Sum ,相当于遍历二叉树每个节点，以每个节点作为起始点，搜索是否存在相应的路径 代码 12345678910111213141516class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if (!root) return 0; return totalPath(root, sum, 0) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); &#125;private: int totalPath(TreeNode* root, int sum, int s)&#123; if (!root) return 0; int total = 0; if (s+root-&gt;val == sum) total++; return total + totalPath(root-&gt;left, sum, s+root-&gt;val) + totalPath(root-&gt;right, sum, s+root-&gt;val); &#125;&#125;; 255.Verify Preorder Sequence in Binary Search Tree 题目大意 给定一个序列，判断是否是搜索二叉树的后序遍历（剑指offer上是后序） 思路 序列的最后一个数是根节点，将n-1的序列分为小于和大于两部分，如果找到分界点后，大于的部分出现了小于根节点的数则不符合要求； 递归左子树和右子树 1234567891011121314151617181920212223class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if (sequence.empty()) return false; int n = sequence.size(), i=0, j=0; bool flagLeft=true, flagRight=true; for (; i!=n-1; ++i)&#123; if (sequence[i] &gt; sequence[n-1]) break; &#125; j = i; for (; j!=n-1; ++j)&#123; if (sequence[j] &lt; sequence[n-1]) return false; &#125; vector&lt;int&gt; left(sequence.begin(), sequence.begin()+i); vector&lt;int&gt; right(sequence.begin()+i, sequence.end()-1); if(!left.empty()) flagLeft = VerifySquenceOfBST(left); if (!right.empty()) flagRight = VerifySquenceOfBST(right); return (flagLeft &amp;&amp; flagRight); &#125; 114.Flatten Binary Tree to Linked List 题目大意 将一棵二叉树转换为链表，要求in-place 思路 递归：先将链表的末端（右侧）完成，递归到最左侧 非递归 遍历所有节点 保存好root右子树的 root右子树指向左子树 1234567891011121314class Solution &#123;public: void flatten(TreeNode* root) &#123; if (!root) return; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right = pre; root-&gt;left = NULL; pre = root; &#125;private: TreeNode* pre;&#125;; 1234567891011121314151617181920class Solution &#123;public: void flatten(TreeNode* root) &#123; if (!root) return; while (root)&#123; if (!root-&gt;left)&#123; root = root-&gt;right; &#125;else&#123; TreeNode* tmp = root-&gt;left; while (tmp-&gt;right)&#123; tmp = tmp-&gt;right; &#125; tmp-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125; &#125; &#125;&#125;; 二叉搜索树与双向链表 题目大意 将一棵二叉搜索树转换为双向链表 思路 很上一题很相似，都是二叉树转换为链表，上题是先序遍历，该题是中序遍历 分为三个部分，根节点、左节点和右节点 将左子树排序好返回最大的链表节点 将根节点插入到链表中(最后一个节点) 将右节点当做根节点递归 代码 123456789101112131415161718192021222324252627class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; if(!pRootOfTree) return pRootOfTree; TreeNode* last = NULL; convertNode(pRootOfTree, &amp;last); TreeNode* tmp = last; while (tmp != NULL &amp;&amp; tmp-&gt;left != NULL) tmp = tmp-&gt;left; return tmp; &#125;private: void convertNode(TreeNode* node, TreeNode** last)&#123; if (node == NULL) return; TreeNode* cur = node; if (node-&gt;left) convertNode(node-&gt;left, last); cur-&gt;left = *last; if (*last) (*last)-&gt;right = cur; *last = cur; if (cur-&gt;right) convertNode(cur-&gt;right, last); &#125;&#125;; 104.Maximum Depth of Binary Tree111.Minimum Depth of Binary Tree题目大意 题目很简单，得到一颗二叉树的最大深度和最小深度。深度的定义是根节点到叶子节点的路径长度。 思路 递归思路 1 + 以当前节点为根节点的最小或最大深度 层次遍历 如果节点是左右子树均为NULL，则为叶子节点 最小，第一次遇到叶子节点即返回深度 最大，遍历所有，返回最大深度即可 代码 min 123456789class Solution1 &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; if (!root-&gt;left) return 1+minDepth(root-&gt;right); if (!root-&gt;right) return 1+minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;right), minDepth(root-&gt;left)); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435// 使用队列，用额外的空间存储层数相关信息class Solution2 &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; queue&lt;map&lt;TreeNode*, int&gt; &gt; q; int layer = 0; TreeNode* cur = root; while (cur != NULL || !q.empty())&#123; if (cur != NULL)&#123; if (cur-&gt;left != NULL)&#123; map&lt;TreeNode*, int&gt; m1; m1[cur-&gt;left] = layer++; q.push(m1); &#125; if (cur-&gt;right != NULL)&#123; map&lt;TreeNode*, int&gt; m2; m2[cur-&gt;right] = layer++; q.push(m2); &#125; &#125; if (!q.empty())&#123; map&lt;TreeNode*, int&gt; m; m = q.front(); cur = (m.begin())-&gt;first; layer = m[cur]; q.pop(); if (!(cur-&gt;left || cur-&gt;right)) return m[cur]; &#125; &#125; return layer; &#125;&#125;; 12345678910111213141516171819202122232425// 比较巧妙的记录层数信息，每一次都遍历完队列中的节点，这些节点都是属于同一层的cclass Solution3 &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; queue&lt;TreeNode*&gt; q; TreeNode* cur = root; q.push(cur); int layer = 0; while (!q.empty())&#123; ++layer; int k = q.size(); for (int i=0; i!=k; ++i)&#123; cur = q.front(); q.pop(); if (cur-&gt;left) q.push(cur-&gt;left); // if we judge the push TreeNode is not NULL, // then you couldn't judge the node is not NULL outspace if (cur-&gt;right) q.push(cur-&gt;right); if (!(cur-&gt;left || cur-&gt;right)) return layer; &#125; &#125; return 0; &#125;&#125;; max 12345678910class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; if (!root-&gt;left) return 1+maxDepth(root-&gt;right); if (!root-&gt;right) return 1+maxDepth(root-&gt;left); return 1+max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)); &#125;&#125;; 12345678910111213141516171819202122class Solution1 &#123;public: int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; queue&lt;TreeNode*&gt; q; TreeNode* cur = root; q.push(cur); int layer = 0; while(!q.empty())&#123; layer++; int k = q.size(); for (int i=0; i!=k; ++i)&#123; cur = q.front(); q.pop(); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125; &#125; return layer; &#125;&#125;; 222.Count Complete Tree Nodes题目大意 给定一颗完全二叉树，求节点个数。要求复杂度低于O(n) 思路 如果左子树右子树高度相等，那么不需要判断直接根据高度计算。否则，递归计算左子树和右子树的节点数。 因为一定存在较多满二叉树，所以时间复杂度低于O(n)。仔细想想，不存在太坏的情况。 123456789101112131415161718class Solution &#123;public: int countNodes(TreeNode* root) &#123; if (!root) return 0; TreeNode *l=root, *r=root; int lh=0, rh = 0; while(l) &#123; l = l-&gt;left; lh++; &#125; while(r) &#123; r = r-&gt;right; rh++; &#125; if (lh == rh) return pow(2, lh) - 1; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; 236.Lowest Common Ancestor of a Binary Tree题目大意 找到一棵二叉树两点节点最近公共祖先。 思路 遍历找到分别到两个节点的路径，比较两个路径，第一个不同节点的上一个节点则为公共祖先 如果root为p则返回root，如果root为q则返回root，如果root为空则返回空(其实也就是返回了p或q是否在子树里) 否则，递归左、右子树 如果q、p在同一个子树那么返回的就是公共祖先，否则如果p和q分别在两个子树，则root是公共祖先 123456789101112131415class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root) return root; if (root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) return root; if (!left) return right; else return left; &#125;&#125;; 235.Lowest Common Ancestor of a Binary Search Tree题目大意 给定一个二叉搜索树及两个节点，找到节点的最近公共祖先。 思路 利用BST的特点，如果p和q的值跟root比一大一小，则root为最近公共祖先，否则递归左子树或者右子树。 12345678910class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); if (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); return root; &#125;&#125;; 124.Binary Tree Maximum Path Sum题目大意 给定一棵二叉树，找到最大的路径和。路径可以试从child-root-child 思路 类比求数组的最大连续子数组和 用res记录最大路径和，每一层递归记录以root为中间节点的最大和(root-&gt;val + max(0, left) + max(0, right)) 返回的是root-child的单向最大和，因为需要和parent组成child-root-child路径 12345678910111213141516171819class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int res = INT_MIN; findMax(root, res); return res; &#125;private: int findMax(TreeNode* root, int&amp; res)&#123; if (root==NULL) return 0; int left = findMax(root-&gt;left, res); int right = findMax(root-&gt;right, res); if (left &lt; 0) left = 0; if (right &lt; 0) right = 0; if (root-&gt;val + left + right &gt; res) res = root-&gt;val + left + right; return root-&gt;val + max(left, right); &#125;&#125;; root-child的最大路径和1234567891011121314151617181920class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int res = INT_MIN; findMax(root, res); return res; &#125;private: int findMax(TreeNode* root, int&amp; res)&#123; if (root==NULL) return 0; int left = findMax(root-&gt;left, res); int right = findMax(root-&gt;right, res); if (left &lt; 0) left = 0; if (right &lt; 0) right = 0; int cur = root-&gt;val + max(left, right); res = max(res, cur); return res; &#125;&#125;; 116. Populating Next Right Pointers in Each Node117. Populating Next Right Pointers in Each Node II题目大意 给定一棵满二叉树，在水平方向上的前一个节点有next指针指向下一个节点； 如果是一颗普通二叉树呢 思路 满二叉树 当前节点的left指向right 当前root节点的right的next指向root-&gt;next的left节点 递归左子树和右子树 普通二叉树 root的right要指向的节点隔了好几个节点（while(root-&gt;next)找到root-&gt;next-&gt;left或者root-&gt;next-&gt;right不为空的节点） 上面的循环要求右子树先形成next，所以先递归右子树 1234567891011121314151617181920212223/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root==NULL) return; if (root-&gt;next)&#123; if (root-&gt;right &amp;&amp; root-&gt;next-&gt;left) root-&gt;right-&gt;next = root-&gt;next-&gt;left; &#125; if (root-&gt;left &amp;&amp; root-&gt;right)&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; connect(root-&gt;left); connect(root-&gt;right); &#125;&#125;; 12345678910111213141516171819202122232425262728class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root == NULL) return; int flag = 0; TreeLinkNode* tmp = root; // 因为二叉树不是完全二叉树，可能水平方向隔了很多个节点才有下一个节点，所以需要一直循环root-&gt;next // 直到找到下一个节点或者null TreeLinkNode* left = tmp-&gt;right ? tmp-&gt;right : tmp-&gt;left; while (tmp-&gt;next)&#123; TreeLinkNode* right = tmp-&gt;next-&gt;left ? tmp-&gt;next-&gt;left : tmp-&gt;next-&gt;right; if (left &amp;&amp; right)&#123; left-&gt;next = right; flag = 1; &#125; if (flag == 1) break; tmp = tmp-&gt;next; &#125; if (root-&gt;left &amp;&amp; root-&gt;right)&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; // 可能root右侧隔了很多个空节点才有节点，所以先调整好右边，在到左边 一直循环next找下去 connect(root-&gt;right); connect(root-&gt;left); &#125;&#125;; Tree208.Implement Trie (Prefix Tree)题目大意 实现一棵字典树 思路 一个trie node，用于存储当前的字母以及当前字母是否为单词的结束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class TrieNode &#123;public: TrieNode* next[26]; bool is_word; TrieNode(bool word = false)&#123; memset(next, 0, sizeof(next)); is_word = word; &#125;&#125;;class Trie &#123;public: /** Initialize your data structure here. */ Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; TrieNode* p = root; for (int i=0; i!=word.size(); ++i)&#123; if (p-&gt;next[word[i]-'a'] == NULL)&#123; p-&gt;next[word[i]-'a'] = new TrieNode(); &#125; p = p-&gt;next[word[i]-'a']; &#125; p-&gt;is_word = true; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; if (word.empty()) return true; TrieNode* p = root; for (int i=0; i!=word.size(); ++i)&#123; if (p-&gt;next[word[i]-'a'] != NULL) p = p-&gt;next[word[i]-'a']; else return false; &#125; return p-&gt;is_word; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; TrieNode* p = root; for (int i=0; i!=prefix.size(); ++i)&#123; if (p-&gt;next[prefix[i]-'a'] != NULL) p = p-&gt;next[prefix[i]-'a']; else return false; &#125; return true; &#125;private: TrieNode* root;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * bool param_2 = obj.search(word); * bool param_3 = obj.startsWith(prefix); */ 116. Populating Next Right Pointers in Each Node题目大意 给定一棵满二叉树，要求每个节点有个next指针，指向右侧的节点 思路 递归处理，对于每个节点root，需要做两件事情 将右子树的next指向next的左子树 root-&gt;right-&gt;next = root-&gt;next-&gt;left 将左子树next指向右子树 123456789101112131415class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root==NULL) return; if (root-&gt;next)&#123; if (root-&gt;right &amp;&amp; root-&gt;next-&gt;left) root-&gt;right-&gt;next = root-&gt;next-&gt;left; &#125; if (root-&gt;left &amp;&amp; root-&gt;right)&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; connect(root-&gt;left); connect(root-&gt;right); &#125;&#125;; 117. Populating Next Right Pointers in Each Node II题目大意 将上题中的满二叉树改为普通二叉树 思路 两个问题 水平方向上当前节点next需要指向的节点可能隔了好几个空节点，怎么办 可以考虑一直root-&gt;next循环，直到找到非空的节点 如何保证水平方向右边的next指针是已经建立好的（这样才可以循环找到非空节点） 先递归右子树，再递归左子树 12345678910111213141516171819202122232425262728class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root == NULL) return; int flag = 0; TreeLinkNode* tmp = root; // 因为二叉树不是完全二叉树，可能水平方向隔了很多个节点才有下一个节点，所以需要一直循环root-&gt;next // 直到找到下一个节点或者null TreeLinkNode* left = tmp-&gt;right ? tmp-&gt;right : tmp-&gt;left; while (tmp-&gt;next)&#123; TreeLinkNode* right = tmp-&gt;next-&gt;left ? tmp-&gt;next-&gt;left : tmp-&gt;next-&gt;right; if (left &amp;&amp; right)&#123; left-&gt;next = right; flag = 1; &#125; if (flag == 1) break; tmp = tmp-&gt;next; &#125; if (root-&gt;left &amp;&amp; root-&gt;right)&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; // 可能root右侧隔了很多个空节点才有节点，所以先调整好右边，在到左边 一直循环next找下去 connect(root-&gt;right); connect(root-&gt;left); &#125;&#125;; stack&amp;queue155.min stack 题目大意 实现一个栈，包括push、pop、top、和min方法，min方法是返回栈中最小值 思路 用一个数组存排序好的栈中的数，这种方法略笨重，时间复杂度也高； 两个栈ss和m_ss，ss用来存储栈数据，m_ss用来存储当前的最小值(用栈来实现很巧妙) m_ss入栈的时候永远是当前的最小值，如果新压入栈数大于栈顶元素则压入栈顶元素，否则压入该元素 出栈时，如果当前数是最小值，那么m_ss出栈了，m_ss栈顶位置是之前的最小值；如果当前数不是最小值，则m_ss出栈不影响之后的最小值。 代码 12345678910111213141516171819202122232425262728293031323334class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; ss.push(x); if (m_ss.empty() || m_ss.top() &gt; x) m_ss.push(x); else m_ss.push(m_ss.top()); &#125; void pop() &#123; assert(!ss.empty()); ss.pop(); m_ss.pop(); &#125; int top() &#123; assert(!ss.empty()); return ss.top(); &#125; int getMin() &#123; assert(!m_ss.empty()); return m_ss.top(); &#125;private: stack&lt;int&gt; ss; stack&lt;int&gt; m_ss;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 数组版本class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; ss.push(x); insert(x); &#125; void pop() &#123; int tmp = ss.top(); ss.pop(); remove(tmp); &#125; int top() &#123; if (!ss.empty()) return ss.top(); else return INT_MIN; &#125; int getMin() &#123; if (!ss.empty()) return minVec[0]; else return INT_MIN; &#125;private: void insert(int x)&#123; int low = findIndex(x); minVec.insert(minVec.begin()+low, x); &#125; void remove(int x)&#123; int low = findIndex(x); minVec.erase(minVec.begin()+low, minVec.begin()+low+1); &#125; int findIndex(int x)&#123; int low=0, high=minVec.size()-1, mid=0; while (low&lt;=high)&#123; mid = low + (high - low) / 2; if (minVec[mid] &lt; x) low = mid + 1; else high = mid - 1; &#125; return low; &#125; stack&lt;int&gt; ss; vector&lt;int&gt; minVec;&#125;; Dfs&amp;bfs22.Generate Parentheses 题目大意 给定一个数n，表示是括号的个数，输出包含n个括号的组合 思路 这种排列组合类的题，dfs是万能，需要考虑 左括号和右括号的个数 当前字符串中加入右括号时，右括号个数不能大于左括号个数 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; dfs(res, "", n, n); return res; &#125;private: void dfs(vector&lt;string&gt;&amp; res, string tmp, int left, int right)&#123; if (left==0 &amp;&amp; right==0)&#123; res.push_back(tmp); return; &#125; if (left &gt; 0) dfs(res, tmp+"(", left-1, right); if (right &gt; 0 &amp;&amp; right &gt; left) dfs(res, tmp+")", left, right-1); &#125;&#125;; 51. N-Queens52. N-Queens II 问题描述 $n\times n$的棋盘，放上n个皇后，要求每一行、每一列、45度和135度方向均不能存在两个皇后，问有多少种放法，以及输出每种放置方法。 回溯法 每一层放置一个皇后，遍历n个位置，如果该位置合法，进入下一行放置下一个皇后 dfs思路 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; chess(n, string(n, '.')); dfs(res, chess, 0, n); return res; &#125;private: void dfs(vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; chess, int row, int n)&#123; if (row == n)&#123; res.push_back(chess); return; &#125; for (int col=0; col!=n; ++col)&#123; if (isvalid(chess, row, col, n))&#123; chess[row][col] = 'Q'; dfs(res, chess, row+1, n); chess[row][col] = '.'; &#125; &#125; &#125; bool isvalid(vector&lt;string&gt;&amp; chess, int row, int col, int n)&#123; for (int i=0; i!=row; ++i)&#123; if (chess[i][col] == 'Q') return false; &#125; for (int x=row-1, y=col-1; x&gt;=0 &amp;&amp; y&gt;=0; --x, --y)&#123; if (chess[x][y] == 'Q') return false; &#125; for (int x=row-1, y=col+1; x&gt;=0 &amp;&amp; y&lt;n; --x, ++y)&#123; if (chess[x][y] == 'Q') return false; &#125; return true; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int totalNQueens(int n) &#123; int res=0; vector&lt;string&gt; chess(n, string(n, '.')); dfs(res, chess, 0, n); return res; &#125;private: void dfs(int&amp; res, vector&lt;string&gt;&amp; chess, int row, int n)&#123; if (row == n)&#123; res++; return; &#125; for (int col=0; col!=n; ++col)&#123; if (isvalid(chess, row, col, n))&#123; chess[row][col] = 'Q'; dfs(res, chess, row+1, n); chess[row][col] = '.'; &#125; &#125; &#125; bool isvalid(vector&lt;string&gt;&amp; chess, int row, int col, int n)&#123; for (int i=0; i!=row; ++i)&#123; if (chess[i][col] == 'Q') return false; &#125; for (int x=row-1, y=col-1; x&gt;=0 &amp;&amp; y&gt;=0; --x, --y)&#123; if (chess[x][y] == 'Q') return false; &#125; for (int x=row-1, y=col+1; x&gt;=0 &amp;&amp; y&lt;n; --x, ++y)&#123; if (chess[x][y] == 'Q') return false; &#125; return true; &#125;&#125;; trick54.Spiral Matrix 题目大意 给定一个二维数组，要求螺旋打印数组中的数 思路 每一圈的左上角的点都是(start, start)，start 2 &lt; m &amp;&amp; start 2&lt;n 每一圈，有四个方向，有相应的限制条件，在相应限制条件下打印即可 代码 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if (matrix.empty() || matrix[0].empty()) return res; int row=matrix.size(), col=matrix[0].size(); int start=0, endRow=0, endCol=0; while (start*2&lt;row &amp;&amp; start*2&lt;col)&#123; endRow = row - start - 1; endCol = col - start - 1; for (int i=start; i&lt;=endCol; ++i) res.push_back(matrix[start][i]); if (start &lt; endRow)&#123; for (int i=start+1; i&lt;=endRow; ++i) res.push_back(matrix[i][endCol]); &#125; if (start &lt; endRow &amp;&amp; start &lt; endCol)&#123; for (int i=endCol-1; i&gt;=start; --i) res.push_back(matrix[endRow][i]); &#125; if (start &lt; endRow-1 &amp;&amp; start &lt; endCol)&#123; for (int i=endRow-1; i&gt;start; --i) res.push_back(matrix[i][start]); &#125; start++; &#125; return res; &#125;&#125;; 169.Majority Element 题目大意 给定一个长度为n的数组，找出数组中出现次数大于n/2的数 思路 排序 majority element的次数 随机找个数，判断是否为majority element Bit Manipulation 计算每一位是否是majority 代码 12345678910111213141516171819// 2class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int result = nums[0], times = 1; for (int i=1; i!=nums.size(); ++i)&#123; if (result != nums[i])&#123; times--; if (times &lt; 0)&#123; result = nums[i]; times = 1; &#125; &#125; else times++; &#125; return result; &#125;&#125;; 123456789101112131415161718// 4class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int major = 0, n = nums.size(); for (int i = 0, mask = 1; i &lt; 32; i++, mask &lt;&lt;= 1) &#123; int bitCounts = 0; for (int j = 0; j &lt; n; j++) &#123; if (nums[j] &amp; mask) bitCounts++; if (bitCounts &gt; n / 2) &#123; major |= mask; break; &#125; &#125; &#125; return major; &#125; &#125;; 229.Majority Element II 题目大意 给定一个长度为n的数组，找出数组中出现次数大于n/3的数 要求线性时间复杂度，空间复杂度为O(1) 思路 Moore Majority Voting 使用res1和res2记录当前两个数，count1和count2记录当前两个数出现的次数 可行性分析 如果存在两个满足条件的数，那么剩下的数出现次数将少于n/3，所以最后剩下的两个数一定是次数大于n/3的数 如果只存在一个满足条件的数a，则a出现次数t大于n/3，最多能减少的次数为(n-t)/2 &lt; n/3，所以a必然能保留到最后(333331212) 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int res1=0, count1=0, res2=0, count2=0; for (int i=0; i!=nums.size(); ++i)&#123; if (nums[i] == res1) count1++; else if (nums[i] == res2) count2++; else if (count1 == 0)&#123; res1 = nums[i]; count1 = 1; &#125; else if (count2 == 0)&#123; res2 = nums[i]; count2 = 1; &#125; else&#123; count1--; count2--; &#125; &#125; count1 = 0; count2 = 0; for (int i=0; i!=nums.size(); ++i)&#123; if (nums[i] == res1) count1++; if (nums[i] == res2) count2++; &#125; if (count1 &gt; nums.size()/3) res.push_back(res1); if (count2 &gt; nums.size()/3 &amp;&amp; res2 != res1) res.push_back(res2); return res; &#125;&#125;; 347.Top K Frequent Elements 题目大意 给定一个数组，找出出现频率最多的k个数 思路 先统计每个数出现次数 使用优先级队列排序，使优先级队列的大小为(n-k) 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; cache1; vector&lt;int&gt; res, tmp; for (int i=0; i!=nums.size(); ++i)&#123; cache1[nums[i]]++; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; q; for (map&lt;int, int&gt;::iterator it=cache1.begin(); it!=cache1.end(); ++it)&#123; q.push(make_pair(it-&gt;second, it-&gt;first)); if (q.size() &gt; cache1.size()-k)&#123; res.push_back(q.top().second); q.pop(); &#125; &#125; return res; &#125;&#125;; 215.Kth Largest Element in an Array 题目大意 找到数组中第k大的元素 思路 堆 维护一个k大小的最小堆(优先级队列) 遍历完所有元素，堆顶元素即为k大的元素 partition 1234567891011class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for (int i=0; i!=nums.size(); ++i)&#123; q.push(nums[i]); if (q.size() &gt; k) q.pop(); &#125; return q.top(); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int s = 0, e = nums.size()-1, index = 0; while (true)&#123; index = partition(nums, s, e); if (index == nums.size()-k) break; else if (index &lt; nums.size()-k)&#123; s = index+1; &#125;else&#123; e = index-1; &#125; &#125; return nums[index]; &#125;private: int partition(vector&lt;int&gt;&amp; nums, int s, int e)&#123; int tmp = nums[s]; while (s &lt; e)&#123; // 注意快排时，交换以后s和e需要改变，否则遇到有重复数的数组会进入死循环 while(s &lt; e &amp;&amp; nums[e] &gt; tmp) --e; if (s &lt; e) nums[s++] = nums[e]; while(s &lt; e &amp;&amp; nums[s] &lt; tmp) ++s; if (s &lt; e) nums[e--] = nums[s]; &#125; nums[s] = tmp; return s; &#125;&#125;; 179.Largest Number 题目大意 给定一个数组，将数组中的数拼接成一个大数，求其中最大的数 思路 将数组中的数按照拼接的大小顺序排序 注意，拼接后的数可能会非常大，是一个大数问题，需要用字符串表示 12345678910111213141516171819class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; new_nums; string res = ""; for (int i=0; i!=nums.size(); ++i) new_nums.push_back(to_string(nums[i])); sort(new_nums.begin(), new_nums.end(), compare); for (int i=0; i!=new_nums.size(); ++i) res += new_nums[i]; while (res.size() &gt; 1 &amp;&amp; res[0] == '0') res.erase(0, 1); return res; &#125; // 给sort用的函数，必须是static或者在类外定义，否则sort无法访问 bool static compare(string a, string b)&#123; return (a+b) &gt; (b+a); &#125;&#125;; 264.Ugly Number II 题目大意 因子分解只有2、3和5的数称为丑数，给定n，求第n个丑数是多少。默认1为第一个丑数 思路 新的丑数都是由旧的丑数乘以2或3或5得到的 记录2或3或5乘到的位置，每次选取最小的即可 12345678910111213141516class Solution &#123;public: int nthUglyNumber(int n) &#123; if (n &lt;= 1) return 1; vector&lt;int&gt; dp(1, 1); int l2=0, l3=0, l5=0; for (int i=0; i!=n; ++i)&#123; int tmp = min(dp[l2]*2, min(dp[l3]*3, dp[l5]*5)); if (tmp == dp[l2]*2) l2++; if (tmp == dp[l3]*3) l3++; if (tmp == dp[l5]*5) l5++; dp.push_back(tmp); &#125; return dp[n-1]; &#125;&#125;; 315.Count of Smaller Numbers After Self 题目大意 给定一个数组，返回一个数组，每个位置表示在该数右边比该数小的个数 思路 暴力，O(n^2) 巧妙使用归并排序 学习到递归形式的归并排序，简单好写 每一趟归并排序时，数组两部分都是有序的，所以左侧的较大的数的逆序数是建立在较小数的基础上，比如a[2]是在a[1]的逆序数上开始进行累加，避免了重复计算 该题要求返回每个位置的逆序数，所以不能直接对原数组进行归并排序，采用了对原数组的index进行归并排序； 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); vector&lt;int&gt; res(n, 0), index(n, 0); for (int i=0; i!=n; ++i) index[i] = i; mergeCount(nums, res, index, 0, n); return res; &#125;private: void mergeCount(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; res, vector&lt;int&gt;&amp; index, int s, int n)&#123; if (s &lt; n-1)&#123; int count = 0, mid = s + (n - s) / 2; mergeCount(nums, res, index, s, mid); mergeCount(nums, res, index, mid, n); //cout &lt;&lt; "== " &lt;&lt; s &lt;&lt; " " &lt;&lt; n &lt;&lt; endl; int id1 = s, id2 = mid; // 避免需要另一个vector存储排序好的数组 vector&lt;int&gt; tmp; while (id1&lt;mid || id2&lt;n)&#123; if (id2 == n || (id1 &lt; mid &amp;&amp; nums[index[id1]] &lt;= nums[index[id2]]))&#123; tmp.push_back(index[id1]); //cout &lt;&lt; 'a' &lt;&lt; id1 &lt;&lt; " " &lt;&lt; index[id1] &lt;&lt; " " &lt;&lt; count &lt;&lt; endl; res[index[id1]] += count; id1++; &#125;else&#123; tmp.push_back(index[id2++]); count++; //cout &lt;&lt; 'b' &lt;&lt; id2 &lt;&lt; " " &lt;&lt; count &lt;&lt; endl; &#125; &#125; move(tmp.begin(), tmp.end(), index.begin()+s); &#125; &#125;&#125;; 数组中的逆序对 题目大意 返回数组中逆序对个数 思路 归并排序 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; int n = data.size(); vector&lt;int&gt; tmp(n, 0); return mergeCount(data, tmp, 0, n)%1000000007 ; &#125;private: long long mergeCount(vector&lt;int&gt;&amp; data, vector&lt;int&gt;&amp; tmp, int s, int n)&#123; int length = n - s; long long count = 0, left = 0, right = 0; if (length &gt; 1)&#123; int mid = s + length / 2; left = mergeCount(data, tmp, s, mid); right = mergeCount(data, tmp, mid, n); int s1 = mid-1, s2 = n-1, i=n-1; while (s1 &gt;= s &amp;&amp; s2 &gt;= mid)&#123; if (data[s1] &gt; data[s2])&#123; count = count + s2 - mid + 1; tmp[i--] = data[s1--]; &#125;else tmp[i--] = data[s2--]; &#125; while (s1 &gt;= s) tmp[i--] = data[s1--]; while (s2 &gt;= mid) tmp[i--] = data[s2--]; for (int k=s; k!=n; ++k) data[k] = tmp[k]; &#125; return left+right+count; &#125;&#125;; 补充 取余和取模 步骤 c = a / b r = a - c * b 区别 取余 c取的时候往0方向取 取模 c取的时候往负无穷方向取 1.Two Sum题目大意 给定一个整数数组和一个目标和，返回数组中加起来和是目标和的两个数的下标。 思路 如果暴力搜索的话，需要O(n^2)复杂度，可以遍历过程中，用map存储，key是值，value是下标。如果能够在map中找到(target-nums[i])，则将对应的下标和i返回即可。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; cache; vector&lt;int&gt; res; for (int i=0; i!=nums.size(); ++i)&#123; if (cache.find(target - nums[i]) != cache.end())&#123; res.push_back(cache[nums[i]]); res.push_back(i); return res; &#125; cache[nums[i]] = i; &#125; return res; &#125;&#125;; 191.Number of 1 Bits题目大意 给定一个32位无符号整数，求该整数二级制形式1的个数。 思路 遍历每一位，记录1的个数即可。 不要使用除操作，耗时较久，使用移位和与操作。 如果是有符号整数，可能会导致循环无法结束，可以左移1来遍历。 n &amp; (n-1)的操作能够将最右边的1变为0，可以将所有的1都变为0，需要的次数即为1的个数。 代码 123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0; while (n)&#123; if (n &amp; 1) ++sum; n = n &gt;&gt; 1; &#125; return sum; &#125;&#125;; 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0; while (n)&#123; ++sum; n = (n-1) &amp; n; &#125; return sum; &#125;&#125;; 12345678910111213// consider signed intclass Solution &#123;public: int hammingWeight(uint32_t n) &#123; unsigned int sum = 0, flag = 1; while (flag)&#123; if (flag &amp; n) ++sum; flag = flag &lt;&lt; 1; &#125; return sum; &#125;&#125;; 231.Power of Two326.Power of Three342.Power of Four题目大意 给定一个整数，求是否是2、3、4的整数次方。 思路 基础思路 一直除2(3,4)，直到有余数，判断此时n是否为1即可，如果不为1，说明不是整数次幂； 不用循环的解法 2 n &amp; (n-1) == 0 则为整数幂 $2^{30}$%n == 0，因为$2^{30-k} 2^k = 2^{30}$，所以如果整除n，则为2的整数幂 3 $3^{19}$%n == 0，因为$3^{19-k} 3^k = 3^{19}$，所以如果整除n，则为3的整数幂 4 满足三个条件 n &gt; 0 n &amp; (n - 1) == 0 (n - 1) % 3 == 0：在满足1、2前提下，只会出现2的整数幂和4的整数幂，而$4^n - 1 = (2^k-1)(2^k+1)$ ，而连续出现的三个数必定有一个是整除3的，而肯定不是$2^k$，$4^n-1$一定整除3，同时，$2^{2k+1}-1$必定不能整除3(为什么) 代码 2 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return (n &gt; 0 &amp;&amp; (n &amp; (n-1) == 0)); &#125;&#125;; 3 12345678910class Solution &#123;public: bool isPowerOfThree(int n) &#123; if (n&lt;=0) return false; while (!(n%3))&#123; n = n / 3; &#125; return (n==1); &#125;&#125;; 1234567class Solution &#123;public: bool isPowerOfThree(int n) &#123; int a = pow(3,19); return ((n&gt;0) &amp;&amp; ( a % n == 0)); &#125;&#125;; 4 12345678910class Solution &#123;public: bool isPowerOfFour(int num) &#123; if (num &lt;= 0) return false; while (!(num % 4))&#123; num = num / 4; &#125; return (num == 1); &#125;&#125;; 123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return (num &gt; 0 &amp;&amp; !(num &amp; (num - 1)) &amp;&amp; ((num - 1) % 3 == 0)); &#125;&#125;; 523.Continuous Subarray Sum题目大意 给定一个非负的数组，找到连续的子数组的和为k的整数倍 思路 要求时间复杂度为O(n) 考虑如果0~i位置元素和除以k的余数为res，如果0~j位置元素和除以k的余数也为res，同时i+1&lt;j，那么i+1~j即为和可以整除k的子数组 考虑k为0的情况 1234567891011121314151617181920class Solution &#123;public: bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; cache; cache[0] = -1; int sum = 0, res = 0; for (int i=0; i!=nums.size(); ++i)&#123; sum += nums[i]; // 如果k==0，那么只有0才满足要求 if (k == 0) res = sum; else res = sum % k; if (cache.find(res) != cache.end())&#123; if (cache[res]+1 &lt; i) return true; &#125;else cache[res] = i; &#125; return false; &#125;&#125;; 135.Candy题目大意 1234567There are N children standing in a line. Each child is assigned a rating value.You are giving candies to these children subjected to the following requirements:* Each child must have at least one candy.* Children with a higher rating get more candies than their neighbors.What is the minimum candies you must give? 思路 一个人分多少糖果取决于左边和右边的人，而左右边的人又有所依赖； 考虑每次只保证一侧是合法的，遍历两次即可 第一遍，从左到右，如果右边大于左边则给右边糖果个数+1 第二遍，从右到左，如果左边大于右边则给左边糖果+1 12345678910111213141516class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int n = ratings.size(); vector&lt;int&gt; cache(n, 1); for (int i=1; i!=n; ++i)&#123; if (ratings[i] &gt; ratings[i-1]) cache[i] = cache[i-1] + 1; &#125; for (int i=n-2; i&gt;=0; --i)&#123; if (ratings[i] &gt; ratings[i+1] &amp;&amp; cache[i] &lt;= cache[i+1]) cache[i] = cache[i+1] + 1; &#125; return accumulate(cache.begin(), cache.end(), 0); &#125;&#125;; 骰子和概率题目大意 返回n个骰子随机投，每种和的概率 思路 dfs 使用两个数组记录，n个骰子和的概率是在n-1个骰子和概率基础上计算的 n个骰子，和为m的次数是n-1个骰子和为m-1、m-2…m-6的和 类似dp 1234567891011121314151617181920212223242526void printProb(int n)&#123; int maxSum = n * 6, flag = 0; vector&lt;vector&lt;int&gt;&gt; cache(2, vector&lt;int&gt;(maxSum+1, 0)); for (int i=1; i&lt;=6; ++i) cache[flag][i] = 1; flag = 1 - flag; for (int k=2; k&lt;=n; ++k)&#123; for (int i=1; i&lt;k; ++i) cache[flag][i] = 0; for (int i=k; i&lt;=k*6; ++i)&#123; cache[flag][i] = 0; for (int j=1; j&lt;=i &amp;&amp; j&lt;=6; ++j)&#123; cache[flag][i] += cache[1-flag][i-j]; &#125; &#125; flag = 1 - flag; &#125; int total = pow(6, n), p = 0; for (int i=n; i!=maxSum+1; ++i)&#123; cout &lt;&lt; i &lt;&lt; " " &lt;&lt; (double)cache[1-flag][i] / total &lt;&lt; endl; p += (double)cache[1-flag][i]; &#125; cout &lt;&lt; "total: " &lt;&lt; p &lt;&lt; endl;&#125; 扑克牌的顺子题目大意 判断抽取的牌是否为顺子，A为1，J为11，Q为12，K为13，大小王是0，可以替代任何数 思路 先排序，判断0的个数，和gap的个数，如果gap的个数大于0的个数，则返回false 12345678910111213141516171819class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; if (numbers.empty()) return false; sort(numbers.begin(), numbers.end()); int zeroNum = 0, gapNum = 0; for (int i=0; i!= numbers.size(); ++i)&#123; if (numbers[i] == 0) zeroNum++; if (i!=0 &amp; numbers[i-1]!=0)&#123; if (numbers[i-1] == numbers[i]) return false; else gapNum += numbers[i] - numbers[i-1] - 1; &#125; &#125; return zeroNum &gt;= gapNum; &#125;&#125;; 73.Set Matrix Zeroes题目大意 给定一个二维数组，将有0的位置的行和列置为0 思路 遍历每一行，记录每一个列出现0的位置，同时记录该行是否有0，如果有零，遍历完该行，将改行置为0 最后将记录的列置为0 12345678910111213141516171819202122232425class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return; int m=matrix.size(), n=matrix[0].size(), flag=0; set&lt;int&gt; zeros; for (int i=0; i!=m; ++i)&#123; for (int j=0; j!=n; ++j)&#123; if (matrix[i][j] == 0)&#123; flag = 1; zeros.insert(j); &#125; &#125; if (flag)&#123; for (int k=0; k!=n; ++k) matrix[i][k] = 0; &#125; flag = 0; &#125; for (set&lt;int&gt;::iterator it=zeros.begin(); it!=zeros.end(); ++it)&#123; for (int j=0; j!=m; ++j) matrix[j][*it] = 0; &#125; &#125;&#125;; 239.Sliding Window Maximum题目大意 给定一个数组和一个窗口大小，问当窗口在数组上滑动时，返回每个窗口最大值组成的数组。 思路 剑指offer上的原题啊 暴力法，暴力滑过各个窗口取得最大值，时间复杂度是O(nk)，每个窗口计算时重复比较了很多数 堆 用一个堆记录当前值的排序顺序，每滑动一个窗口，往堆中插入一个数，堆顶元素即使当前窗口的最大值 问题在于，如何弹出已经超过该窗口的元素。堆中元素包含下标，如果堆顶元素的小标超过了当前窗口的最小小标值，那么就pop掉。 时间复杂度O(nlogk) 双端队列 队列中存储的是降序排列的元素，自然队列头部是当前窗口的最大值，如果当前要插入的元素大于尾部数据，则弹出尾部数据，直到找到比该元素大的数插入； 问题在于，如何判断某个元素是否已经超过了该窗口，此时，可以考虑队列中存储下标，如果下标超过了当前窗口的最小下标，那么就需要pop掉； 12345678910111213141516171819struct cmp&#123; bool operator()(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b)&#123; return a.first &lt; b.first; &#125;&#125;;class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; q; vector&lt;int&gt; res; for (int i=0; i!=nums.size(); ++i)&#123; q.push(make_pair(nums[i], i)); while (q.top().second &lt; res.size()) q.pop(); if (i+1 &gt;= k) res.push_back(q.top().first); &#125; return res; &#125;&#125;; 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; q; vector&lt;int&gt; res; for (int i=0; i!=nums.size(); ++i)&#123; // 如果队首元素超过了结果的长度(第几个窗口)，那么需要弹出 if (!q.empty() &amp;&amp; q.front() &lt; res.size()) q.pop_front(); // 维护双端队列是一个降序，front位置永远是当前窗口的最大值 while (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i]) q.pop_back(); q.push_back(i); if (i&gt;=k-1) res.push_back(nums[q.front()]); &#125; return res; &#125;&#125;; 152. Maximum Product Subarray题目大意 给定一个数组，返回连续子数组的最大积 思路 只要中间没有零，那么连续子数组越长越好，同时恰好使得子数组负数个数为偶数，此时最大； front和back记录遍历过程中正向遍历和逆向遍历的每一步的最大值，除非遇到零。 123456789101112131415class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int front = 1, back = 1, res = INT_MIN; int n = nums.size(); for (int i=0; i!=n; ++i)&#123; front *= nums[i]; back *= nums[n-i-1]; res = max(res, max(front, back)); front = front == 0 ? 1 : front; back = back == 0 ? 1 : back; &#125; return res; &#125;&#125;; 3. Longest Substring Without Repeating Characters 题目大意 给定一个字符串，找到没有重复字符的最长字符串的长度 思路 用256大小的数组记录每个字符在字符串中出现的位置，如果没有出现用-1表示。 用start记录，没有重复字符的字符串的开始下标；遍历字符串，如果当前字符曾经出现过，且出现的位置在start以后，那么start将变为从该字符串上一次出现的位置。遍历过程中记录长度的最大值。 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; cache(256, -1); int res = 0, start = -1; for (int i=0; i&lt;s.size(); ++i)&#123; if (cache[s[i]] &gt; start) start = cache[s[i]]; cache[s[i]] = i; res = max(res, i - start); &#125; return res; &#125;&#125;; math233.Number of Digit One 题目大意 给定一个数n，求出1-n所有数中1出现的个数 思路 考虑每一位上为1的情况 例如考虑百位为1的情况，n为32198，a为321，b为98 如果百位(a%10) &gt;=2, 那么有(a/10+1)*m个1； 如果(a%10)==1，那么(a/10*m)+b+1个1； 如果(a%10)==0, 那么(a/10*m)个1； 综合起来(a+8)/10*m+(a%10==1?b+1:0); 123456789101112class Solution &#123;public: int countDigitOne(int n) &#123; int count = 0, a = 0, b = 0; for (long m=1; m&lt;=n; m*=10)&#123; a = n / m; b = n % m; count += (a+8)/10*m + ((a%10==1)?b+1:0); &#125; return count; &#125;&#125;; 69.Sqrt(x)题目大意 求一个数的开根号，返回floor(sqrt(x)) 思路 二分法 牛顿法 $f(x) = f(x_k) + f^-(x_k)(x - x_k)$ $x = x_k - \frac{f(x_k)}{f^-(x_k)}$ 1234567891011121314151617// binaryclass Solution &#123;public: int mySqrt(int x) &#123; long low = 0, high = x, mid = 0; while (low &lt;= high)&#123; mid = low + (high - low) / 2; // mid * mid 考虑越界问题 if (mid * mid &lt; x) low = mid + 1; else if (mid * mid &gt; x) high = mid - 1; else return mid; &#125; return high; &#125;&#125;; 1234567891011// newtonclass Solution &#123;public: int mySqrt(int x) &#123; long res = x; while (res*res &gt; x)&#123; res = (res + x / res) / 2; &#125; return res; &#125;&#125;; 50.Pow(x, n)题目大意 实现标准库中的pow运算。 思路 考虑一些边界条件以及优化 指数为负的情况； 底为零指数为负的情况，不能做除法； int的指数变负为正时，考虑最大的负数变为整数会越界； 提高效率，将$2^{2k+1}$装换为$2^k$的平方乘2 代码 12345678910111213141516171819202122232425262728class Solution &#123;public: double myPow(double x, int n) &#123; // float和double类型的比较不能直接比较 // 考虑底为零的情况 if ((x - 0.0) &lt; 0.0000001 &amp;&amp; (x - 0.0) &gt; -0.000000001) return x; double res = 1.0; // 考虑为负的情况 if (n &lt; 0)&#123; x = 1 / x; // 考虑越界 if (n == INT_MIN)&#123; res *= x; n += 1; &#125; n = -n; &#125; while (n)&#123; // &amp; 和 移位运算替代取余和除法 if (n &amp; 1) res *= x; n &gt;&gt;= 1; x *= x; &#125; return res; &#125;&#125;; 372.Super Pow题目大意 计算$a^b$%1337, b非常大，用vector的形式给出。 思路 ab % k = (a % k)(b % k) % k f(a,b)表示$a^b$%k, 则f( f( a, b / 10), 10) * f(a, b % 10) % k，这样就转化为一个递归问题了 123456789101112131415161718192021class Solution &#123;public: int superPow(int a, vector&lt;int&gt;&amp; b) &#123; if (a == 0) return 0; if (b.empty()) return 1; int x = b.back(); b.pop_back(); return mypow(superPow(a, b), 10) * mypow(a, x) % base; &#125;private: const int base = 1337; int mypow(int a, int k)&#123; // 相当于拆分到每个底相乘，每个底都对base取模 a %= base; int res = 1; for (int i=0; i!=k; ++i)&#123; res = (res * a) % base; &#125; return res; &#125;&#125;; 约瑟夫环题目大意 0-n-1个人围成一个圈，从0喊到m-1，m-1的人被淘汰。然后从下一个人开始继续，请问最后活下来的是哪个人 思路 推导 f(n,m)表示n个小朋友，第m个人出局剩下的最后一个人;g(n-1, m)表示淘汰了f(n,m)中第m个人后按照规则剩下的那个人； f(n,m) = g(n-1,m) = (f(n-1, m) + m) % n 下标差了m 递推公式f(n,m) = (f(n-1, m) + m)% n 123456789101112class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; int last = 0; for (int i=2; i&lt;=n; ++i) last = (last + m ) % i; return last; &#125;&#125;; 382.Linked List Random Node题目大意 一个非常大的链表，随机返回链表上的一个节点值，要求O(n) 思路 蓄水池算法。 需要选取k个随机数 选择前k个数，对于第i个来的数，以$\frac{k}{k+i}$的概率是否选择该数，然后再以$\frac{1}{k}$的概率替换池子中的一个数 直到i到最后一个数，池子里的数就是随机出来的k个数 12345678910111213141516171819202122232425class Solution &#123;ListNode* root;public: /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution(ListNode* head) &#123; root = head; &#125; /** Returns a random node's value. */ int getRandom() &#123; if (root == NULL) return -1; ListNode* tmp = root; int res = tmp-&gt;val, count = 1; tmp = tmp-&gt;next; while (tmp)&#123; if (rand() % (1 + count++) == 0)&#123; res = tmp-&gt;val; &#125; tmp = tmp-&gt;next; &#125; return res; &#125;&#125;; 29. Divide Two Integers题目大意 给定两个整数，输出除的结果，要求不能使用加、减和取余操作 思路 整体思路是判断结果正负号，将负数变为整数，使用移位和减法操作实现除法。 溢出 因为负数要换成正数，所以针对出现负数的情况讨论溢出问题 除数较小时使用移位操作加速计算 除数左移时候也需要考虑是否会溢出的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int divide(int dividend, int divisor) &#123; // 几种可能越界的情况 if (dividend == INT_MIN &amp;&amp; divisor == INT_MIN) return 1; else if (divisor == INT_MIN) return 0; if (dividend == INT_MIN &amp;&amp; divisor == -1) return INT_MAX; if (dividend == INT_MIN &amp;&amp; divisor == 1) return INT_MIN; int is_minus = 0, res = 0, count = 1; if (divisor &lt; 0)&#123; divisor = -divisor; is_minus = ~is_minus; &#125; if (dividend &lt; 0)&#123; // 考虑被除数的越界问题 if (dividend == INT_MIN) &#123; dividend += divisor; res++; &#125; dividend = - dividend; is_minus = ~is_minus; &#125; while (dividend &gt; 0)&#123; int t = divisor; count = 1; // 使用移位加速计算 while (dividend &gt;&gt; 1 &gt; t)&#123; t = t &lt;&lt; 1; count = count &lt;&lt; 1; &#125; dividend -= t; res += count; &#125; // 不能整除 取整 if (dividend &lt; 0) res--; // 负数 返回负数 if (is_minus) return -res; // 整数 直接返回 else return res; &#125;&#125;; 两个数相除返回字符串形式题目大意 两个整数相除，返回字符串形式，循环小数用括号+循环位替代。 4 / 2 -&gt; 2 , 2 / 4 -&gt; 0.5 , 1 / 3 -&gt; 0.(3) 思路 整数部分直接除取整，小数部分乘10除取整，余数再循环。 1234567891011121314151617181920212223242526272829303132333435string divide2int(int a, int b)&#123; string res = ""; int zs, xs, last, count = 0; if (a == INT_MIN &amp;&amp; b == -1)&#123; res = to_string(INT_MAX); return res; &#125; // get zhengshu zs = a / b; res += to_string(zs); a = a - b * zs; if (a == 0) return res; // 需要计算小数部分 last = a; res += '.'; map&lt;int, int&gt; cache; string tmp = ""; while (a &amp;&amp; count &lt; 10)&#123; // 有循环小数 if (cache.find(a) != cache.end())&#123; tmp = string(tmp.begin(), tmp.begin()+cache[a]) + '(' + string(tmp.begin()+cache[a], tmp.end()) + ')'; break; &#125; cache[a] = count; xs = a * 10 / b; a = a * 10 % b; count++; tmp += to_string(xs); last = a; &#125; res += tmp; return res;&#125; Binary Search34.Search for a Range题目大意 给定一个升序数组和一个目标值，找到目标所在的区间，如果不存在就返回[-1,-1] 思路 二分搜索，改变=的位置即可找到上界和下界； 使用low&lt;=high的条件，low是左边的位置，high是右边的位置 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, -1); if (nums.empty()) return res; int low = binarySearch(nums, target, 1); if (low &gt;=0 &amp;&amp; low &lt; nums.size() &amp;&amp; nums[low] == target) res[0] = low; else res[0] = -1; int high = binarySearch(nums, target, 0); if (high &gt;= 0 &amp;&amp; high &lt; nums.size() &amp;&amp; nums[high] == target) res[1] = high; return res; &#125;private: int binarySearch(vector&lt;int&gt;&amp; nums, int target, int left)&#123; int low=0, high=nums.size()-1, mid=0; while (low &lt;= high)&#123; mid = low + (high - low) / 2; if ((left &amp;&amp; nums[mid] &gt;= target) || (!left &amp;&amp; nums[mid] &gt; target)) high = mid - 1; else low = mid + 1; &#125; // low是高一位的点，high是低一位的点 if (left) return low; else return high; &#125;&#125;; 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, -1); if (nums.empty()) return res; int low = 0, high = nums.size()-1, mid; while (low &lt; high)&#123; mid = low + (high - low) / 2; if (nums[mid] &gt;= target) high = mid; else low = mid + 1; &#125; if (nums[low] != target) return res; res[0] = low; while (low &lt; nums.size() &amp;&amp; nums[low] == target) low++; res[1] = low-1; return res; &#125;&#125;; 153.Find Minimum in Rotated Sorted Array154.Find Minimum in Rotated Sorted Array II题目大意 在一个没有重复数字的循环排序数组里，找到最小的数； 在一个有重复数字的循环排序数组里，找到最小的数； 思路 使用二分查找； 将mid和high位置比较； 如果是有重复数字，将high自减； 代码 12345678910111213141516class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int low = 0, high = nums.size() - 1, mid = 0; while (low &lt; high)&#123; // 正常情况下，查找会用=的条件，然后low指向恰好大的位置，high指向恰好小的位置； mid = low + (high - low) / 2; if (nums[mid] &lt; nums[high]) //不能和low比较，因为mid取值时是取整，可能会取到和low相同的值,此时比值只会相等， //但是却有两种情况[1,2]和[2,1]，无法区分 high = mid; //此处不能+1,可能mid处是最小值 else low = mid + 1; // low如果不加1的话最后不能收敛 &#125; return nums[high]; &#125;&#125;; 1234567891011121314151617class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int low = 0, high = nums.size()-1, mid = 0; // 内置类型在函数内部不会进行初始化 while (low &lt; high)&#123; mid = low + (high - low) / 2; if (nums[mid] &lt; nums[high]) high = mid; else if (nums[mid] &gt; nums[high]) low = mid + 1; else --high; &#125; return nums[high]; &#125;&#125;; 162.Find Peak Element题目大意 给定一个山峰数组，即先升序后降序。求数组的山峰。 思路 二分 nums[mid] &lt; nums[mid+1] : low = mid + 1 (因为循环条件是low&lt;high，所以只有low==high时mid才会越界，此时已经跳出循环了) nums[mid] &gt; nums[mid+1] : high = mid 12345678910111213141516class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; // nums.push_back(INT_MIN); int low =0, high = nums.size()-1, mid; while (low &lt; high)&#123; mid = low + (high - low) / 2; // 只有low和high相等时才会出现mid=high的情况，此时已经跳出循环 if (nums[mid] &lt; nums[mid+1]) low = mid + 1; else high = mid; &#125; return low; &#125;&#125;; 33.Search in Rotated Sorted Array81.Search in Rotated Sorted Array II题目大意 在一个循环排序数组中，查找是否存在某个数。 思路 二分 nums[low] &lt;= nums[mid] 此时 low到mid是递增区间 如果 nums[low] &lt;= target &lt; nums[mid] : high = mid - 1 low = mid + 1 （此时，target位于mid+1和high之间） nums[low] &gt; nums[mid] 此时 mid到high是递增区间 如果 nums[mid] &lt; target &lt;= nums[high] : low = mid + 1 high = mid - 1; 如果有重复的数，导致 nums[mid] == nums[low] == nums[high] 无法判断，则low++ high— 继续循环 12345678910111213141516171819202122232425class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return -1; int low=0, high=nums.size()-1, mid; while (low &lt;= high)&#123; mid = low + (high - low) / 2; if (nums[mid] == target) return mid; // 在没有重复情况下，nums[mid]==nums[low]意味着收敛到low和mid之间了，不应该再去mid和high之间了 if (nums[mid] &gt;= nums[low])&#123; // 考虑target和边界相等的情况，此时target就是落在这个区间内 if (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) high = mid - 1; else low = mid + 1; &#125;else&#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) low = mid + 1; else high = mid - 1; &#125; &#125; return -1; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return false; int low=0, high=nums.size()-1, mid; while(low &lt;= high)&#123; mid = low + (high - low) / 1; if (nums[mid] == target) return true; if (nums[mid] == nums[low] &amp;&amp; nums[mid] == nums[high]) &#123; low++; high--; &#125; else if (nums[low] &lt;= nums[mid])&#123; if (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) high = mid - 1; else low = mid + 1; &#125;else&#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) low = mid + 1; else high = mid - 1; &#125; &#125; return false; &#125;&#125;; Bit Operation136.Single Number题目大意 给定一个数组，只有一个数出现一次，其他都出现两次，返回只出现一次的数 思路 异或 相同的数异或为0，最后只剩下单独的数 12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for (int i=0; i!=nums.size(); ++i)&#123; res ^= nums[i]; &#125; return res; &#125;&#125;; 137.Single Number II题目大意 给定一个数组，只有一个数出现一次，其他都出现三次，返回出现一次的数 思路 对每一位进行计数，只需要 00、01和10即可，循环为00-01-10-00 对于出现三次的位一定会被消除，所以，最后剩下的就是只出现一次的数 只有三种情况，只需要ones和twos两位即可满足计数要求 更新规则 ones ^ nums[i]，当nums[i]是1时，ones需要更新，此时，如果twos == 1，ones更新为0(10-00)，否则ones更新为1(00-01) twos ^ nums[i]，当nums[i]是1时，twos需要更新，此时，如果ones == 0，twos变为1，否则不变 对于出现次数是5的情况同样处理 1234567891011class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ones = 0, twos = 0; for (int i=0; i!=nums.size(); ++i)&#123; ones = ones^nums[i] &amp; ~twos; twos = twos^nums[i] &amp; ~ones; &#125; return ones; &#125;&#125;; 1234567891011121314class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int tmp=0, res=0; for (int i=0; i!=32; ++i)&#123; tmp = 0; for (auto num:nums)&#123; tmp += (num &gt;&gt; i) &amp; 1; &#125; res |= (tmp % 3) &lt;&lt; i; &#125; return res; &#125;&#125;; 260.Single Number III题目大意 给定一个数组，有两个数字出现次数是1次，其他数字均出现两次，求出现1次的两个数 思路 先异或，找到两个出现次数为1的数字的不同的位 找到两个数字某个不同的位(diff &amp; ~(diff - 1)) 根据这个位将原数组分为两部分，必然两个数会分开 两个数组分别异或，找到两个出现1次的数 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int diff = 0; vector&lt;int&gt; res(2, 0); for (int i=0; i!=nums.size(); ++i) diff ^= nums[i]; diff &amp;= ~(diff-1); for (int i=0; i!=nums.size(); ++i)&#123; if (nums[i] &amp; diff) res[0] ^= nums[i]; else res[1] ^= nums[i]; &#125; return res; &#125;&#125;; string151.Reverse Words in a String题目大意 给定一个包含词的字符串，将词顺序翻转 思路 三个指针i，j，l。i是头指针，j是要将nums[i]移动到的位置，l是上一次的位置，翻转的时候要用 首先要去除多余的空格 如果前面有word需要加空格 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void reverseWords(string &amp;s) &#123; int i=0, j=0, l=0, n=s.size(); int count=0; while (i&lt;n)&#123; while (i&lt;n &amp;&amp; s[i]==' ') i++; if (i==n) break; if (count) s[j++] = ' '; l = j; while (i&lt;n &amp;&amp; s[i]!=' ')&#123; s[j++] = s[i++]; &#125; reverse_str(s, l, j-1); count++; &#125; s.resize(j); reverse_str(s, 0, j-1); &#125;private: void reverse_str(string &amp;s, int i, int j)&#123; if (i&lt;0 || i &gt;= s.size() || j&lt;0 || j &gt;=s.size()) return; while (i &lt; j)&#123; char t = s[i]; s[i++] = s[j]; s[j--] = t; &#125; &#125;&#125;; 左旋转字符串题目大意 给定一个字符串和n，将字符串前n位左移。如给定abcde和2，则返回cdeab 思路 可以理解为，前n个字符是一个单词，后面的字符为另一个单词，相当于翻转单词的问题 12345678910111213141516171819class Solution &#123;public: string LeftRotateString(string str, int n) &#123; if (str.size()&gt;0 &amp;&amp; n&gt;0 &amp;&amp; n&lt;str.size())&#123; reverseString(str, 0, n-1); reverseString(str, n, str.size()-1); reverseString(str, 0, str.size()-1); &#125; return str; &#125;private: void reverseString(string &amp;input, int left, int right)&#123; while (left&lt;right)&#123; char tmp = input[left]; input[left++] = input[right]; input[right--] = tmp; &#125; &#125;&#125;; DP最长公共子序列题目大意 给定两个字符串，找到最长公共子序列。子序列的不一定需要是连续的 思路 动态规划，dp[i][j]记录s前i个字符串和t前j个字符串的最长公共子序列； dp[i][j]=dp[i-1][j-1] if(A[i-1]==B[j-1]) dp[i][j]=max(dp[i-1][j], dp[i][j-1]) if (A[i-1] != B[j-1]) 123456789101112131415161718192021222324class Solution &#123;public: /** * @param A: A string * @param B: A string * @return: The length of longest common subsequence of A and B */ int longestCommonSubsequence(string &amp;A, string &amp;B) &#123; // write your code here int m = A.size(), n = B.size(); vector&lt;vector&lt;int&gt; &gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for (int i=1; i&lt;=m; ++i)&#123; for (int j=1; j&lt;=n; ++j)&#123; // 注意下标和dp下标区别 if (A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; return dp[m][n]; &#125;&#125;; 最长公共子串题目大意 给定两个字符串s和t，求s和t的最大公共子串的长度。 思路 同上使用动态规划，dp[i][j]记录s前i个字符串和t前j个字符串的最长公共子串； dp[i][j]=dp[i-1][j-1] if(A[i-1]==B[j-1]) dp[i][j]=0 if (A[i-1] != B[j-1]) 同时，使用res记录全程最大的子串。 1234567891011121314151617181920212223class Solution &#123;public: /** * @param A: A string * @param B: A string * @return: the length of the longest common substring. */ int longestCommonSubstring(string &amp;A, string &amp;B) &#123; // write your code here int m = A.size(), n = B.size(), res = 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for (int i=1; i&lt;=m; ++i)&#123; for (int j=1; j&lt;=n; ++j)&#123; if (A[i-1] == B[j-1])&#123; dp[i][j] = dp[i-1][j-1] + 1; res = max(res, dp[i][j]); &#125; &#125; &#125; return res; &#125;&#125;; 322.Coin Change题目大意 给定一些钱币面值和总钱数，求能够凑出总钱数的最小钱币数。 思路 动态规划，dp[count] = min(dp[count-1], dp[count-2]…) + 1 1234567891011121314151617181920class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1, -1); dp[0] = 0; int coins_len = coins.size(), cur = INT_MAX, last; for (int i=1; i&lt;=amount; ++i)&#123; int tmp = INT_MAX; for (int j=0; j!=coins_len; ++j)&#123; last = i - coins[j]; if (last &gt;= 0 &amp;&amp; dp[last] &gt; -1)&#123; tmp = min(tmp, dp[last]); &#125; &#125; if (tmp != INT_MAX) dp[i] = tmp + 1; &#125; return dp[amount]; &#125;&#125;; 62.Unique Paths题目大意 给定一个m n的矩阵，求左上角到达右下角的路径数量有多少 思路 动态规划，dp[i][j] = dp[i-1][j] + dp[i][j-1] 123456789101112131415class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); for (int i=0; i!=m; ++i) dp[i][0] = 1; for (int j=0; j!=n; ++j) dp[0][j] = 1; for (int i=1; i!=m; ++i)&#123; for (int j=1; j!=n; ++j) dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; return dp[m-1][n-1]; &#125;&#125;; 416.Partition Equal Subset Sum题目大意 给定一个(非空、正数)数组，判断是否能将数组分为两个部分，两个部分和相等。 思路 使用动态规划，数组和为sum，则dp[i]记录是否有一部分元素和为i，返回dp[sum/2]即可。(如果数组有负数，那么dp数组就没有范围限制了) dp[0] = true, 如果dp[i-num[k]]为true，则dp[i] = true 123456789101112131415161718class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum &amp; 1) return false; sum = sum &gt;&gt; 1; vector&lt;bool&gt; dp(sum+1, false); dp[0] = true; for (int i=0; i!=nums.size(); ++i)&#123; // 必须从sum开始，否则会nums[i]会被重复使用，比如2、4、6。。。 for (int j=sum; j&gt;0; --j)&#123; if (j-nums[i] &gt;=0 &amp;&amp; dp[j-nums[i]]) dp[j] = true; &#125; &#125; return dp[sum]; &#125;&#125;; 698.Partition to K Equal Sum Subsets题目大意 给定一个数组，判断是否能分成和相等的k部分。 思路 使用dfs，先找到一组元素使得和为sum/k，然后再递归剩下的元素是否能分为k-1组，递归结束条件为k==1(存在k-1组和为sum / k的数组那么剩下的一组必然为sum / k) 123456789101112131415161718192021222324class Solution &#123;public: bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % k) return false; sum = sum / k; vector&lt;int&gt; visited(nums.size(), 0); return dfs(nums, visited, 0, 0, k, sum); &#125;private: bool dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; visited, int start, int sum, int k, int target)&#123; if (k==1) return true; // 新的part，从头开始考虑 if (sum == target) return dfs(nums, visited, 0, 0, k-1, target); // 找到和为target的数组，如果前面的不可以，则后面不需要再考虑这些数了 for (int i=start; i&lt;nums.size(); ++i)&#123; if (visited[i]) continue; visited[i] = 1; if (dfs(nums, visited, i+1, sum+nums[i], k, target)) return true; visited[i] = 0; &#125; return false; &#125;&#125;; 5.Longest Palindromic Substring题目大意 求字符串的最长回文字符串。 思路 动态规划 暴力法：遍历所有子串，判断是否为回文子串。在判断子串是否为回文子串过程中，有很多重复的判断，此处可以用动态规划 dp[i][j]表示i到j是否为回文串，此时dp[i][j]可以通过dp[i+1][j-1]和判断s[i] == s[j]来计算 提前计算dp[i][i]和dp[i][i+1]位置的对称性 奇数和偶数回文串两种情况 在此过程中，记录最长的回文串的开始位置和长度 Manacher算法 https://articles.leetcode.com/longest-palindromic-substring-part-ii/ 将字符串aaxsd变成^#a#a#x#s#d#$，#的目的是将奇数长度和偶数长度的回文字符串都变成奇数长度的回文字符串，^和$是为了防止越界问题。 使用p[i] 记录i位置回文串的单边长度，在计算过程中，可以利用对称性简化计算 中心位置是c，对称半径是r 如果i位于半径r内，可以通过对称位置计算 如果对称位置的回文长度没有超过r-i那么p[i] = p[mirror_i] 如果超过了，则p[i] = r-c，同时从r位置继续判断是否为回文串 如果在半径外，直接计算 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; int max_len = 1, start=0; int n=s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, (vector&lt;int&gt;(n))); for (int i=0; i!=n; ++i)&#123; dp[i][i] = 1; if (i+1&lt;n &amp;&amp; s[i]==s[i+1])&#123; dp[i][i+1] = 1; if (max_len &lt; 2)&#123; start = i; max_len = 2; &#125; &#125; &#125; for (int i=n-2; i&gt;=0; --i)&#123; for (int j=i+2; j&lt;n; ++j)&#123; if (dp[i+1][j-1] &amp;&amp; s[i]==s[j])&#123; dp[i][j] = 1; if (j - i &gt;= max_len)&#123; start = i; max_len = j - i + 1; &#125; &#125; &#125; &#125; return s.substr(start, max_len); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; string t = preprocess(s); int len = t.size(); vector&lt;int&gt; p(len); int c = 0, r = 0; for (int i=0; i!=len; ++i)&#123; int mirror = 2 * c - i; p[i] = r &gt; i ? min(r-i, p[mirror]) : 0; while (t[i+1+p[i]] == t[i-1-p[i]]) p[i]++; if (p[i] + i &gt; r)&#123; c = i; r = p[i] + i; &#125; &#125; int max_pos=0, max_len=0; for (int i=0; i!=len; ++i)&#123; if (max_len &lt; p[i])&#123; max_len = p[i]; max_pos = i; &#125; &#125; return s.substr((max_pos-1-max_len)/2, max_len); &#125;private: string preprocess(string s)&#123; string res = "@"; for (int i=0; i!=s.size(); ++i)&#123; res += "#"; res += s[i]; &#125; res += "#$"; return res; &#125;&#125;; 300.Longest Increasing Subsequence题目大意 给定一个数组，找到最长的递增子序列。 思路 动态规划，$O(n^2)$时间复杂度，$O(n)$空间复杂度 dp[i]表示前 i 个数的最长递增子序列 每次更新时，遍历0到 i-1的数，如果比nums[j]大，则可以构成新的递增子序列，序列长度为dp[j]+1，将最大值作为dp[i] 遍历过程中记录最大值 $O(nlogn)$时间复杂度，$O(n)$空间复杂度 遍历过程中维护一个S数组，数组维护的是各个长度LIS的最小尾部 遍历数组，找到S中不小于nums[i]的最小值， 如果找到了，则替换该值， 如果比S中最大值还大，直接append即可 最后，S的长度就是最长递增子序列的长度 12345678910111213141516171819class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int n = nums.size(), len, max_len=1; vector&lt;int&gt; dp(n, 1); for (int i=1; i&lt;n; ++i)&#123; len = 0; for (int j=0; j&lt;i; ++j)&#123; if (nums[i] &gt; nums[j])&#123; len = max(len, dp[j]); &#125; &#125; dp[i] = len + 1; max_len = max(dp[i], max_len); &#125; return max_len; &#125;&#125;; 12345678910111213141516// nlognclass Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; vector&lt;int&gt;::iterator it = nums.begin(), tmp; for (int i=0; i!=nums.size(); ++i)&#123; tmp = lower_bound(nums.begin(), it, nums[i]); *tmp = nums[i]; if (tmp == it)&#123; it++; &#125; &#125; return it - nums.begin(); &#125;&#125;; 674. Longest Continuous Increasing Subsequence题目大意 给定一个数组，找到最长的连续升序序列 思路 遍历，因为是连续序列，所以尽可能记录升序序列的长度，如果断了就重新计数，在此过程中记录最大值即可 123456789101112131415class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int max_len=1, len=1, n = nums.size(); for (int i=0; i&lt;n-1; ++i)&#123; if (nums[i] &lt; nums[i+1]) len++; else len = 1; max_len = max(max_len, len); &#125; return max_len; &#125;&#125;; 198.House Robber题目大意 给定一个正数数组，要求相邻的数不能同时取得，问选取的数和最大是多少。 思路 dp[i] = max(dp[i-1], dp[i-2]+nums[i])动态规划值 只需要用a、b两个数，存储奇数和偶数位置的最大结果 a = max(a+nums[i], b) &amp;&amp; b = max(b+nums[i], b) 1234567891011121314class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int a = 0, b = 0; for (int i=0; i!=nums.size(); ++i)&#123; if (i%2)&#123; a = max(b, a+nums[i]); &#125;else&#123; b = max(a, b+nums[i]); &#125; &#125; return max(a, b); &#125;&#125;; 123456789101112131415161718class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int n = nums.size(); vector&lt;int&gt; dp(n+1); dp[1] = nums[0]; for (int i=2; i&lt;=n; ++i)&#123; if (i-1&gt;=0)&#123; dp[i] = max(dp[i], dp[i-1]); &#125; if (i-2&gt;=0)&#123; dp[i] = max(dp[i], dp[i-2]+nums[i-1]); &#125; &#125; return dp[n]; &#125;&#125;; 213. House Robber II题目大意 给定一个正数数组，要求相邻的数以及首尾的数不能同时取得，问选取的数和最大是多少。 思路 乍看上去，首尾的情况不太好处理。如果分两次遍历，一次掐头，一次 去尾。取两次的最大值即可。 12345678910111213141516171819202122class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int n = nums.size(); // 对于数组长度为1的情况后面的函数无法处理，需要简单处理下边界 if (n == 1) return nums[0]; return max(find(nums, 0, n-1), find(nums, 1, n)); &#125;private: int find(vector&lt;int&gt;&amp; nums, int s, int e)&#123; int a = 0, b = 0; for (int i=s; i&lt;e; ++i)&#123; if (i%2)&#123; a = max(a+nums[i], b); &#125;else&#123; b = max(b+nums[i], a); &#125; &#125; return max(a, b); &#125;&#125;; 337. House Robber III题目大意 小区的布局变成了二叉树的形式，父亲和孩子不能同时被偷。问最多能偷多少。 思路 思路略微不同，每个位置有被偷或者不被偷两种情况，存储两种情况的最大收获值(上面两题都是存储存在i个位置，能够偷的最大收获是多少)。res[0] = left[1] + right[1] + root-&gt;val和res[1] = max(left[0], left[1]) + max(right[0], right[1]) 1234567891011121314151617class Solution &#123;public: int rob(TreeNode* root) &#123; pair&lt;int, int&gt; res = dfs(root); return max(res.first, res.second); &#125;private: pair&lt;int, int&gt; dfs(TreeNode* root)&#123; if (root==NULL) return make_pair(0, 0); pair&lt;int, int&gt; res; pair&lt;int, int&gt; left = dfs(root-&gt;left); pair&lt;int, int&gt; right = dfs(root-&gt;right); res.first = left.second + right.second + root-&gt;val; res.second = max(left.first, left.second) + max(right.first, right.second); return res; &#125;&#125;; 121. Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: 1234Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) 题目大意 给定一个数组，下标为i的数表示股票在第i天的价格。如果最多只能操作一次（买、卖一次），请问最多能挣多少钱。 思路 从头到尾遍历，dp[i-1][0]为前 i-1 天的最低价位，如果第i天价位不高于dp[i-1][0], 则dp[i][0] = prices[i]； 否则，计算出第i天卖出的最大利润 profit=prices[i] - dp[i-1][0]，前i天能达到的最大利润为dp[i][1] = max(profit, dp[i-1][1])。 其实因为这个情况很简单，所以可以考虑不用数组去做，只需要一个记录之前的股票最小值，以及之前的利润最大值即可。 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int res=0, last=prices[0]; for (int i=0; i&lt;prices.size(); ++i)&#123; if (last &lt; prices[i])&#123; res = max(res, prices[i] - last); &#125;else&#123; last = prices[i]; &#125; &#125; return res; &#125;&#125;; 122. Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目大意 可以完成尽可能多次的交易，请问最大获益是多少。 思路 这种情况很简单，用贪心去做，只要能赚钱我就交易即可。 即，只要上一天的价格低于当天的价格，就在上一天买入在当天卖出。 两种情况： 若第三天的价格高于当天价格，那么在今天买入第三天卖出，效果和贪心是一样的； 若第三天价格低于当天价格，那么就应该在当天卖出；所以应该用贪心的思路做。 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int res=0, last=prices[0]; for (int i=0; i&lt;prices.size(); ++i)&#123; if (last &lt; prices[i])&#123; res += prices[i]-last; last = prices[i]; &#125;else&#123; last = prices[i]; &#125; &#125; return res; &#125;&#125;; 123. Best Time to Buy and Sell Stock III题目大意 只能完成两次交易，那么最大收益是多少。 思路 第一种思路： 想了很久，画了一条曲线，其实两次交易相当于在中间找到一个局部最高点，在这个最高点后面又找到一个局部最低点，而我们可以去遍历所有的数，将每个数作为最高点（前一次卖出）和最低点（后一次买入）的分割点，在遍历的过程中记录收益的最大值即可。 思路很简单，分割以后，分别用题I的解法去做就可以了。但是，此时会重复遍历很多次，第i天为分割点，为了找到第一次交易的最大收益，需要遍历前i天，而这前i天中有i-1天是上一次已经遍历过的了，所以这种方法会超时。 第二种思路： 如上面的分析，这种重复的情况可以用一个dp数组去存储第i天为分割点时，前i天的股票最大收益和后n-i+1天的最大收益，这样就不需要进行重复计算了，时间效率大大提高。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(), res=0; vector&lt;int&gt; left_dp(n), right_dp(n), left_max(n), right_max(n); // 从前往后遍历第一次卖得位置 for (int i=0; i&lt;n; ++i)&#123; if (i&gt;0 &amp;&amp; left_dp[i-1] &lt; prices[i])&#123; left_max[i] = max(left_max[i-1], prices[i]-left_dp[i-1]); left_dp[i] = left_dp[i-1]; &#125;else&#123; if (i&gt;0) left_max[i] = left_max[i-1]; left_dp[i] = prices[i]; &#125; &#125; // 从后往前遍历第二次买的位置 for (int i=n-1; i&gt;=0; --i)&#123; if (i&lt;n-1 &amp;&amp; right_dp[i+1] &gt; prices[i])&#123; right_max[i] = max(right_max[i+1], right_dp[i+1] - prices[i]); right_dp[i] = right_dp[i+1]; &#125;else&#123; if (i&lt;n-1) right_max[i] = right_max[i+1]; right_dp[i] = prices[i]; &#125; &#125; // 根据第一次卖得位置和第二次买的位置求得最佳的分割点 for (int i=0; i!=n; ++i)&#123; res = max(res, left_max[i]+right_max[i]); &#125; return res; &#125;&#125;; 188. Best Time to Buy and Sell Stock IV题目大意 最多k次交易，请问最大收益是多少。 思路 不会做。参考大神的思路，使用循环引用的动态规划。 must_sell[i][k] 表示 第i天必须卖出且至多交易k次的最大收益。global_max[i][k] 表示 截止到第i天至多交易k次的最大收益。 状态转移方程： must_sell[i][k] = max(global_max[i-1][k-1] + profit, must_sell[i-1][k] + profit) (第i天卖出且至多交易k次的最大收益为：前i-1天至多交易k-1次的最大收益 和 第i-1天必须卖出至多交易k次的最大收益 的较大值 加上第i天卖出的收益。） global_max[i][k] = max(global_max[i-1][k], must_sell[i][k]) (前i天至多交易k次的最大收益为：前i-1天至多交易k次的最大收益 和 第i天必须卖出至多交易k次的最大收益 的较大者。) 123456789101112131415161718192021222324252627282930class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(), res=0; if (n == 0 || k == 0) return 0; // 当可以交易的次数足够多 if (k &gt; n / 2)&#123; for (int i=1; i!=n; ++i)&#123; if (prices[i-1] &lt; prices[i])&#123; res+= prices[i] - prices[i-1]; &#125; &#125; return res; &#125; // must_sell[i][k] 必须卖出prices[i]且交易次数最多是k的 最大收益 vector&lt;vector&lt;int&gt;&gt; must_sell(n, vector&lt;int&gt;(k+1)); // global_sell[i][k] 进行到prices[i](不一定卖出)且交易次数最多是k的 最大收益 vector&lt;vector&lt;int&gt;&gt; global_sell(n, vector&lt;int&gt;(k+1)); for (int i=1; i&lt;n; ++i)&#123; int profit = prices[i] - prices[i-1]; for (int kk=1; kk&lt;k+1; ++kk)&#123; must_sell[i][kk] = max(global_sell[i-1][kk-1] + profit, must_sell[i-1][kk] + profit); global_sell[i][kk] = max(global_sell[i-1][kk], must_sell[i][kk]); &#125; &#125; return global_sell[n-1][k]; &#125;&#125;;c 72. Edit Distance题目大意 计算两个字符串之间的编辑距离。word1通过删除、插入和替换三种操作变为word2，操作需要的次数即为编辑距离。 思路 动态规划 if str[i-1]==str[j-1]: dp[i][j] = dp[i-1][j-1] if str[i-1]!=str[j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 123456789101112131415161718192021class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(), n = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1)); for (int i=0; i&lt;=m; ++i) dp[i][0] = i; for (int i=0; i&lt;=n; ++i) dp[0][i] = i; for (int i=1; i&lt;=m; ++i)&#123; for (int j=1; j&lt;=n; ++j)&#123; if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else&#123; dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Approaches to Attention-based Neural Machine Translation]]></title>
    <url>%2F2018%2F04%2F22%2Fluong-attention%2F</url>
    <content type="text"><![CDATA[Effective Approaches to Attention-based Neural Machine Translation 总体介绍这篇文章不得不说写的非常好，写的结构清晰，逻辑清楚，内容讲得也非常通俗易懂。总体来说，这篇文章在神经机器翻译的基础上提出了两种attention的结构，attention的机制可以保障在翻译时每个字词的输出是和输入是对齐的（我的理解就是和源输入是保持一致的）。一种是global attention，一种是local attention。global指的是对齐时会考虑到所有的输入序列，而local则会只考虑部分输入序列。文章还提出了一些训练数据的trick，比如input-feeding approach，文章最后给出了自己做的各种实验的结果，进行了比对，对两种attention机制以及对齐方式进行了实验，local一般来说会有较为出色的结果。 Two Attention Architecture Attention-based Models 传统的RNN ecoder-decoder模型中，decoder时最上层的rnn单元会直接输出$h_t​$，根据$h_t​$再接一层网络，形成最终的输出$y_t​$。这种传统的模型，在每个time step输出结果时，没有考虑到整个输入序列的情况，仅仅依赖encoder的最后一个hidden state，而对于比较长的句子，则可能不能完全代表整体的语义； attention机制会根据当前time step的hidden state $h_t$，再跟encoder的outputs进行词对齐，生成context vector $c_t$，最后的输出$y_t$由$c_t$和$h_t$组成。 \mathop{h_t}\limits^- = tanh(W_c[c_t;h_t]) 总体来说，attention model的特点就是最后的输出$y_t$不仅仅由$h_t$决定，还需要考虑context vector $c_t$。而$c_t$的不同生成方式就构成了不同的attention architecture。 global attention global attention模型下$c_t$会参考所有的encoder hidden states alignment vector $\alpha_t$ \alpha_t(s) = align(h_t, \mathop{h_s}\limits^-) = \frac{exp(score(h_t, \mathop{h_s}\limits^-))}{\sum_{s^*}(score(h_t, \mathop{h_{s^*}}\limits^-))} score function $h_t^T \mathop{h_s}\limits^-$—- dot $h_t^TW_a \mathop{h_s}\limits^-$ —- general $v_atanh(W_a[h_t; \mathop{h_s}\limits^-])$ —— concat $\alpha_t = softmax(W_ah_t)$ 作者最开始使用的score function，仅仅使用了target hidden state去计算 和Bahdanau提出的模型的比较（更多的是简化和泛化） hidden state的使用 本文encoder和decoder部分只使用了最顶层的LSTM单元的hidden state Bah文中猜测encoder用的是双向LSTM，对forward和backward的hidden state进行了拼接，猜测decoder部分是单层单向LSTM，没有对state进行拼接。 计算路径（是否可以理解为context vector的计算） $h_t - &gt; \alpha_t - &gt; c_t - &gt;\mathop{h_t}\limits^-$ 本文的计算路径 $h_{t-1} - &gt; \alpha_t - &gt; c_t - &gt; h_t$ 从前一个hidden state开始计算，计算量会更大（具体怎么计算的需要参考Bah原始论文） 具体不同 luong和Bahdanau不同 luong使用了encoder和decoder部分的hidden_state计算context；而Bah只使用了encoder部分的hidden_state，将forward和backward的hidden_state concat 计算context的不同 luong直接使用decoder的hidden_state和encoder部分hidden_state计算context，和decoder的hidden_state进行concat过一层网络输出 Bah使用t-1时刻的decoder的hidden_state和concat的state计算context(这个地方有个疑问，到底用不用到decoder的hidden_state计算context)，然后和t-1时刻的decoder的hidden_state进行concat输入到t时刻 context的分数计算方式 luong有三种 Bah只会concat local attention global的缺点很明显，在生成每一个$y_t$的时候需要考虑到所有的input words，这种计算是非常expensive的，而且对于长句子的处理来说非常不友好。 灵感来自于图片描述生成任务 soft attention：会考虑图片中所有的patches hard attention：只会考虑图片中的一个patch；需要降维和增强学习等技术来辅助训练 每次生成context vector时，会选取一个窗口，用窗口内的encoder hidden states来计算 $c_t$。具体的，每次计算时，需要选取一个 $p_t$，这个是窗口的中心，那么窗口就是[p_t-D, p_t+D]，D一般由经验指定；然后就可以根据前面提出的计算context vector的方式进行计算。针对 $p_t$ 生成规则不同，又分为两种模型 Monotonic alignment 单调对齐：即简单地设置$p_t = t$ predictive alignment 预测对齐 $p_t$由模型预测得出 p_t= S\cdot sigmod(v_p^Ttanh(W_ph_t)) S为encoder max-time，因为sigmod $\in[0,1]$，所以可以得出某个位置 \alpha_t = align(h_t, \mathop{h_s}\limits^-)exp(-\frac{ {s-p_t}^2}{2\sigma^2}) alignment weights 生成时引入了高斯分布，令 $\sigma = \frac{D}{2}$ 与Gregor的selective attention机制（用于image generation task）非常像，但是该模型选择图片patch时会同时有变化的position和zoom，而本文使用的是相同的zoom(D) Trick input-feeding approach 每次字词生成的时候需要知道之前的生成情况，传统的机器翻译模型会在生成当前词的时候考虑到那些词汇已经被翻译过。 本文将上一次的attention与当前的input进行concat，然后再进行输入达到了考虑之前情况的效果。 Experiment 模型使用的technology reverse 猜测是双向LSTM dropout global attention local-p attention feed input unk replace 结论 dot function 在global attention中使用会取得较好的效果 general function在local attention中会取得比较好的效果 总的来说，使用predictive position的local attention效果是最好的 对于alignment quality，可以使用AER（alignment error rate）来衡量，发现local attention model的AER会更低一些。 应用可以应用到自己翻译模型中的点 看一下tf中luong attention是实现的哪一种方式，可以考虑尝试local attention unk word的处理 一些参数的调节，包括字典词数的选择 bucket的选择batch的方式]]></content>
      <categories>
        <category>paper_reading</category>
      </categories>
      <tags>
        <tag>机器翻译</tag>
      </tags>
  </entry>
</search>
