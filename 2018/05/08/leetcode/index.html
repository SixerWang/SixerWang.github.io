<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="leetcode,算法," />










<meta name="description" content="LinkedList链表翻转、两个链表代表的数求和（两种形式）、找到链表的倒数第k个节点（删除链表的倒数第k个节点） 445. Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes firs">
<meta name="keywords" content="leetcode,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode">
<meta property="og:url" content="http://yoursite.com/2018/05/08/leetcode/index.html">
<meta property="og:site_name" content="Dannyw&#39;s Blog">
<meta property="og:description" content="LinkedList链表翻转、两个链表代表的数求和（两种形式）、找到链表的倒数第k个节点（删除链表的倒数第k个节点） 445. Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes firs">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-06-02T08:08:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode">
<meta name="twitter:description" content="LinkedList链表翻转、两个链表代表的数求和（两种形式）、找到链表的倒数第k个节点（删除链表的倒数第k个节点） 445. Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes firs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/08/leetcode/"/>





  <title>leetcode | Dannyw's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7ac99c57df069649fcb7486c78be2b32";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dannyw's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-类别">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            类别
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/08/leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dannyw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://owxv9mpb2.bkt.clouddn.com/cyh.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dannyw's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-08T23:46:36+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法题/" itemprop="url" rel="index">
                    <span itemprop="name">算法题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/05/08/leetcode/" class="leancloud_visitors" data-flag-title="leetcode">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>链表翻转、两个链表代表的数求和（两种形式）、找到链表的倒数第k个节点（删除链表的倒数第k个节点）</p>
<h2 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="445. Add Two Numbers II"></a><a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">445. Add Two Numbers II</a></h2><p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Follow up:</strong></p>
<p>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>
<p><strong>题目大意</strong></p>
<p>给定两个非空的链表，链表的每个节点代表非负整数的一位，链表的靠前的位置代表着高位。返回两个链表所代表的数相加的结果，结果以链表形式返回。</p>
<p>如果不能改变输入的链表即不能翻转链表该如何操作。</p>
<p><strong>思路</strong></p>
<ol>
<li>翻转链表，按顺序加起来，然后构造链表即可；(但是题目要求不允许改变链表)；</li>
<li>空间换时间，遍历两个链表用数组存起来，使用数组相加，同时生成结果链表，生成结果链表的时候可以逆序直接生成结果链表；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1, vec2, vec3;</span><br><span class="line">		ListNode *res = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			vec1.push_back(l1-&gt;val);</span><br><span class="line">			l1 = l1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			vec2.push_back(l2-&gt;val);</span><br><span class="line">			l2 = l2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> len1 = vec1.size(), len2 = vec2.size(), c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=len1<span class="number">-1</span>, j=len2<span class="number">-1</span>; i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || c &gt; <span class="number">0</span>; --i, --j)&#123;</span><br><span class="line">			<span class="keyword">int</span> sum = c;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) sum += vec1[i];</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= <span class="number">0</span>) sum += vec2[j];</span><br><span class="line">			c = sum / <span class="number">10</span>;</span><br><span class="line">			p = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">			p-&gt;next = res;</span><br><span class="line">			res = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>翻转链表，熟悉下链表翻转</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverse the linked list</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">		ListNode *l1_r = reverse(l1);</span><br><span class="line">		ListNode *l2_r = reverse(l2);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">		ListNode *res = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> ((l1_r!=<span class="literal">NULL</span>) || (l2_r!=<span class="literal">NULL</span>) || c&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> sum = c;</span><br><span class="line">			<span class="keyword">if</span> (l1_r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				sum += l1_r-&gt;val;</span><br><span class="line">				l1_r = l1_r-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (l2_r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				sum += l2_r-&gt;val;</span><br><span class="line">				l2_r = l2_r-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			c = sum / <span class="number">10</span>;</span><br><span class="line">			p = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">			p-&gt;next = res;</span><br><span class="line">			res = p;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* node)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">NULL</span> || node-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> node;</span><br><span class="line">		ListNode *p = <span class="literal">NULL</span>, *q = node;</span><br><span class="line">		<span class="keyword">while</span> (q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			ListNode *tmp = q-&gt;next;</span><br><span class="line">			q-&gt;next = p;</span><br><span class="line">			p = q;</span><br><span class="line">			q = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a><a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">2.Add Two Numbers</a></h2><p><strong>题目大意</strong></p>
<p>用一个链表给出一个非负数，链表的头是数的低位，尾部是高位，求两个链表所代表数的和的链表形式。</p>
<p><strong>思路</strong></p>
<p>比445简单多了，直接遍历链表相加，返回即可。</p>
<p>考虑</p>
<ol>
<li>如果是有符号数，得考虑大小再做减法</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head, *p, *q;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry)&#123;</span><br><span class="line">            sum =carry;</span><br><span class="line">            <span class="keyword">if</span> (l1)&#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2)&#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (!head-&gt;next || !head-&gt;next-&gt;next)</span></span><br><span class="line"><span class="comment">            return head-&gt;next;</span></span><br><span class="line"><span class="comment">        p = NULL;</span></span><br><span class="line"><span class="comment">        q = head-&gt;next;</span></span><br><span class="line"><span class="comment">        delete head;</span></span><br><span class="line"><span class="comment">        while (q)&#123;</span></span><br><span class="line"><span class="comment">            ListNode* tmp = q-&gt;next;</span></span><br><span class="line"><span class="comment">            q-&gt;next = p;</span></span><br><span class="line"><span class="comment">            p = q;</span></span><br><span class="line"><span class="comment">            q = tmp;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return p;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19.Remove Nth Node From End of List"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">19.Remove Nth Node From End of List</a></h2><p><strong>题目大意</strong></p>
<p>删除链表的倒数第n个节点</p>
<p><strong>思路</strong></p>
<p>使用双指针法，第一个指针访问第n个节点，然后同时移动两个指针，当第一个指针到达尾部时，第二个指针指向的就是倒数第n个节点。</p>
<p>需要考虑边界条件</p>
<ol>
<li>head节点为空</li>
<li>n大于链表节点数目</li>
<li>当链表只有一个节点且需要删除当前节点的情况(有指向head的头结点时会更好处理)</li>
</ol>
<p>使用一个指向head的头节点会比较好处理一些。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑head为空</span></span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *bak, *low = head, *fast = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!fast)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            bak = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> bak;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = low-&gt;next;</span><br><span class="line">        low-&gt;next = low-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> fast;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑head为空</span></span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre;</span><br><span class="line">        pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        ListNode *low = pre, *fast = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 考虑n超过范围</span></span><br><span class="line">            <span class="keyword">if</span> (!fast)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast肯定不会为空，只是保险</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = low-&gt;next;</span><br><span class="line">        low-&gt;next = low-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 记得释放删除节点的内存</span></span><br><span class="line">        <span class="keyword">delete</span> fast;</span><br><span class="line">        low = pre-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pre;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92.Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">92.Reverse Linked List II</a></h2><p><strong>题目大意</strong></p>
<p>给定一个单链表，翻转m到n的位置，链表从1开始标号。要求in-place and one-pass。</p>
<p><strong>思路</strong></p>
<ol>
<li>使用额外空间：<ul>
<li>fast指针先指到m位置，遍历到n，将值push到栈中；</li>
<li>low从m位置开始，依次将栈中值pop出来存储到对应的节点位置</li>
</ul>
</li>
<li>直接操作<ul>
<li>pre指向(m-1)位置，pStart指向m位置，那么依次开始逆序</li>
<li>tmp = pStart-&gt;next;</li>
<li>pStart-&gt;next = tmp-&gt;next;</li>
<li>tmp-&gt;next = pre-&gt;next;</li>
<li>pre-&gt;next = tmp;</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *pre = &amp;preHead;</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *p=pre, *pstart=<span class="literal">NULL</span>, *t=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; ++i)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        pstart = p-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-m; ++i)&#123;</span><br><span class="line">            t = pstart-&gt;next;</span><br><span class="line">            pstart-&gt;next = t-&gt;next;</span><br><span class="line">            t-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        n -= m;</span><br><span class="line">        ListNode *root=<span class="literal">NULL</span>, *pre=<span class="literal">NULL</span>, *pStart=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">preNode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        root = &amp;preNode;</span><br><span class="line">        root-&gt;next = head;</span><br><span class="line">        pre = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (--m)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pStart = pre-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">            ListNode *t = pStart-&gt;next;</span><br><span class="line">            pStart-&gt;next = t-&gt;next;</span><br><span class="line">            t-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21.Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">21.Merge Two Sorted Lists</a></h2><p><strong>题目大意</strong></p>
<p>将两条排序好的链表合并，要求返回的新链表的节点是由旧链表而来。</p>
<p><strong>思路</strong></p>
<p>归并排序的思路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">prenode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        pre = &amp;prenode;</span><br><span class="line">        ListNode *cur = pre;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l1)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2)&#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23.Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">23.Merge k Sorted Lists</a></h2><p><strong>题目大意</strong></p>
<p>合并k条排好序的链表</p>
<p><strong>思路</strong></p>
<ol>
<li>普通思路<ul>
<li>转换为k次两个链表的合并</li>
<li>时间复杂度为$O(k^2n)$</li>
</ul>
</li>
<li>复杂度为$O(log(k)n)$<ul>
<li>比较k个链表的当前最小值时，使用堆排序维护顺序，这样的话就不需要重复进行排序了</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=lists.size(); ++i)&#123;</span><br><span class="line">            tmp = mergeTwoLists(tmp, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        pre = &amp;preHead;</span><br><span class="line">        ListNode* head = pre;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">                head-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1)</span><br><span class="line">            head-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2)</span><br><span class="line">            head-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// priority_queue的比较</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">      	<span class="comment">// 	小顶堆</span></span><br><span class="line">        <span class="keyword">return</span> (a-&gt;val &gt; b-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *pre=<span class="literal">NULL</span>, *cur=<span class="literal">NULL</span>, *tmp=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        pre = &amp;preHead;</span><br><span class="line">        cur = pre;</span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=lists.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i])&#123;</span><br><span class="line">                q.push(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            tmp = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;next)</span><br><span class="line">                q.push(tmp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138.Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/" target="_blank" rel="noopener">138.Copy List with Random Pointer</a></h2><ol>
<li>题目大意<ul>
<li>给定一条带有随机指针的链表，随机指针随机指向链表中的某个节点，要求返回该链表的深拷贝。</li>
</ul>
</li>
<li>思路<ul>
<li>1<ul>
<li>先对仅仅对链表的普通关系进行复制，同时用一个map存储原来链表节点和复制链表节点的对应关系</li>
<li>再遍历一遍普通链表，对非空的random指针在复制链表中复制，指向的节点有map确定</li>
</ul>
</li>
<li>2<ul>
<li>对原有链表复制一个节点插入到当前节点后面</li>
<li>复制random pointer</li>
<li>拆分</li>
</ul>
</li>
</ul>
</li>
<li>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="function">RandomListNode <span class="title">preHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        pre = &amp;preHead;</span><br><span class="line">        RandomListNode *cur1=head, *cur2 = pre;</span><br><span class="line">        <span class="built_in">map</span>&lt;RandomListNode*, RandomListNode*&gt; cache;</span><br><span class="line">        <span class="keyword">while</span> (cur1)&#123;</span><br><span class="line">            cur2-&gt;next = <span class="keyword">new</span> RandomListNode(cur1-&gt;label);</span><br><span class="line">            cache[cur1] = cur2-&gt;next;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = head;</span><br><span class="line">        cur2 = pre-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur1)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1-&gt;random)&#123;</span><br><span class="line">                cur2-&gt;random = cache[cur1-&gt;random];</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode *cur = head, *tmp=<span class="literal">NULL</span>, *cur1=<span class="literal">NULL</span>, *res=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// step 1</span></span><br><span class="line">        <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> RandomListNode(cur-&gt;label);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// step 2</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;random)&#123;</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// step 3</span></span><br><span class="line">        res = head-&gt;next;</span><br><span class="line">        cur1 = head-&gt;next;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">            tmp = cur1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (tmp)&#123;</span><br><span class="line">                cur1-&gt;next = tmp-&gt;next;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160.Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">160.Intersection of Two Linked Lists</a></h2><ol>
<li>题目大意<ul>
<li>给定两个有公共部分的单链表，找出单链表的交叉点</li>
</ul>
</li>
<li>思路<ul>
<li>将两个单链表当做循环链表<ul>
<li>如果两个链表长度相同，那么两个指针相遇的位置即为交叉点</li>
<li>如果长度不同，一个大圈一个小圈，循环遍历，一定有某个时刻会相遇到交叉点</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *l1=headA, *l2=headB;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="literal">NULL</span> || l2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1!=l2)&#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1 == l2) <span class="keyword">return</span> l1;<span class="comment">// 如果相遇到为空的点，那么两个链表不存在公共节点</span></span><br><span class="line">            <span class="comment">// 空节点说明到达了尾部，要跳过空节点，进入到头节点</span></span><br><span class="line">            <span class="comment">// 注意，不能将该步骤移到while的开始部分，while需要两次判断low和high是否相等</span></span><br><span class="line">            <span class="comment">// 第一次是判断是不是公共节点，第二次是判断是不是有公共节点</span></span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) l1 = headA;</span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) l2 = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141.Linked List Cycle"></a><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">141.Linked List Cycle</a></h2><h2 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142.Linked List Cycle II"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">142.Linked List Cycle II</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>判断一个链表是否有环</li>
<li>如果一个链表有环，找到环的入口</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>有环<ol>
<li>使用快慢指针</li>
<li>如果相遇则有环，否则fast到达尾部(NULL)</li>
</ol>
</li>
<li>入口<ol>
<li>相遇位置为(km)</li>
<li>开始节点到入口(n-m)</li>
<li>相遇位置到入口需要走的路径长度为(m - (km-(n-m))) = n - km</li>
<li>所以必然会相遇在入口节点</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 141</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast=head, *slow=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 142</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *slow=head, *fast=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=slow)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a><a href="https://leetcode.com/problems/find-the-duplicate-number/description/" target="_blank" rel="noopener">287. Find the Duplicate Number</a></h2><p><strong>题目大意</strong></p>
<p>给定一个包含n+1个整数（[1,n]）的数组，假设只有一个重复数字，要求找到这个重复的数字。</p>
<p><strong>思路</strong></p>
<p>本身这个题目不算难，用hash或者排序都可以做，但是要求不能改变原数组、空间复杂度为O(1)、时间复杂度低于o(n^2)，这样就不好做了。</p>
<ol>
<li><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">142. Linked List Cycle II</a>类似于这道题的解法。</li>
<li>双指针方法<ol>
<li>设置low指针和fast指针，low每次走一步，fast每次走两步；</li>
<li>存在环必然会相遇，设相遇时low走了k步，环的长度为r，则2k-k = nr；</li>
<li>环入口到相遇位置距离为m，数组开始位置到环入口位置的距离为s，则k - s =m, nr - s = m, s = (n-1)r + (r-m)</li>
<li>由上式可知，相遇后，如果fast再从0位置开始，low在相遇位置开始，low和fast都以一步为步长前进，则会相遇到环入口，而环入口上一个位置则为重复的数。</li>
<li>指针从不同位置开始，结果会略微不同，需要注意。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">/* 整数是1到n，而重复的指针下一步会指到相同的位置，</span></span><br><span class="line"><span class="comment">		 *所以必然会形成一个循环，因此可以通过步长不同的指针去找到这个循环 </span></span><br><span class="line"><span class="comment">		 *如果是这样开始的话，2k-k-1=nr, k-s=m, nr-1-s=m, -&gt; s = (n-1)r+(r-m)+1</span></span><br><span class="line"><span class="comment">		 * 所以fast需要从0开始，而不能从nums[0]开始 </span></span><br><span class="line"><span class="comment">		 */</span> </span><br><span class="line">        <span class="keyword">while</span> (low != fast)&#123;</span><br><span class="line">			low = nums[low];</span><br><span class="line">			fast = nums[nums[fast]];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; low &lt;&lt; <span class="string">" "</span> &lt;&lt; fast &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*可以证明，low在第一次meet的位置，fast从第一个位置开始 </span></span><br><span class="line"><span class="comment">         *同时以一步移动，最后会相遇在相同的那个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low != fast)&#123;</span><br><span class="line">			low = nums[low];</span><br><span class="line">			fast = nums[fast];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; low &lt;&lt; <span class="string">" "</span> &lt;&lt; fast &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="BinaryTree"><a href="#BinaryTree" class="headerlink" title="BinaryTree"></a><strong>BinaryTree</strong></h1><h2 id="572-Subtree-of-Another-Tree"><a href="#572-Subtree-of-Another-Tree" class="headerlink" title="572.Subtree of Another Tree"></a><a href="https://leetcode.com/problems/subtree-of-another-tree/description/" target="_blank" rel="noopener">572.Subtree of Another Tree</a></h2><p><strong>题目大意</strong></p>
<p>给定两棵二叉树s和t，判断t是否是a的子树。</p>
<p><strong>思路</strong></p>
<p>二叉树问题基本都可以用递归解决</p>
<ol>
<li>isSubtree：看看s和t是否是相同的，是就return true，否则，判断s-&gt;left和t或者s-&gt;right和t是否是相同的；</li>
<li>isSame：如果s-&gt;val == t-&gt;val 则递归判断left和right，否则直接返回false；</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((s &amp;&amp; !t) || (!s &amp;&amp; t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isSame(s, t))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* s, TreeNode* t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((s &amp;&amp; !t) || (!s &amp;&amp; t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;val == t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144.Binary Tree Preorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">144.Binary Tree Preorder Traversal</a></h2><h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145.Binary Tree Postorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145.Binary Tree Postorder Traversal</a></h2><p><strong>题目大意</strong></p>
<p>前序和后序遍历二叉树</p>
<p><strong>思路</strong></p>
<p>基础的二叉树前序、中序和后序遍历没什么好说的，但是这两个题目提供了新的思路，值得思考</p>
<ol>
<li>前序遍历<ul>
<li>不再沿着左子树一直搜索下去，每次将右节点和左节点入栈，下一次循环时，左节点出栈继续该过程，因此也达到了先序遍历的目的</li>
<li>中序不适合此种方式，因为栈中没有存储所有的左子节点，所以没办法等到最后一个最深处的左子节点被访问以后再访问父节点，所以无法完成中序遍历</li>
</ul>
</li>
<li>后序遍历<ul>
<li>以往的思路是，对当前节点做一个标记，如果是第二次访问，则该访问该节点，否则 不访问该节点，继续入栈，但是如果节点本身无法做标记就没办法做了；</li>
<li>思路是 先序遍历是 root-left-right，如果root-right-left这样遍历的话，结果反过来就是left-right-root，就是后序遍历的结果(可以递归去思考为什么reverse就是后序的结果)</li>
<li>root-right-left有两种思路<ul>
<li>原来的先序遍历，先入栈右节点</li>
<li>1中提到的先序遍历，同样先入栈左节点</li>
</ul>
</li>
<li>补充一种做法：使用pre节点记录回溯时上一次访问的节点（两种情况，一种是遇到叶子节点会回溯，一种是第二次访问某个节点需要继续向上回溯），如果是当前节点的右节点，说明该节点是第二次访问，访问该节点，出栈即可。</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<p>preorder</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new way to preoder binary tree</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; ss;</span><br><span class="line">        ss.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!ss.empty())&#123;</span><br><span class="line">            root = ss.top();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            ss.pop();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) ss.push(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) ss.push(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nPreOrder</span><span class="params">(Node *bt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bt == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">	<span class="comment">// 如果栈为空但是bt不为空则需要继续遍历</span></span><br><span class="line">	<span class="keyword">while</span> (!ss.empty() || bt)&#123;</span><br><span class="line">		<span class="keyword">while</span> (bt != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; bt-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			s.push(bt);</span><br><span class="line">			bt = bt-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s.empty()) <span class="keyword">return</span>;</span><br><span class="line">		bt = s.top();</span><br><span class="line">        bt = bt-&gt;rchild;</span><br><span class="line">        s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>postorder</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; ss;</span><br><span class="line">        ss.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!ss.empty())&#123;</span><br><span class="line">            root = ss.top();</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">            ss.pop();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) ss.push(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) ss.push(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; ss;</span><br><span class="line">        <span class="keyword">while</span> (!ss.empty() || root)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root)&#123;</span><br><span class="line">                result.push_back(root-&gt;val);</span><br><span class="line">                ss.push(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ss.empty())&#123;</span><br><span class="line">                root = ss.top();</span><br><span class="line">                ss.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root)</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="comment">// 用来记录上次访问的节点是什么，从而判断当前节点是不是第一次访问</span></span><br><span class="line">        TreeNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (root || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (root)&#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()) <span class="keyword">break</span>;</span><br><span class="line">            root = s.top();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right &amp;&amp; root-&gt;right != pre)&#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 包含两种情况，1. 是叶子节点 2. 是第二次访问的节点</span></span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                pre = root;</span><br><span class="line">                s.pop();</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树路径和为某一值"><a href="#二叉树路径和为某一值" class="headerlink" title="二叉树路径和为某一值"></a>二叉树路径和为某一值</h2><h3 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112.Path Sum"></a><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">112.Path Sum</a></h3><ol>
<li>题目大意<ul>
<li>给定一棵二叉树和某个值，判断二叉树是否存在某条路径使得路径和为给定值。路径的起点为根节点，终点为叶子节点。</li>
</ul>
</li>
<li>思路<ul>
<li>递归</li>
<li>非递归<ul>
<li>非递归的方法，因为在遍历完左子树和右子树时才能pop掉当前节点，所以和后序遍历很相似</li>
<li>三种后序遍历方法<ul>
<li>标记节点是第几次访问，如果是第二次访问，则visit该节点。如果节点无法标记做没法做</li>
<li>使用left-right-root的reverse是root-right-left，稍微修改先序遍历代码，得到root-right-left的访问结果，再翻转即可</li>
<li>使用pre节点，记录回溯时刻当前节点的上一次访问的节点，如果是右子树，那么是第二次访问，visit，否则是第一次访问，继续保留在栈中</li>
</ul>
</li>
<li>显然，这个问题只能用第三种方法做。</li>
</ul>
</li>
</ul>
</li>
<li>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; ss;</span><br><span class="line">        TreeNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root || !ss.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (root)&#123;</span><br><span class="line">                s += root-&gt;val;</span><br><span class="line">                ss.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ss.empty()) <span class="keyword">break</span>;</span><br><span class="line">            root = ss.top();</span><br><span class="line">            <span class="keyword">if</span> ((!root-&gt;left &amp;&amp; !root-&gt;right) &amp;&amp; s==sum)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right &amp;&amp; root-&gt;right != pre)&#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = root;</span><br><span class="line">                s -= root-&gt;val;</span><br><span class="line">                ss.pop();</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;val == sum) &amp;&amp; (!root-&gt;left &amp;&amp; !root-&gt;right)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113.Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/description/" target="_blank" rel="noopener">113.Path Sum II</a></h3><ol>
<li>题目大意<ul>
<li>给定一颗二叉树和给定值，要求找到所有的和为给定值的路径，路径定义和上题一样</li>
</ul>
</li>
<li>思路<ul>
<li>有了上题基础，直接递归思路，设置两个引用参数，用于存储路径即可</li>
</ul>
</li>
<li>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        findPath(res, tmp, root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;val == sum) &amp;&amp; (!root-&gt;left &amp;&amp; !root-&gt;right))&#123;</span><br><span class="line">            tmp.push_back(root-&gt;val);</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        findPath(res, tmp, root-&gt;left, sum-root-&gt;val);</span><br><span class="line">        findPath(res, tmp, root-&gt;right, sum-root-&gt;val);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii/description/" target="_blank" rel="noopener">437. Path Sum III</a></h3><ol>
<li>题目大意<ul>
<li>给定二叉树和给定值，求和为给定值的路径个数，路径的起始和结束不一定是跟节点和叶子节点，但是肯定是自上而下的。</li>
</ul>
</li>
<li>思路<ul>
<li>这道题和求解<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Binary Tree Maximum Path Sum</a> ,相当于遍历二叉树每个节点，以每个节点作为起始点，搜索是否存在相应的路径</li>
</ul>
</li>
<li>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> totalPath(root, sum, <span class="number">0</span>) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s+root-&gt;val == sum)</span><br><span class="line">            total++;</span><br><span class="line">        <span class="keyword">return</span> total + totalPath(root-&gt;left, sum, s+root-&gt;val) + totalPath(root-&gt;right, sum, s+root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="255-Verify-Preorder-Sequence-in-Binary-Search-Tree"><a href="#255-Verify-Preorder-Sequence-in-Binary-Search-Tree" class="headerlink" title="255.Verify Preorder Sequence in Binary Search Tree"></a><a href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree" target="_blank" rel="noopener">255.Verify Preorder Sequence in Binary Search Tree</a></h2><ol>
<li>题目大意<ul>
<li>给定一个序列，判断是否是搜索二叉树的后序遍历（剑指offer上是后序）</li>
</ul>
</li>
<li>思路<ul>
<li>序列的最后一个数是根节点，将n-1的序列分为小于和大于两部分，如果找到分界点后，大于的部分出现了小于根节点的数则不符合要求；</li>
<li>递归左子树和右子树</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sequence.size(), i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flagLeft=<span class="literal">true</span>, flagRight=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i!=n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &gt; sequence[n<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">for</span> (; j!=n<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[j] &lt; sequence[n<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(sequence.begin(), sequence.begin()+i);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(sequence.begin()+i, sequence.end()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!left.empty()) </span><br><span class="line">            flagLeft = VerifySquenceOfBST(left);</span><br><span class="line">        <span class="keyword">if</span> (!right.empty())</span><br><span class="line">            flagRight = VerifySquenceOfBST(right);</span><br><span class="line">        <span class="keyword">return</span> (flagLeft &amp;&amp; flagRight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114.Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="noopener">114.Flatten Binary Tree to Linked List</a></h2><ol>
<li>题目大意<ul>
<li>将一棵二叉树转换为链表，要求in-place</li>
</ul>
</li>
<li>思路<ul>
<li>递归：先将链表的末端（右侧）完成，递归到最左侧</li>
<li>非递归<ul>
<li>遍历所有节点</li>
<li>保存好root右子树的</li>
<li>root右子树指向左子树</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        root-&gt;right = pre;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (root)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left)&#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* tmp = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (tmp-&gt;right)&#123;</span><br><span class="line">                    tmp = tmp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><ol>
<li>题目大意<ol>
<li>将一棵二叉搜索树转换为双向链表</li>
</ol>
</li>
<li>思路<ol>
<li>很上一题很相似，都是二叉树转换为链表，上题是先序遍历，该题是中序遍历</li>
<li>分为三个部分，根节点、左节点和右节点<ul>
<li>将左子树排序好返回最大的链表节点</li>
<li>将根节点插入到链表中(最后一个节点)</li>
<li>将右节点当做根节点递归</li>
</ul>
</li>
</ol>
</li>
<li>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRootOfTree) <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        TreeNode* last = <span class="literal">NULL</span>;</span><br><span class="line">        convertNode(pRootOfTree, &amp;last);</span><br><span class="line">        TreeNode* tmp = last;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="literal">NULL</span> &amp;&amp; tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">convertNode</span><span class="params">(TreeNode* node, TreeNode** last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* cur = node;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            convertNode(node-&gt;left, last);</span><br><span class="line">        cur-&gt;left = *last;</span><br><span class="line">        <span class="keyword">if</span> (*last)</span><br><span class="line">            (*last)-&gt;right = cur;</span><br><span class="line">        *last = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right)</span><br><span class="line">            convertNode(cur-&gt;right, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104.Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">104.Maximum Depth of Binary Tree</a></h2><h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111.Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">111.Minimum Depth of Binary Tree</a></h2><p><strong>题目大意</strong></p>
<p>题目很简单，得到一颗二叉树的最大深度和最小深度。深度的定义是根节点到叶子节点的路径长度。</p>
<p><strong>思路</strong></p>
<ol>
<li>递归思路<ul>
<li>1 + 以当前节点为根节点的最小或最大深度</li>
</ul>
</li>
<li>层次遍历<ul>
<li>如果节点是左右子树均为NULL，则为叶子节点</li>
<li>最小，第一次遇到叶子节点即返回深度</li>
<li>最大，遍历所有，返回最大深度即可</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<p>min</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> <span class="number">1</span>+minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>+minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+min(minDepth(root-&gt;right), minDepth(root-&gt;left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用队列，用额外的空间存储层数相关信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !q.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">                    m1[cur-&gt;left] = layer++;</span><br><span class="line">                    q.push(m1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">                    m2[cur-&gt;right] = layer++;</span><br><span class="line">                    q.push(m2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!q.empty())&#123;</span><br><span class="line">                <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; m;</span><br><span class="line">                m = q.front();</span><br><span class="line">                cur = (m.begin())-&gt;first;</span><br><span class="line">                layer = m[cur];</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (!(cur-&gt;left || cur-&gt;right)) </span><br><span class="line">                    <span class="keyword">return</span> m[cur];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> layer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较巧妙的记录层数信息，每一次都遍历完队列中的节点，这些节点都是属于同一层的c</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            ++layer;</span><br><span class="line">            <span class="keyword">int</span> k = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=k; ++i)&#123;</span><br><span class="line">                cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) q.push(cur-&gt;left); <span class="comment">// if we judge the push TreeNode is not NULL, </span></span><br><span class="line">                                                  <span class="comment">// then you couldn't judge the node is not NULL outspace</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (!(cur-&gt;left || cur-&gt;right))</span><br><span class="line">                    <span class="keyword">return</span> layer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>max</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> <span class="number">1</span>+maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>+maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">           layer++;</span><br><span class="line">           <span class="keyword">int</span> k = q.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=k; ++i)&#123;</span><br><span class="line">               cur = q.front();</span><br><span class="line">               q.pop();</span><br><span class="line">               <span class="keyword">if</span> (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">               <span class="keyword">if</span> (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> layer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222.Count Complete Tree Nodes"></a><a href="https://leetcode.com/problems/count-complete-tree-nodes/description/" target="_blank" rel="noopener">222.Count Complete Tree Nodes</a></h2><p><strong>题目大意</strong></p>
<p>给定一颗完全二叉树，求节点个数。要求复杂度低于O(n)</p>
<p><strong>思路</strong></p>
<p>如果左子树右子树高度相等，那么不需要判断直接根据高度计算。否则，递归计算左子树和右子树的节点数。</p>
<p>因为一定存在较多满二叉树，所以时间复杂度低于O(n)。仔细想想，不存在太坏的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode *l=root, *r=root;</span><br><span class="line">        <span class="keyword">int</span> lh=<span class="number">0</span>, rh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l) &#123;</span><br><span class="line">            l = l-&gt;left;</span><br><span class="line">            lh++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r) &#123;</span><br><span class="line">            r = r-&gt;right;</span><br><span class="line">            rh++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lh == rh) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, lh) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236.Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">236.Lowest Common Ancestor of a Binary Tree</a></h2><p><strong>题目大意</strong></p>
<p>找到一棵二叉树两点节点最近公共祖先。</p>
<p><strong>思路</strong></p>
<ol>
<li>遍历找到分别到两个节点的路径，比较两个路径，第一个不同节点的上一个节点则为公共祖先</li>
<li>如果root为p则返回root，如果root为q则返回root，如果root为空则返回空(其实也就是返回了p或q是否在子树里)<ol>
<li>否则，递归左、右子树</li>
<li>如果q、p在同一个子树那么返回的就是公共祖先，否则如果p和q分别在两个子树，则root是公共祖先</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (!left)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235.Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">235.Lowest Common Ancestor of a Binary Search Tree</a></h2><p><strong>题目大意</strong></p>
<p>给定一个二叉搜索树及两个节点，找到节点的最近公共祖先。</p>
<p><strong>思路</strong></p>
<p>利用BST的特点，如果p和q的值跟root比一大一小，则root为最近公共祖先，否则递归左子树或者右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124.Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/" target="_blank" rel="noopener">124.Binary Tree Maximum Path Sum</a></h2><p><strong>题目大意</strong></p>
<p>给定一棵二叉树，找到最大的路径和。路径可以试从child-root-child</p>
<p><strong>思路</strong></p>
<p>类比求数组的最大连续子数组和</p>
<p>用res记录最大路径和，每一层递归记录以root为中间节点的最大和(root-&gt;val + max(0, left) + max(0, right))</p>
<p>返回的是root-child的单向最大和，因为需要和parent组成child-root-child路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        findMax(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = findMax(root-&gt;left, res);</span><br><span class="line">        <span class="keyword">int</span> right = findMax(root-&gt;right, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span>) right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val + left + right &gt; res) res = root-&gt;val + left + right;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="root-child的最大路径和"><a href="#root-child的最大路径和" class="headerlink" title="root-child的最大路径和"></a><a href="">root-child的最大路径和</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        findMax(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = findMax(root-&gt;left, res);</span><br><span class="line">        <span class="keyword">int</span> right = findMax(root-&gt;right, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span>) right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = root-&gt;val + max(left, right);</span><br><span class="line">       	res = max(res, cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node</a></h2><h2 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II</a></h2><p><strong>题目大意</strong></p>
<p>给定一棵满二叉树，在水平方向上的前一个节点有next指针指向下一个节点；</p>
<p>如果是一颗普通二叉树呢</p>
<p><strong>思路</strong></p>
<ol>
<li>满二叉树<ol>
<li>当前节点的left指向right</li>
<li>当前root节点的right的next指向root-&gt;next的left节点</li>
<li>递归左子树和右子树</li>
</ol>
</li>
<li>普通二叉树<ol>
<li>root的right要指向的节点隔了好几个节点（while(root-&gt;next)找到root-&gt;next-&gt;left或者root-&gt;next-&gt;right不为空的节点）</li>
<li>上面的循环要求右子树先形成next，所以先递归右子树</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right &amp;&amp; root-&gt;next-&gt;left)</span><br><span class="line">                root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">            root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        TreeLinkNode* tmp = root;</span><br><span class="line">        <span class="comment">// 因为二叉树不是完全二叉树，可能水平方向隔了很多个节点才有下一个节点，所以需要一直循环root-&gt;next</span></span><br><span class="line">        <span class="comment">// 直到找到下一个节点或者null</span></span><br><span class="line">        TreeLinkNode* left = tmp-&gt;right ? tmp-&gt;right : tmp-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;next)&#123;</span><br><span class="line">            TreeLinkNode* right = tmp-&gt;next-&gt;left ? tmp-&gt;next-&gt;left : tmp-&gt;next-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (left &amp;&amp; right)&#123;</span><br><span class="line">                left-&gt;next = right;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">            root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可能root右侧隔了很多个空节点才有节点，所以先调整好右边，在到左边 一直循环next找下去</span></span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208.Implement Trie (Prefix Tree)"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">208.Implement Trie (Prefix Tree)</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>实现一棵字典树</li>
</ol>
<p>思路</p>
<ol>
<li>一个trie node，用于存储当前的字母以及当前字母是否为单词的结束</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> is_word;</span><br><span class="line">    </span><br><span class="line">    TrieNode(<span class="keyword">bool</span> word = <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">        is_word = word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=word.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next[word[i]-<span class="string">'a'</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                p-&gt;next[word[i]-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">             p = p-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=word.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next[word[i]-<span class="string">'a'</span>] != <span class="literal">NULL</span>)</span><br><span class="line">                p = p-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;is_word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=prefix.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next[prefix[i]-<span class="string">'a'</span>] != <span class="literal">NULL</span>)</span><br><span class="line">                p = p-&gt;next[prefix[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="116-Populating-Next-Right-Pointers-in-Each-Node-1"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node-1" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node</a></h2><p><strong>题目大意</strong></p>
<p>给定一棵满二叉树，要求每个节点有个next指针，指向右侧的节点</p>
<p><strong>思路</strong></p>
<p>递归处理，对于每个节点root，需要做两件事情</p>
<ol>
<li>将右子树的next指向next的左子树 root-&gt;right-&gt;next = root-&gt;next-&gt;left </li>
<li>将左子树next指向右子树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right &amp;&amp; root-&gt;next-&gt;left)</span><br><span class="line">                root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">            root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="117-Populating-Next-Right-Pointers-in-Each-Node-II-1"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-1" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II</a></h2><p><strong>题目大意</strong></p>
<p>将上题中的满二叉树改为普通二叉树</p>
<p><strong>思路</strong></p>
<p>两个问题</p>
<ol>
<li>水平方向上当前节点next需要指向的节点可能隔了好几个空节点，怎么办<ul>
<li>可以考虑一直root-&gt;next循环，直到找到非空的节点</li>
</ul>
</li>
<li>如何保证水平方向右边的next指针是已经建立好的（这样才可以循环找到非空节点）<ul>
<li>先递归右子树，再递归左子树</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        TreeLinkNode* tmp = root;</span><br><span class="line">        <span class="comment">// 因为二叉树不是完全二叉树，可能水平方向隔了很多个节点才有下一个节点，所以需要一直循环root-&gt;next</span></span><br><span class="line">        <span class="comment">// 直到找到下一个节点或者null</span></span><br><span class="line">        TreeLinkNode* left = tmp-&gt;right ? tmp-&gt;right : tmp-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;next)&#123;</span><br><span class="line">            TreeLinkNode* right = tmp-&gt;next-&gt;left ? tmp-&gt;next-&gt;left : tmp-&gt;next-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (left &amp;&amp; right)&#123;</span><br><span class="line">                left-&gt;next = right;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">            root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可能root右侧隔了很多个空节点才有节点，所以先调整好右边，在到左边 一直循环next找下去</span></span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="stack-amp-queue"><a href="#stack-amp-queue" class="headerlink" title="stack&amp;queue"></a><strong>stack&amp;queue</strong></h1><h2 id="155-min-stack"><a href="#155-min-stack" class="headerlink" title="155.min stack"></a><a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">155.min stack</a></h2><ol>
<li>题目大意<ul>
<li>实现一个栈，包括push、pop、top、和min方法，min方法是返回栈中最小值</li>
</ul>
</li>
<li>思路<ul>
<li>用一个数组存排序好的栈中的数，这种方法略笨重，时间复杂度也高；</li>
<li>两个栈ss和m_ss，ss用来存储栈数据，m_ss用来存储当前的最小值(用栈来实现很巧妙)<ul>
<li>m_ss入栈的时候永远是当前的最小值，如果新压入栈数大于栈顶元素则压入栈顶元素，否则压入该元素</li>
<li>出栈时，如果当前数是最小值，那么m_ss出栈了，m_ss栈顶位置是之前的最小值；如果当前数不是最小值，则m_ss出栈不影响之后的最小值。</li>
</ul>
</li>
</ul>
</li>
<li>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ss.push(x);</span><br><span class="line">        <span class="keyword">if</span> (m_ss.empty() || m_ss.top() &gt; x)</span><br><span class="line">            m_ss.push(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m_ss.push(m_ss.top());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(!ss.empty());</span><br><span class="line">        ss.pop();</span><br><span class="line">        m_ss.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(!ss.empty());</span><br><span class="line">        <span class="keyword">return</span> ss.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(!m_ss.empty());</span><br><span class="line">        <span class="keyword">return</span> m_ss.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ss;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; m_ss;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ss.push(x);</span><br><span class="line">        insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = ss.top();</span><br><span class="line">        ss.pop();</span><br><span class="line">        remove(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ss.empty())</span><br><span class="line">            <span class="keyword">return</span> ss.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ss.empty())</span><br><span class="line">            <span class="keyword">return</span> minVec[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = findIndex(x);</span><br><span class="line">        minVec.insert(minVec.begin()+low, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = findIndex(x);</span><br><span class="line">        minVec.erase(minVec.begin()+low, minVec.begin()+low+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, high=minVec.size()<span class="number">-1</span>, mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low&lt;=high)&#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (minVec[mid] &lt; x)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ss;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minVec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Dfs-amp-bfs"><a href="#Dfs-amp-bfs" class="headerlink" title="Dfs&amp;bfs"></a><strong>Dfs&amp;bfs</strong></h1><h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22.Generate Parentheses"></a><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="noopener">22.Generate Parentheses</a></h2><ol>
<li>题目大意<ul>
<li>给定一个数n，表示是括号的个数，输出包含n个括号的组合</li>
</ul>
</li>
<li>思路<ul>
<li>这种排列组合类的题，dfs是万能，需要考虑<ul>
<li>左括号和右括号的个数</li>
<li>当前字符串中加入右括号时，右括号个数不能大于左括号个数</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        dfs(res, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(res, tmp+<span class="string">"("</span>, left<span class="number">-1</span>, right);</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span> &amp;&amp; right &gt; left)</span><br><span class="line">            dfs(res, tmp+<span class="string">")"</span>, left, right<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51.  N-Queens"></a><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">51.  N-Queens</a></h2><h2 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a><a href="https://leetcode.com/problems/n-queens-ii/description/" target="_blank" rel="noopener">52. N-Queens II</a></h2><ol>
<li>问题描述<ul>
<li>$n\times n$的棋盘，放上n个皇后，要求每一行、每一列、45度和135度方向均不能存在两个皇后，问有多少种放法，以及输出每种放置方法。</li>
</ul>
</li>
<li>回溯法<ul>
<li>每一层放置一个皇后，遍历n个位置，如果该位置合法，进入下一行放置下一个皇后</li>
<li>dfs思路</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; chess(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">        dfs(res, chess, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; chess, <span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n)&#123;</span><br><span class="line">            res.push_back(chess);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>; col!=n; ++col)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isvalid(chess, row, col, n))&#123;</span><br><span class="line">                chess[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                dfs(res, chess, row+<span class="number">1</span>, n);</span><br><span class="line">                chess[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; chess, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=row<span class="number">-1</span>, y=col<span class="number">-1</span>; x&gt;=<span class="number">0</span> &amp;&amp; y&gt;=<span class="number">0</span>; --x, --y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[x][y] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=row<span class="number">-1</span>, y=col+<span class="number">1</span>; x&gt;=<span class="number">0</span> &amp;&amp; y&lt;n; --x, ++y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[x][y] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; chess(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">        dfs(res, chess, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; chess, <span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>; col!=n; ++col)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isvalid(chess, row, col, n))&#123;</span><br><span class="line">                chess[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                dfs(res, chess, row+<span class="number">1</span>, n);</span><br><span class="line">                chess[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; chess, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=row<span class="number">-1</span>, y=col<span class="number">-1</span>; x&gt;=<span class="number">0</span> &amp;&amp; y&gt;=<span class="number">0</span>; --x, --y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[x][y] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=row<span class="number">-1</span>, y=col+<span class="number">1</span>; x&gt;=<span class="number">0</span> &amp;&amp; y&lt;n; --x, ++y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[x][y] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="trick"><a href="#trick" class="headerlink" title="trick"></a><strong>trick</strong></h1><h2 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54.Spiral Matrix"></a><a href="https://leetcode.com/problems/spiral-matrix/description/" target="_blank" rel="noopener">54.Spiral Matrix</a></h2><ol>
<li>题目大意<ul>
<li>给定一个二维数组，要求螺旋打印数组中的数</li>
</ul>
</li>
<li>思路<ul>
<li>每一圈的左上角的点都是(start, start)，start <em> 2 &lt; m &amp;&amp; start </em> 2&lt;n</li>
<li>每一圈，有四个方向，有相应的限制条件，在相应限制条件下打印即可</li>
</ul>
</li>
<li>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size(), col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>, endRow=<span class="number">0</span>, endCol=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start*<span class="number">2</span>&lt;row &amp;&amp; start*<span class="number">2</span>&lt;col)&#123;</span><br><span class="line">            endRow = row - start - <span class="number">1</span>;</span><br><span class="line">            endCol = col - start - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=endCol; ++i)</span><br><span class="line">                res.push_back(matrix[start][i]);</span><br><span class="line">            <span class="keyword">if</span> (start &lt; endRow)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;=endRow; ++i)</span><br><span class="line">                    res.push_back(matrix[i][endCol]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; endRow &amp;&amp; start &lt; endCol)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=endCol<span class="number">-1</span>; i&gt;=start; --i)</span><br><span class="line">                    res.push_back(matrix[endRow][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; endRow<span class="number">-1</span> &amp;&amp; start &lt; endCol)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=endRow<span class="number">-1</span>; i&gt;start; --i)</span><br><span class="line">                    res.push_back(matrix[i][start]);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169.Majority Element"></a><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">169.Majority Element</a></h2><ol>
<li>题目大意<ul>
<li>给定一个长度为n的数组，找出数组中出现次数大于n/2的数</li>
</ul>
</li>
<li>思路<ul>
<li>排序</li>
<li>majority element的次数</li>
<li>随机找个数，判断是否为majority element</li>
<li>Bit Manipulation<ul>
<li>计算每一位是否是majority</li>
</ul>
</li>
</ul>
</li>
<li>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>], times = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (result != nums[i])&#123;</span><br><span class="line">                times--;</span><br><span class="line">                <span class="keyword">if</span> (times &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    result = nums[i];</span><br><span class="line">                    times = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> major = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mask = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> bitCounts = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &amp; mask) bitCounts++;</span><br><span class="line">                <span class="keyword">if</span> (bitCounts &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">                    major |= mask;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="229-Majority-Element-II"><a href="#229-Majority-Element-II" class="headerlink" title="229.Majority Element II"></a><a href="https://leetcode.com/problems/majority-element-ii/description/" target="_blank" rel="noopener">229.Majority Element II</a></h2><ol>
<li>题目大意<ul>
<li>给定一个长度为n的数组，找出数组中出现次数大于n/3的数</li>
<li>要求线性时间复杂度，空间复杂度为O(1)</li>
</ul>
</li>
<li>思路<ul>
<li>Moore Majority Voting</li>
<li>使用res1和res2记录当前两个数，count1和count2记录当前两个数出现的次数</li>
<li>可行性分析<ul>
<li>如果存在两个满足条件的数，那么剩下的数出现次数将少于n/3，所以最后剩下的两个数一定是次数大于n/3的数</li>
<li>如果只存在一个满足条件的数a，则a出现次数t大于n/3，最多能减少的次数为(n-t)/2 &lt; n/3，所以a必然能保留到最后(333331212)</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; majorityElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> res1=<span class="number">0</span>, count1=<span class="number">0</span>, res2=<span class="number">0</span>, count2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == res1)</span><br><span class="line">                count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == res2)</span><br><span class="line">                count2++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count1 == <span class="number">0</span>)&#123;</span><br><span class="line">                res1 = nums[i];</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>)&#123;</span><br><span class="line">                res2 = nums[i];</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == res1)</span><br><span class="line">                count1++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == res2)</span><br><span class="line">                count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; nums.size()/<span class="number">3</span>) res.push_back(res1);</span><br><span class="line">        <span class="keyword">if</span> (count2 &gt; nums.size()/<span class="number">3</span> &amp;&amp; res2 != res1) res.push_back(res2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347.Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">347.Top K Frequent Elements</a></h2><ol>
<li>题目大意<ul>
<li>给定一个数组，找出出现频率最多的k个数</li>
</ul>
</li>
<li>思路<ul>
<li>先统计每个数出现次数</li>
<li>使用优先级队列排序，使优先级队列的大小为(n-k)</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cache1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            cache1[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it=cache1.begin(); it!=cache1.end(); ++it)&#123;</span><br><span class="line">            q.push(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; cache1.size()-k)&#123;</span><br><span class="line">                res.push_back(q.top().second);</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215.Kth Largest Element in an Array"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215.Kth Largest Element in an Array</a></h2><ol>
<li>题目大意<ul>
<li>找到数组中第k大的元素</li>
</ul>
</li>
<li>思路<ul>
<li>堆<ul>
<li>维护一个k大小的最小堆(优先级队列)</li>
<li>遍历完所有元素，堆顶元素即为k大的元素</li>
</ul>
</li>
<li>partition</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; k) q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, e = nums.size()<span class="number">-1</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            index = partition(nums, s, e);</span><br><span class="line">            <span class="keyword">if</span> (index == nums.size()-k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; nums.size()-k)&#123;</span><br><span class="line">                s = index+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                e = index<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[s];</span><br><span class="line">        <span class="keyword">while</span> (s &lt; e)&#123;</span><br><span class="line">        	<span class="comment">// 注意快排时，交换以后s和e需要改变，否则遇到有重复数的数组会进入死循环</span></span><br><span class="line">            <span class="keyword">while</span>(s &lt; e &amp;&amp; nums[e] &gt; tmp) --e;</span><br><span class="line">            <span class="keyword">if</span> (s &lt; e)</span><br><span class="line">                nums[s++] = nums[e];</span><br><span class="line">            <span class="keyword">while</span>(s &lt; e &amp;&amp; nums[s] &lt; tmp) ++s;</span><br><span class="line">            <span class="keyword">if</span> (s &lt; e)</span><br><span class="line">                nums[e--] = nums[s];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[s] = tmp;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="179-Largest-Number"><a href="#179-Largest-Number" class="headerlink" title="179.Largest Number"></a><a href="https://leetcode.com/problems/largest-number/description/" target="_blank" rel="noopener">179.Largest Number</a></h2><ol>
<li>题目大意<ul>
<li>给定一个数组，将数组中的数拼接成一个大数，求其中最大的数</li>
</ul>
</li>
<li>思路<ul>
<li>将数组中的数按照拼接的大小顺序排序</li>
<li>注意，拼接后的数可能会非常大，是一个大数问题，需要用字符串表示</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; new_nums;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)</span><br><span class="line">            new_nums.push_back(to_string(nums[i]));</span><br><span class="line">        sort(new_nums.begin(), new_nums.end(), compare);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=new_nums.size(); ++i)</span><br><span class="line">            res += new_nums[i];</span><br><span class="line">        <span class="keyword">while</span> (res.size() &gt; <span class="number">1</span> &amp;&amp; res[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">            res.erase(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 给sort用的函数，必须是static或者在类外定义，否则sort无法访问</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="keyword">static</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a+b) &gt; (b+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="264-Ugly-Number-II"><a href="#264-Ugly-Number-II" class="headerlink" title="264.Ugly Number II"></a><a href="https://leetcode.com/problems/ugly-number-ii/description/" target="_blank" rel="noopener">264.Ugly Number II</a></h2><ol>
<li>题目大意<ul>
<li>因子分解只有2、3和5的数称为丑数，给定n，求第n个丑数是多少。默认1为第一个丑数</li>
</ul>
</li>
<li>思路<ul>
<li>新的丑数都是由旧的丑数乘以2或3或5得到的</li>
<li>记录2或3或5乘到的位置，每次选取最小的即可</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l2=<span class="number">0</span>, l3=<span class="number">0</span>, l5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = min(dp[l2]*<span class="number">2</span>, min(dp[l3]*<span class="number">3</span>, dp[l5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (tmp == dp[l2]*<span class="number">2</span>) l2++;</span><br><span class="line">            <span class="keyword">if</span> (tmp == dp[l3]*<span class="number">3</span>) l3++;</span><br><span class="line">            <span class="keyword">if</span> (tmp == dp[l5]*<span class="number">5</span>) l5++;</span><br><span class="line">            dp.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="315-Count-of-Smaller-Numbers-After-Self"><a href="#315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="315.Count of Smaller Numbers After Self"></a><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/" target="_blank" rel="noopener">315.Count of Smaller Numbers After Self</a></h2><ol>
<li>题目大意<ul>
<li>给定一个数组，返回一个数组，每个位置表示在该数右边比该数小的个数</li>
</ul>
</li>
<li>思路<ul>
<li>暴力，<script type="math/tex">O(n^2)</script></li>
<li>巧妙使用归并排序<ul>
<li>学习到递归形式的归并排序，简单好写</li>
<li>每一趟归并排序时，数组两部分都是有序的，所以左侧的较大的数的逆序数是建立在较小数的基础上，比如a[2]是在a[1]的逆序数上开始进行累加，避免了重复计算</li>
<li>该题要求返回每个位置的逆序数，所以不能直接对原数组进行归并排序，采用了对原数组的index进行归并排序；</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>), index(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">            index[i] = i;</span><br><span class="line">        mergeCount(nums, res, index, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; index, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>, mid = s + (n - s) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            mergeCount(nums, res, index, s, mid);</span><br><span class="line">            mergeCount(nums, res, index, mid, n);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "== " &lt;&lt; s &lt;&lt; " " &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> id1 = s, id2 = mid;</span><br><span class="line">            <span class="comment">// 避免需要另一个vector存储排序好的数组</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span> (id1&lt;mid || id2&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span> (id2 == n || (id1 &lt; mid &amp;&amp; nums[index[id1]] &lt;= nums[index[id2]]))&#123;</span><br><span class="line">                    tmp.push_back(index[id1]);</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; 'a' &lt;&lt; id1 &lt;&lt; " " &lt;&lt; index[id1] &lt;&lt; " " &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">                    res[index[id1]] += count;</span><br><span class="line">                    id1++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp.push_back(index[id2++]);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; 'b' &lt;&lt; id2 &lt;&lt; " " &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move(tmp.begin(), tmp.end(), index.begin()+s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中的逆序对</a></h2><ol>
<li>题目大意<ul>
<li>返回数组中逆序对个数</li>
</ul>
</li>
<li>思路<ul>
<li>归并排序</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> mergeCount(data, tmp, <span class="number">0</span>, n)%<span class="number">1000000007</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mergeCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = n - s;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = s + length / <span class="number">2</span>;</span><br><span class="line">            left = mergeCount(data, tmp, s, mid);</span><br><span class="line">            right = mergeCount(data, tmp, mid, n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s1 = mid<span class="number">-1</span>, s2 = n<span class="number">-1</span>, i=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (s1 &gt;= s &amp;&amp; s2 &gt;= mid)&#123;</span><br><span class="line">                <span class="keyword">if</span> (data[s1] &gt; data[s2])&#123;</span><br><span class="line">                    count = count + s2 - mid + <span class="number">1</span>;</span><br><span class="line">                    tmp[i--] = data[s1--];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    tmp[i--] = data[s2--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (s1 &gt;= s)</span><br><span class="line">                tmp[i--] = data[s1--];</span><br><span class="line">            <span class="keyword">while</span> (s2 &gt;= mid)</span><br><span class="line">                tmp[i--] = data[s2--];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=s; k!=n; ++k)</span><br><span class="line">                data[k] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left+right+count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>补充<ul>
<li>取余和取模<ol>
<li>步骤<ul>
<li>c = a / b</li>
<li>r = a - c * b</li>
</ul>
</li>
<li>区别<ul>
<li>取余 c取的时候往0方向取</li>
<li>取模 c取的时候往负无穷方向取</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">1.Two Sum</a></h2><p><strong>题目大意</strong></p>
<p>给定一个整数数组和一个目标和，返回数组中加起来和是目标和的两个数的下标。</p>
<p><strong>思路</strong></p>
<p>如果暴力搜索的话，需要<script type="math/tex">O(n^2)</script>复杂度，可以遍历过程中，用map存储，key是值，value是下标。如果能够在map中找到(target-nums[i])，则将对应的下标和i返回即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cache;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cache.find(target - nums[i]) != cache.end())&#123;</span><br><span class="line">                res.push_back(cache[nums[i]]);</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            cache[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191.Number of 1 Bits"></a><a href="https://leetcode.com/problems/number-of-1-bits/description/" target="_blank" rel="noopener">191.Number of 1 Bits</a></h2><p><strong>题目大意</strong></p>
<p>给定一个32位无符号整数，求该整数二级制形式1的个数。</p>
<p><strong>思路</strong></p>
<p>遍历每一位，记录1的个数即可。</p>
<p>不要使用除操作，耗时较久，使用移位和与操作。</p>
<p>如果是有符号整数，可能会导致循环无法结束，可以左移1来遍历。</p>
<p>n &amp; (n-1)的操作能够将最右边的1变为0，可以将所有的1都变为0，需要的次数即为1的个数。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">                ++sum;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)&#123;</span><br><span class="line">            ++sum;</span><br><span class="line">            n = (n<span class="number">-1</span>) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consider signed int</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp; n)</span><br><span class="line">                ++sum;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="231-Power-of-Two"><a href="#231-Power-of-Two" class="headerlink" title="231.Power of Two"></a><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="noopener">231.Power of Two</a></h2><h2 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326.Power of Three"></a><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="noopener">326.Power of Three</a></h2><h2 id="342-Power-of-Four"><a href="#342-Power-of-Four" class="headerlink" title="342.Power of Four"></a><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="noopener">342.Power of Four</a></h2><p><strong>题目大意</strong></p>
<p>给定一个整数，求是否是2、3、4的整数次方。</p>
<p><strong>思路</strong></p>
<ol>
<li>基础思路<ul>
<li>一直除2(3,4)，直到有余数，判断此时n是否为1即可，如果不为1，说明不是整数次幂；</li>
</ul>
</li>
<li>不用循环的解法<ul>
<li>2<ul>
<li>n &amp; (n-1) == 0 则为整数幂</li>
<li>$2^{30}$%n == 0，因为$2^{30-k} 2^k = 2^{30}$，所以如果整除n，则为2的整数幂</li>
</ul>
</li>
<li>3 <ul>
<li>$3^{19}$%n == 0，因为$3^{19-k} 3^k = 3^{19}$，所以如果整除n，则为3的整数幂</li>
</ul>
</li>
<li>4<ul>
<li>满足三个条件 <ul>
<li>n &gt; 0</li>
<li>n &amp; (n - 1) == 0</li>
<li>(n - 1) % 3 == 0：在满足1、2前提下，只会出现2的整数幂和4的整数幂，而$4^n - 1 = (2^k-1)(2^k+1)$ ，而连续出现的三个数必定有一个是整除3的，而肯定不是$2^k$，$4^n-1$一定整除3，同时，$2^{2k+1}-1$必定不能整除3(<strong>为什么</strong>)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<p>2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n<span class="number">-1</span>) == <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(n%<span class="number">3</span>))&#123;</span><br><span class="line">            n = n / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n==<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">pow</span>(<span class="number">3</span>,<span class="number">19</span>);</span><br><span class="line">        <span class="keyword">return</span> ((n&gt;<span class="number">0</span>) &amp;&amp; ( a % n == <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(num % <span class="number">4</span>))&#123;</span><br><span class="line">            num = num / <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (num == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &gt; <span class="number">0</span> &amp;&amp; !(num &amp; (num - <span class="number">1</span>)) &amp;&amp; ((num - <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="523-Continuous-Subarray-Sum"><a href="#523-Continuous-Subarray-Sum" class="headerlink" title="523.Continuous Subarray Sum"></a><a href="https://leetcode.com/problems/continuous-subarray-sum/description/" target="_blank" rel="noopener">523.Continuous Subarray Sum</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>给定一个非负的数组，找到连续的子数组的和为k的整数倍</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>要求时间复杂度为O(n)</li>
<li>考虑如果0~i位置元素和除以k的余数为res，如果0~j位置元素和除以k的余数也为res，同时i+1&lt;j，那么i+1~j即为和可以整除k的子数组</li>
<li>考虑k为0的情况</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cache;</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">// 如果k==0，那么只有0才满足要求</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) res = sum;</span><br><span class="line">            <span class="keyword">else</span> res = sum % k;</span><br><span class="line">            <span class="keyword">if</span> (cache.find(res) != cache.end())&#123;</span><br><span class="line">                <span class="keyword">if</span> (cache[res]+<span class="number">1</span> &lt; i)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                cache[res] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135.Candy"></a><a href="https://leetcode.com/problems/candy/description/" target="_blank" rel="noopener">135.Candy</a></h2><p><strong>题目大意</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">There are N children standing in a line. Each child is assigned a rating value.</span><br><span class="line"></span><br><span class="line">You are giving candies to these children subjected to the following requirements:</span><br><span class="line"></span><br><span class="line">* Each child must have at least one candy.</span><br><span class="line">* Children with a higher rating get more candies than their neighbors.</span><br><span class="line">What is the minimum candies you must give?</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<ol>
<li>一个人分多少糖果取决于左边和右边的人，而左右边的人又有所依赖；</li>
<li>考虑每次只保证一侧是合法的，遍历两次即可<ul>
<li>第一遍，从左到右，如果右边大于左边则给右边糖果个数+1</li>
<li>第二遍，从右到左，如果左边大于右边则给左边糖果+1</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cache(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i!=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>])</span><br><span class="line">                cache[i] = cache[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i+<span class="number">1</span>] &amp;&amp; cache[i] &lt;= cache[i+<span class="number">1</span>])</span><br><span class="line">                cache[i] = cache[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(cache.begin(), cache.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="骰子和概率"><a href="#骰子和概率" class="headerlink" title="骰子和概率"></a>骰子和概率</h2><p><strong>题目大意</strong></p>
<ol>
<li>返回n个骰子随机投，每种和的概率</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>dfs</li>
<li>使用两个数组记录，n个骰子和的概率是在n-1个骰子和概率基础上计算的<ul>
<li>n个骰子，和为m的次数是n-1个骰子和为m-1、m-2…m-6的和</li>
<li>类似dp</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printProb</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = n * <span class="number">6</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cache(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxSum+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; ++i)</span><br><span class="line">        cache[flag][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    flag = <span class="number">1</span> - flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">2</span>; k&lt;=n; ++k)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;k; ++i)</span><br><span class="line">           cache[flag][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&lt;=k*<span class="number">6</span>; ++i)&#123;</span><br><span class="line">            cache[flag][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i &amp;&amp; j&lt;=<span class="number">6</span>; ++j)&#123;</span><br><span class="line">                cache[flag][i] += cache[<span class="number">1</span>-flag][i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">int</span> total = <span class="built_in">pow</span>(<span class="number">6</span>, n), p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n; i!=maxSum+<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; (<span class="keyword">double</span>)cache[<span class="number">1</span>-flag][i] / total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p += (<span class="keyword">double</span>)cache[<span class="number">1</span>-flag][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扑克牌的顺子"><a href="#扑克牌的顺子" class="headerlink" title="扑克牌的顺子"></a><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">扑克牌的顺子</a></h2><p><strong>题目大意</strong></p>
<p>判断抽取的牌是否为顺子，A为1，J为11，Q为12，K为13，大小王是0，可以替代任何数</p>
<p><strong>思路</strong></p>
<ol>
<li>先排序，判断0的个数，和gap的个数，如果gap的个数大于0的个数，则返回false</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(numbers.begin(), numbers.end());</span><br><span class="line">        <span class="keyword">int</span> zeroNum = <span class="number">0</span>, gapNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!= numbers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>)</span><br><span class="line">                zeroNum++;</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span> &amp; numbers[i<span class="number">-1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i<span class="number">-1</span>] == numbers[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    gapNum += numbers[i] - numbers[i<span class="number">-1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zeroNum &gt;= gapNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73.Set Matrix Zeroes"></a><a href="https://leetcode.com/problems/set-matrix-zeroes/description/" target="_blank" rel="noopener">73.Set Matrix Zeroes</a></h2><p><strong>题目大意</strong></p>
<p>给定一个二维数组，将有0的位置的行和列置为0</p>
<p><strong>思路</strong></p>
<ol>
<li>遍历每一行，记录每一个列出现0的位置，同时记录该行是否有0，如果有零，遍历完该行，将改行置为0</li>
<li>最后将记录的列置为0</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size(), n=matrix[<span class="number">0</span>].size(), flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; zeros;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    zeros.insert(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k!=n; ++k)</span><br><span class="line">                    matrix[i][k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=zeros.begin(); it!=zeros.end(); ++it)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=m; ++j)</span><br><span class="line">                matrix[j][*it] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239.Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/description/" target="_blank" rel="noopener">239.Sliding Window Maximum</a></h2><p><strong>题目大意</strong></p>
<p>给定一个数组和一个窗口大小，问当窗口在数组上滑动时，返回每个窗口最大值组成的数组。</p>
<p><strong>思路</strong></p>
<p>剑指offer上的原题啊</p>
<ol>
<li>暴力法，暴力滑过各个窗口取得最大值，时间复杂度是O(nk)，每个窗口计算时重复比较了很多数</li>
<li>堆<ul>
<li>用一个堆记录当前值的排序顺序，每滑动一个窗口，往堆中插入一个数，堆顶元素即使当前窗口的最大值</li>
<li>问题在于，如何弹出已经超过该窗口的元素。堆中元素包含下标，如果堆顶元素的小标超过了当前窗口的最小小标值，那么就pop掉。</li>
<li>时间复杂度O(nlogk)</li>
</ul>
</li>
<li>双端队列<ul>
<li>队列中存储的是降序排列的元素，自然队列头部是当前窗口的最大值，如果当前要插入的元素大于尾部数据，则弹出尾部数据，直到找到比该元素大的数插入；</li>
<li>问题在于，如何判断某个元素是否已经超过了该窗口，此时，可以考虑队列中存储下标，如果下标超过了当前窗口的最小下标，那么就需要pop掉；</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            q.push(make_pair(nums[i], i));</span><br><span class="line">            <span class="keyword">while</span> (q.top().second &lt; res.size())</span><br><span class="line">                q.pop();</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &gt;= k) res.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 如果队首元素超过了结果的长度(第几个窗口)，那么需要弹出</span></span><br><span class="line">            <span class="keyword">if</span> (!q.empty() &amp;&amp; q.front() &lt; res.size()) q.pop_front();</span><br><span class="line">            <span class="comment">// 维护双端队列是一个降序，front位置永远是当前窗口的最大值</span></span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i]) q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=k<span class="number">-1</span>) res.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray/description/" target="_blank" rel="noopener">152. Maximum Product Subarray</a></h2><p><strong>题目大意</strong></p>
<p>给定一个数组，返回连续子数组的最大积</p>
<p><strong>思路</strong></p>
<p>只要中间没有零，那么连续子数组越长越好，同时恰好使得子数组负数个数为偶数，此时最大；</p>
<p>front和back记录遍历过程中正向遍历和逆向遍历的每一步的最大值，除非遇到零。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">1</span>, back = <span class="number">1</span>, res = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)&#123;</span><br><span class="line">            front *= nums[i];</span><br><span class="line">            back *= nums[n-i<span class="number">-1</span>];</span><br><span class="line">            res = max(res, max(front, back));</span><br><span class="line">            front = front == <span class="number">0</span> ? <span class="number">1</span> : front;</span><br><span class="line">            back = back == <span class="number">0</span> ? <span class="number">1</span> : back;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="math"><a href="#math" class="headerlink" title="math"></a>math</h1><h2 id="233-Number-of-Digit-One"><a href="#233-Number-of-Digit-One" class="headerlink" title="233.Number of Digit One"></a><a href="https://leetcode.com/problems/number-of-digit-one/description/" target="_blank" rel="noopener">233.Number of Digit One</a></h2><ol>
<li>题目大意<ul>
<li>给定一个数n，求出1-n所有数中1出现的个数</li>
</ul>
</li>
<li>思路<ul>
<li>考虑每一位上为1的情况</li>
<li>例如考虑百位为1的情况，n为32198，a为321，b为98<ul>
<li>如果百位(a%10) &gt;=2, 那么有(a/10+1)*m个1；</li>
<li>如果(a%10)==1，那么(a/10*m)+b+1个1；</li>
<li>如果(a%10)==0, 那么(a/10*m)个1；</li>
<li>综合起来(a+8)/10*m+(a%10==1?b+1:0);</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> m=<span class="number">1</span>; m&lt;=n; m*=<span class="number">10</span>)&#123;</span><br><span class="line">            a = n / m;</span><br><span class="line">            b = n % m;</span><br><span class="line">            count += (a+<span class="number">8</span>)/<span class="number">10</span>*m + ((a%<span class="number">10</span>==<span class="number">1</span>)?b+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69.Sqrt(x)"></a><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">69.Sqrt(x)</a></h2><p><strong>题目大意</strong></p>
<p>求一个数的开根号，返回floor(sqrt(x))</p>
<p><strong>思路</strong></p>
<ol>
<li>二分法</li>
<li>牛顿法<ul>
<li>$f(x) = f(x_k) + f^-(x_k)(x - x_k)$</li>
<li>$x = x_k - \frac{f(x_k)}{f^-(x_k)}$</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> low = <span class="number">0</span>, high = x, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// mid * mid 考虑越界问题</span></span><br><span class="line">            <span class="keyword">if</span> (mid * mid &lt; x)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &gt; x)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = x;</span><br><span class="line">        <span class="keyword">while</span> (res*res &gt; x)&#123;</span><br><span class="line">            res = (res + x / res) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50.Pow(x, n)"></a><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">50.Pow(x, n)</a></h2><p><strong>题目大意</strong></p>
<p>实现标准库中的pow运算。</p>
<p><strong>思路</strong></p>
<p>考虑一些边界条件以及优化</p>
<ol>
<li>指数为负的情况；</li>
<li>底为零指数为负的情况，不能做除法；</li>
<li>int的指数变负为正时，考虑最大的负数变为整数会越界；</li>
<li>提高效率，将$2^{2k+1}$装换为$2^k$的平方乘2</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// float和double类型的比较不能直接比较</span></span><br><span class="line">        <span class="comment">// 考虑底为零的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((x - <span class="number">0.0</span>) &lt; <span class="number">0.0000001</span> &amp;&amp; (x - <span class="number">0.0</span>) &gt; <span class="number">-0.000000001</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 考虑为负的情况</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            <span class="comment">// 考虑越界</span></span><br><span class="line">            <span class="keyword">if</span> (n == INT_MIN)&#123;</span><br><span class="line">                res *= x;</span><br><span class="line">                n += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n)&#123;</span><br><span class="line">            <span class="comment">// &amp; 和 移位运算替代取余和除法</span></span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">                res *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="372-Super-Pow"><a href="#372-Super-Pow" class="headerlink" title="372.Super Pow"></a><a href="https://leetcode.com/problems/super-pow/description/" target="_blank" rel="noopener">372.Super Pow</a></h2><p><strong>题目大意</strong></p>
<p>计算$a^b$%1337, b非常大，用vector的形式给出。</p>
<p><strong>思路</strong></p>
<ol>
<li><code>ab % k = (a % k)(b % k) % k</code></li>
<li>f(a,b)表示$a^b$%k, 则f( f( a, b / 10), 10) * f(a, b % 10) % k，这样就转化为一个递归问题了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (b.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = b.back();</span><br><span class="line">        b.pop_back();</span><br><span class="line">        <span class="keyword">return</span> mypow(superPow(a, b), <span class="number">10</span>) * mypow(a, x) % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 相当于拆分到每个底相乘，每个底都对base取模</span></span><br><span class="line">        a %= base;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=k; ++i)&#123;</span><br><span class="line">            res = (res * a) % base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=3&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">约瑟夫环</a></h2><p><strong>题目大意</strong></p>
<p>0-n-1个人围成一个圈，从0喊到m-1，m-1的人被淘汰。然后从下一个人开始继续，请问最后活下来的是哪个人</p>
<p><strong>思路</strong></p>
<p>推导</p>
<ol>
<li>f(n,m)表示n个小朋友，第m个人出局剩下的最后一个人;g(n-1, m)表示淘汰了f(n,m)中第m个人后按照规则剩下的那个人；</li>
<li>f(n,m) = g(n-1,m) = (f(n-1, m) + m) % n 下标差了m</li>
</ol>
<p>递推公式<code>f(n,m) = (f(n-1, m) + m)% n</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)</span><br><span class="line">            last = (last + m ) % i;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="382-Linked-List-Random-Node"><a href="#382-Linked-List-Random-Node" class="headerlink" title="382.Linked List Random Node"></a><a href="https://leetcode.com/problems/linked-list-random-node/description/" target="_blank" rel="noopener">382.Linked List Random Node</a></h2><p><strong>题目大意</strong></p>
<p>一个非常大的链表，随机返回链表上的一个节点值，要求O(n)</p>
<p><strong>思路</strong></p>
<p>蓄水池算法。</p>
<ul>
<li>需要选取k个随机数<ul>
<li>选择前k个数，对于第i个来的数，以$\frac{k}{k+i}$的概率是否选择该数，然后再以$\frac{1}{k}$的概率替换池子中的一个数</li>
<li>直到i到最后一个数，池子里的数就是随机出来的k个数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">ListNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** @param head The linked list's head.</span></span><br><span class="line"><span class="comment">        Note that the head is guaranteed to be not null, so it contains at least one node. */</span></span><br><span class="line">    Solution(ListNode* head) &#123;</span><br><span class="line">        root = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random node's value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode* tmp = root;</span><br><span class="line">        <span class="keyword">int</span> res = tmp-&gt;val, count = <span class="number">1</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span> (rand() % (<span class="number">1</span> + count++) == <span class="number">0</span>)&#123;</span><br><span class="line">                res = tmp-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a><a href="https://leetcode.com/problems/divide-two-integers/description/" target="_blank" rel="noopener">29. Divide Two Integers</a></h2><p><strong>题目大意</strong></p>
<p>给定两个整数，输出除的结果，要求不能使用加、减和取余操作</p>
<p><strong>思路</strong></p>
<p>整体思路是判断结果正负号，将负数变为整数，使用移位和减法操作实现除法。</p>
<ol>
<li>溢出<ol>
<li>因为负数要换成正数，所以针对出现负数的情况讨论溢出问题</li>
</ol>
</li>
<li>除数较小时使用移位操作加速计算<ol>
<li>除数左移时候也需要考虑是否会溢出的问题</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 几种可能越界的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN &amp;&amp; divisor == INT_MIN)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (divisor == INT_MIN)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN &amp;&amp; divisor == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> is_minus = <span class="number">0</span>, res = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (divisor &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            is_minus = ~is_minus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dividend &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 考虑被除数的越界问题</span></span><br><span class="line">            <span class="keyword">if</span> (dividend == INT_MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                dividend += divisor;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            dividend = - dividend;</span><br><span class="line">            is_minus = ~is_minus;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (dividend &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = divisor;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 使用移位加速计算</span></span><br><span class="line">            <span class="keyword">while</span> (dividend &gt;&gt; <span class="number">1</span> &gt; t)&#123;</span><br><span class="line">                t = t &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                count = count &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dividend -= t;</span><br><span class="line">            res += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能整除 取整</span></span><br><span class="line">        <span class="keyword">if</span> (dividend &lt; <span class="number">0</span>)</span><br><span class="line">            res--;</span><br><span class="line">        <span class="comment">// 负数 返回负数</span></span><br><span class="line">        <span class="keyword">if</span> (is_minus)</span><br><span class="line">            <span class="keyword">return</span> -res;</span><br><span class="line">        <span class="comment">// 整数 直接返回</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="两个数相除返回字符串形式"><a href="#两个数相除返回字符串形式" class="headerlink" title="两个数相除返回字符串形式"></a><a href="">两个数相除返回字符串形式</a></h2><p><strong>题目大意</strong></p>
<p>两个整数相除，返回字符串形式，循环小数用括号+循环位替代。</p>
<p><code>4 / 2 -&gt; 2 , 2 / 4 -&gt; 0.5 , 1 / 3 -&gt; 0.(3)</code></p>
<p><strong>思路</strong></p>
<p>整数部分直接除取整，小数部分乘10除取整，余数再循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">divide2int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> zs, xs, last, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == INT_MIN &amp;&amp; b == <span class="number">-1</span>)&#123;</span><br><span class="line">        res = to_string(INT_MAX);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get zhengshu</span></span><br><span class="line">    zs = a / b;</span><br><span class="line">    res += to_string(zs);</span><br><span class="line">    a = a - b * zs;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 需要计算小数部分</span></span><br><span class="line">    last = a;</span><br><span class="line">    res += <span class="string">'.'</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cache;</span><br><span class="line">    <span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &amp;&amp; count &lt; <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="comment">// 有循环小数</span></span><br><span class="line">        <span class="keyword">if</span> (cache.find(a) != cache.end())&#123;</span><br><span class="line">            tmp = <span class="built_in">string</span>(tmp.begin(), tmp.begin()+cache[a]) + <span class="string">'('</span> + <span class="built_in">string</span>(tmp.begin()+cache[a], tmp.end()) + <span class="string">')'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[a] = count;</span><br><span class="line">        xs = a * <span class="number">10</span> / b;</span><br><span class="line">        a = a * <span class="number">10</span> % b;</span><br><span class="line">        count++;</span><br><span class="line">        tmp += to_string(xs);</span><br><span class="line">        last = a;</span><br><span class="line">    &#125; </span><br><span class="line">    res += tmp;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><h2 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34.Search for a Range"></a><a href="https://leetcode.com/problems/search-for-a-range/description/" target="_blank" rel="noopener">34.Search for a Range</a></h2><p><strong>题目大意</strong></p>
<p>给定一个升序数组和一个目标值，找到目标所在的区间，如果不存在就返回[-1,-1]</p>
<p><strong>思路</strong></p>
<p>二分搜索，改变=的位置即可找到上界和下界；</p>
<p>使用low&lt;=high的条件，low是左边的位置，high是右边的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> low = binarySearch(nums, target, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (low &gt;=<span class="number">0</span> &amp;&amp; low &lt; nums.size() &amp;&amp; nums[low] == target)</span><br><span class="line">            res[<span class="number">0</span>] = low;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> high = binarySearch(nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (high &gt;= <span class="number">0</span> &amp;&amp; high &lt; nums.size() &amp;&amp; nums[high] == target)</span><br><span class="line">            res[<span class="number">1</span>] = high;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>, mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((left &amp;&amp; nums[mid] &gt;= target) || (!left &amp;&amp; nums[mid] &gt; target))</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// low是高一位的点，high是低一位的点</span></span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">return</span> low;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[low] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>] = low;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; nums.size() &amp;&amp; nums[low] == target) low++;</span><br><span class="line">        res[<span class="number">1</span>] = low<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153.Find Minimum in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" target="_blank" rel="noopener">153.Find Minimum in Rotated Sorted Array</a></h2><h2 id="154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="154.Find Minimum in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" target="_blank" rel="noopener">154.Find Minimum in Rotated Sorted Array II</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>在一个没有重复数字的循环排序数组里，找到最小的数；</li>
<li>在一个有重复数字的循环排序数组里，找到最小的数；</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>使用二分查找；</li>
<li>将mid和high位置比较；</li>
<li>如果是有重复数字，将high自减；</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123; <span class="comment">// 正常情况下，查找会用=的条件，然后low指向恰好大的位置，high指向恰好小的位置；</span></span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[high]) <span class="comment">//不能和low比较，因为mid取值时是取整，可能会取到和low相同的值,此时比值只会相等，</span></span><br><span class="line">                                        <span class="comment">//但是却有两种情况[1,2]和[2,1]，无法区分</span></span><br><span class="line">                high = mid; <span class="comment">//此处不能+1,可能mid处是最小值</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>; <span class="comment">// low如果不加1的话最后不能收敛</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[high];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>, mid = <span class="number">0</span>; <span class="comment">// 内置类型在函数内部不会进行初始化</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[high])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[high];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162.Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element/description/" target="_blank" rel="noopener">162.Find Peak Element</a></h2><p><strong>题目大意</strong></p>
<p>给定一个山峰数组，即先升序后降序。求数组的山峰。</p>
<p><strong>思路</strong></p>
<p>二分</p>
<ol>
<li>nums[mid] &lt; nums[mid+1] : low = mid + 1 (因为循环条件是low&lt;high，所以只有low==high时mid才会越界，此时已经跳出循环了)</li>
<li>nums[mid] &gt; nums[mid+1] : high = mid</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nums.push_back(INT_MIN);</span></span><br><span class="line">        <span class="keyword">int</span> low =<span class="number">0</span>, high = nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 只有low和high相等时才会出现mid=high的情况，此时已经跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid+<span class="number">1</span>])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33.Search in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">33.Search in Rotated Sorted Array</a></h2><h2 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81.Search in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/" target="_blank" rel="noopener">81.Search in Rotated Sorted Array II</a></h2><p><strong>题目大意</strong></p>
<p>在一个循环排序数组中，查找是否存在某个数。</p>
<p><strong>思路</strong></p>
<p>二分</p>
<ol>
<li>nums[low] &lt;= nums[mid] 此时 low到mid是递增区间<ol>
<li>如果 nums[low] &lt;= target &lt; nums[mid] : high = mid - 1</li>
<li>low = mid + 1 （此时，target位于mid+1和high之间）</li>
</ol>
</li>
<li>nums[low] &gt; nums[mid] 此时 mid到high是递增区间<ol>
<li>如果 nums[mid] &lt; target &lt;= nums[high] : low = mid + 1</li>
<li>high = mid - 1;</li>
</ol>
</li>
<li>如果有重复的数，导致 nums[mid] == nums[low] == nums[high] 无法判断，则low++ high— 继续循环</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 在没有重复情况下，nums[mid]==nums[low]意味着收敛到low和mid之间了，不应该再去mid和high之间了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[low])&#123;</span><br><span class="line">                <span class="comment">// 考虑target和边界相等的情况，此时target就是落在这个区间内</span></span><br><span class="line">                <span class="keyword">if</span> (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high])</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[low] &amp;&amp; nums[mid] == nums[high]) &#123;</span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[low] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high])</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Bit-Operation"><a href="#Bit-Operation" class="headerlink" title="Bit Operation"></a>Bit Operation</h1><h2 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136.Single Number"></a><a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener">136.Single Number</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>给定一个数组，只有一个数出现一次，其他都出现两次，返回只出现一次的数</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>异或</li>
<li>相同的数异或为0，最后只剩下单独的数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="137-Single-Number-II"><a href="#137-Single-Number-II" class="headerlink" title="137.Single Number II"></a><a href="https://leetcode.com/problems/single-number-ii/description/" target="_blank" rel="noopener">137.Single Number II</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>给定一个数组，只有一个数出现一次，其他都出现三次，返回出现一次的数</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>对每一位进行计数，只需要 00、01和10即可，循环为00-01-10-00</li>
<li>对于出现三次的位一定会被消除，所以，最后剩下的就是只出现一次的数</li>
<li>只有三种情况，只需要ones和twos两位即可满足计数要求</li>
<li>更新规则<ol>
<li>ones ^ nums[i]，当nums[i]是1时，ones需要更新，此时，如果twos == 1，ones更新为0(10-00)，否则ones更新为1(00-01)</li>
<li>twos ^ nums[i]，当nums[i]是1时，twos需要更新，此时，如果ones == 0，twos变为1，否则不变</li>
</ol>
</li>
<li>对于出现次数是5的情况同样处理</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            ones = ones^nums[i] &amp; ~twos;</span><br><span class="line">            twos = twos^nums[i] &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=<span class="number">32</span>; ++i)&#123;</span><br><span class="line">            tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">                tmp += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res |= (tmp % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="260-Single-Number-III"><a href="#260-Single-Number-III" class="headerlink" title="260.Single Number III"></a><a href="https://leetcode.com/problems/single-number-iii/description/" target="_blank" rel="noopener">260.Single Number III</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>给定一个数组，有两个数字出现次数是1次，其他数字均出现两次，求出现1次的两个数</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>先异或，找到两个出现次数为1的数字的不同的位</li>
<li>找到两个数字某个不同的位(diff &amp; ~(diff - 1))</li>
<li>根据这个位将原数组分为两部分，必然两个数会分开</li>
<li>两个数组分别异或，找到两个出现1次的数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)</span><br><span class="line">            diff ^= nums[i];</span><br><span class="line">        diff &amp;= ~(diff<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &amp; diff)</span><br><span class="line">                res[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[<span class="number">1</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151.Reverse Words in a String"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string/description/" target="_blank" rel="noopener">151.Reverse Words in a String</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>给定一个包含词的字符串，将词顺序翻转</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>三个指针i，j，l。i是头指针，j是要将nums[i]移动到的位置，l是上一次的位置，翻转的时候要用</li>
<li>首先要去除多余的空格</li>
<li>如果前面有word需要加空格</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, l=<span class="number">0</span>, n=s.size();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;n &amp;&amp; s[i]==<span class="string">' '</span>) i++;</span><br><span class="line">            <span class="keyword">if</span> (i==n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (count) s[j++] = <span class="string">' '</span>;</span><br><span class="line">            l = j;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;n &amp;&amp; s[i]!=<span class="string">' '</span>)&#123;</span><br><span class="line">                s[j++] = s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            reverse_str(s, l, j<span class="number">-1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        s.resize(j);</span><br><span class="line">        reverse_str(s, <span class="number">0</span>, j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse_str</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i &gt;= s.size() || j&lt;<span class="number">0</span> || j &gt;=s.size())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">char</span> t = s[i];</span><br><span class="line">            s[i++] = s[j];</span><br><span class="line">            s[j--] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">左旋转字符串</a></h2><p><strong>题目大意</strong></p>
<ol>
<li>给定一个字符串和n，将字符串前n位左移。如给定abcde和2，则返回cdeab</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li>可以理解为，前n个字符是一个单词，后面的字符为另一个单词，相当于翻转单词的问题</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.size()&gt;<span class="number">0</span> &amp;&amp; n&gt;<span class="number">0</span> &amp;&amp; n&lt;str.size())&#123;</span><br><span class="line">            reverseString(str, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">            reverseString(str, n, str.size()<span class="number">-1</span>);</span><br><span class="line">            reverseString(str, <span class="number">0</span>, str.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = input[left];</span><br><span class="line">            input[left++] = input[right];</span><br><span class="line">            input[right--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="http://www.lintcode.com/zh-cn/problem/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列</a></h2><p><strong>题目大意</strong></p>
<p>给定两个字符串，找到最长公共子序列。子序列的不一定需要是连续的</p>
<p><strong>思路</strong></p>
<p>动态规划，<code>dp[i][j]</code>记录s前i个字符串和t前j个字符串的最长公共子序列；</p>
<ol>
<li><code>dp[i][j]=dp[i-1][j-1] if(A[i-1]==B[j-1])</code></li>
<li><code>dp[i][j]=max(dp[i-1][j], dp[i][j-1]) if (A[i-1] != B[j-1])</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param A: A string</span></span><br><span class="line"><span class="comment">     * @param B: A string</span></span><br><span class="line"><span class="comment">     * @return: The length of longest common subsequence of A and B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> &amp;A, <span class="built_in">string</span> &amp;B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)&#123;</span><br><span class="line">                <span class="comment">// 注意下标和dp下标区别</span></span><br><span class="line">                <span class="keyword">if</span> (A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a><a href="http://www.lintcode.com/zh-cn/problem/longest-common-substring/" target="_blank" rel="noopener">最长公共子串</a></h2><p><strong>题目大意</strong></p>
<p>给定两个字符串s和t，求s和t的最大公共子串的长度。</p>
<p><strong>思路</strong></p>
<p>同上使用动态规划，<code>dp[i][j]</code>记录s前i个字符串和t前j个字符串的最长公共子串；</p>
<ol>
<li><code>dp[i][j]=dp[i-1][j-1] if(A[i-1]==B[j-1])</code></li>
<li><code>dp[i][j]=0 if (A[i-1] != B[j-1])</code></li>
</ol>
<p>同时，使用res记录全程最大的子串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param A: A string</span></span><br><span class="line"><span class="comment">     * @param B: A string</span></span><br><span class="line"><span class="comment">     * @return: the length of the longest common substring.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(<span class="built_in">string</span> &amp;A, <span class="built_in">string</span> &amp;B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = max(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322.Coin Change"></a><a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener">322.Coin Change</a></h2><p><strong>题目大意</strong></p>
<p>给定一些钱币面值和总钱数，求能够凑出总钱数的最小钱币数。</p>
<p><strong>思路</strong></p>
<p>动态规划，dp[count] = min(dp[count-1], dp[count-2]…) + 1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> coins_len = coins.size(), cur = INT_MAX, last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=coins_len; ++j)&#123;</span><br><span class="line">                last = i - coins[j];</span><br><span class="line">                <span class="keyword">if</span> (last &gt;= <span class="number">0</span> &amp;&amp; dp[last] &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">                    tmp = min(tmp, dp[last]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp != INT_MAX)</span><br><span class="line">                dp[i] = tmp + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62.Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="noopener">62.Unique Paths</a></h2><p><strong>题目大意</strong></p>
<p>给定一个m n的矩阵，求左上角到达右下角的路径数量有多少</p>
<p><strong>思路</strong></p>
<p>动态规划，<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=m; ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=n; ++j)</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i!=m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j!=n; ++j)</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416.Partition Equal Subset Sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="noopener">416.Partition Equal Subset Sum</a></h2><p><strong>题目大意</strong></p>
<p>给定一个(非空、正数)数组，判断是否能将数组分为两个部分，两个部分和相等。</p>
<p><strong>思路</strong></p>
<p>使用动态规划，数组和为sum，则dp[i]记录是否有一部分元素和为i，返回dp[sum/2]即可。(如果数组有负数，那么dp数组就没有范围限制了)</p>
<p>dp[0] = true, 如果dp[i-num[k]]为true，则dp[i] = true</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(sum+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 必须从sum开始，否则会nums[i]会被重复使用，比如2、4、6。。。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=sum; j&gt;<span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j-nums[i] &gt;=<span class="number">0</span> &amp;&amp; dp[j-nums[i]])</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="698-Partition-to-K-Equal-Sum-Subsets"><a href="#698-Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="698.Partition to K Equal Sum Subsets"></a><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/" target="_blank" rel="noopener">698.Partition to K Equal Sum Subsets</a></h2><p><strong>题目大意</strong></p>
<p>给定一个数组，判断是否能分成和相等的k部分。</p>
<p><strong>思路</strong></p>
<p>使用dfs，先找到一组元素使得和为sum/k，然后再递归剩下的元素是否能分为k-1组，递归结束条件为k==1(存在k-1组和为sum / k的数组那么剩下的一组必然为sum / k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum = sum / k;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, visited, <span class="number">0</span>, <span class="number">0</span>, k, sum);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> start, <span class="keyword">int</span> sum, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 新的part，从头开始考虑</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> dfs(nums, visited, <span class="number">0</span>, <span class="number">0</span>, k<span class="number">-1</span>, target);</span><br><span class="line">        <span class="comment">// 找到和为target的数组，如果前面的不可以，则后面不需要再考虑这些数了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(nums, visited, i+<span class="number">1</span>, sum+nums[i], k, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5.Longest Palindromic Substring"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">5.Longest Palindromic Substring</a></h2><p><strong>题目大意</strong></p>
<p>求字符串的最长回文字符串。</p>
<p><strong>思路</strong></p>
<ol>
<li>动态规划<ol>
<li>暴力法：遍历所有子串，判断是否为回文子串。在判断子串是否为回文子串过程中，有很多重复的判断，此处可以用动态规划</li>
<li><code>dp[i][j]</code>表示i到j是否为回文串，此时<code>dp[i][j]</code>可以通过<code>dp[i+1][j-1]</code>和判断s[i] == s[j]来计算<ol>
<li>提前计算<code>dp[i][i]</code>和<code>dp[i][i+1]</code>位置的对称性</li>
<li>奇数和偶数回文串两种情况</li>
</ol>
</li>
<li>在此过程中，记录最长的回文串的开始位置和长度</li>
</ol>
</li>
<li>Manacher算法<ol>
<li><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">https://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></li>
<li>将字符串<code>aaxsd</code>变成<code>^#a#a#x#s#d#$</code>，#的目的是将奇数长度和偶数长度的回文字符串都变成奇数长度的回文字符串，^和$是为了防止越界问题。</li>
<li>使用p[i] 记录i位置回文串的单边长度，在计算过程中，可以利用对称性简化计算<ol>
<li>中心位置是c，对称半径是r</li>
<li>如果i位于半径r内，可以通过对称位置计算<ol>
<li>如果对称位置的回文长度没有超过r-i那么p[i] = p[mirror_i]</li>
<li>如果超过了，则p[i] = r-c，同时从r位置继续判断是否为回文串</li>
</ol>
</li>
<li>如果在半径外，直接计算</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">1</span>, start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n &amp;&amp; s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (max_len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    max_len = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">2</span>; j&lt;n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i]==s[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &gt;= max_len)&#123;</span><br><span class="line">                        start = i;</span><br><span class="line">                        max_len = j - i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> t = preprocess(s);</span><br><span class="line">        <span class="keyword">int</span> len = t.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(len);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=len; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> mirror = <span class="number">2</span> * c - i;</span><br><span class="line">            </span><br><span class="line">            p[i] = r &gt; i ? min(r-i, p[mirror]) : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (t[i+<span class="number">1</span>+p[i]] == t[i<span class="number">-1</span>-p[i]])</span><br><span class="line">                p[i]++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (p[i] + i &gt; r)&#123;</span><br><span class="line">                c = i;</span><br><span class="line">                r = p[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max_pos=<span class="number">0</span>, max_len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (max_len &lt; p[i])&#123;</span><br><span class="line">                max_len = p[i];</span><br><span class="line">                max_pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr((max_pos<span class="number">-1</span>-max_len)/<span class="number">2</span>, max_len);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">preprocess</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"@"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=s.size(); ++i)&#123;</span><br><span class="line">            res += <span class="string">"#"</span>;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="string">"#$"</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300.Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">300.Longest Increasing Subsequence</a></h2><p><strong>题目大意</strong></p>
<p>给定一个数组，找到最长的递增子序列。</p>
<p><strong>思路</strong></p>
<ol>
<li>动态规划，$O(n^2)$时间复杂度，$O(n^2)$空间复杂度<ol>
<li><code>dp[i]</code>表示前 i 个数的最长递增子序列</li>
<li>每次更新时，遍历0到 i-1的数，如果比nums[j]大，则可以构成新的递增子序列，序列长度为dp[j]+1，将最大值作为dp[i]</li>
<li>遍历过程中记录最大值</li>
</ol>
</li>
<li>$O(nlogn)$时间复杂度，$O(n)$空间复杂度<ol>
<li>遍历过程中维护一个S数组，数组维护的是各个长度LIS的最小尾部</li>
<li>遍历数组，找到S中不小于nums[i]的最小值，<ol>
<li>如果找到了，则替换该值，</li>
<li>如果比S中最大值还大，直接append即可</li>
</ol>
</li>
<li>最后，S的长度就是最长递增子序列的长度</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), len, max_len=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    len = max(len, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = len + <span class="number">1</span>;</span><br><span class="line">            max_len = max(dp[i], max_len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nlogn</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.begin(), tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            tmp = lower_bound(nums.begin(), it, nums[i]);</span><br><span class="line">            *tmp = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (tmp == it)&#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> it - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="674-Longest-Continuous-Increasing-Subsequence"><a href="#674-Longest-Continuous-Increasing-Subsequence" class="headerlink" title="674.  Longest Continuous Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/" target="_blank" rel="noopener">674.  Longest Continuous Increasing Subsequence</a></h2><p><strong>题目大意</strong></p>
<p>给定一个数组，找到最长的连续升序序列</p>
<p><strong>思路</strong></p>
<p>遍历，因为是连续序列，所以尽可能记录升序序列的长度，如果断了就重新计数，在此过程中记录最大值即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">1</span>, len=<span class="number">1</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i+<span class="number">1</span>])</span><br><span class="line">                len++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            max_len = max(max_len, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198.House Robber"></a><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">198.House Robber</a></h2><p><strong>题目大意</strong></p>
<p>给定一个正数数组，要求相邻的数不能同时取得，问选取的数和最大是多少。</p>
<p><strong>思路</strong></p>
<ol>
<li><code>dp[i] = max(dp[i-1], dp[i-2]+nums[i])</code>动态规划值</li>
<li>只需要用a、b两个数，存储奇数和偶数位置的最大结果 <code>a = max(a+nums[i], b)</code> &amp;&amp; <code>b = max(b+nums[i], b)</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>)&#123;</span><br><span class="line">                a = max(b, a+nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b = max(a, b+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-2</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a><a href="https://leetcode.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">213. House Robber II</a></h2><p><strong>题目大意</strong></p>
<p>给定一个正数数组，要求相邻的数以及首尾的数不能同时取得，问选取的数和最大是多少。</p>
<p><strong>思路</strong></p>
<p>乍看上去，首尾的情况不太好处理。如果分两次遍历，一次掐头，一次 去尾。取两次的最大值即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">// 对于数组长度为1的情况后面的函数无法处理，需要简单处理下边界</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> max(find(nums, <span class="number">0</span>, n<span class="number">-1</span>), find(nums, <span class="number">1</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=s; i&lt;e; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>)&#123;</span><br><span class="line">                a = max(a+nums[i], b);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b = max(b+nums[i], a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337. House Robber III"></a><a href="https://leetcode.com/problems/house-robber-iii/description/" target="_blank" rel="noopener">337. House Robber III</a></h2><p><strong>题目大意</strong></p>
<p>小区的布局变成了二叉树的形式，父亲和孩子不能同时被偷。问最多能偷多少。</p>
<p><strong>思路</strong></p>
<p>相同的思路，每个位置有被偷或者不被偷两种情况。<code>res[0] = left[1] + right[1] + root-&gt;val</code>和<code>res[1] = max(left[0], left[1]) + max(right[0], right[1])</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max(res.first, res.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dfs(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; left = dfs(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; right = dfs(root-&gt;right);</span><br><span class="line">        res.first = left.second + right.second + root-&gt;val;</span><br><span class="line">        res.second = max(left.first, left.second) + max(right.first, right.second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock</a></h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 1, 5, 3, 6, 4]</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</span><br></pre></td></tr></table></figure>
<p><strong>题目大意</strong></p>
<p>给定一个数组，下标为i的数表示股票在第i天的价格。如果最多只能操作一次（买、卖一次），请问最多能挣多少钱。</p>
<p><strong>思路</strong></p>
<p>从头到尾遍历，<code>dp[i-1][0]</code>为前 i-1 天的最低价位，如果第i天价位不高于<code>dp[i-1][0]</code>, 则<code>dp[i][0] = prices[i]</code>；</p>
<p>否则，计算出第i天卖出的最大利润 <code>profit=prices[i] - dp[i-1][0]</code>，前i天能达到的最大利润为<code>dp[i][1] = max(profit, dp[i-1][1])</code>。</p>
<p>其实因为这个情况很简单，所以可以考虑不用数组去做，只需要一个记录之前的股票最小值，以及之前的利润最大值即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>, last=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (last &lt; prices[i])&#123;</span><br><span class="line">                res = max(res, prices[i] - last);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/#/description" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II</a></h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p><strong>题目大意</strong></p>
<p>可以完成尽可能多次的交易，请问最大获益是多少。</p>
<p><strong>思路</strong></p>
<p>这种情况很简单，用贪心去做，只要能赚钱我就交易即可。</p>
<p>即，只要上一天的价格低于当天的价格，就在上一天买入在当天卖出。</p>
<p>两种情况：</p>
<p>若第三天的价格高于当天价格，那么在今天买入第三天卖出，效果和贪心是一样的；</p>
<p>若第三天价格低于当天价格，那么就应该在当天卖出；所以应该用贪心的思路做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>, last=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (last &lt; prices[i])&#123;</span><br><span class="line">                res += prices[i]-last;</span><br><span class="line">                last = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/#/description" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III</a></h2><p><strong>题目大意</strong></p>
<p>只能完成两次交易，那么最大收益是多少。</p>
<p><strong>思路</strong></p>
<p>第一种思路：</p>
<p>想了很久，画了一条曲线，其实两次交易相当于在中间找到一个局部最高点，在这个最高点后面又找到一个局部最低点，而我们可以去遍历所有的数，将每个数作为最高点（前一次卖出）和最低点（后一次买入）的分割点，在遍历的过程中记录收益的最大值即可。</p>
<p>思路很简单，分割以后，分别用题I的解法去做就可以了。但是，此时会重复遍历很多次，第i天为分割点，为了找到第一次交易的最大收益，需要遍历前i天，而这前i天中有i-1天是上一次已经遍历过的了，所以这种方法会超时。</p>
<p>第二种思路：</p>
<p>如上面的分析，这种重复的情况可以用一个dp数组去存储第i天为分割点时，前i天的股票最大收益和后n-i+1天的最大收益，这样就不需要进行重复计算了，时间效率大大提高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size(), res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_dp(n), right_dp(n), left_max(n), right_max(n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从前往后遍历第一次卖得位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; left_dp[i<span class="number">-1</span>] &lt; prices[i])&#123;</span><br><span class="line">                left_max[i] = max(left_max[i<span class="number">-1</span>], prices[i]-left_dp[i<span class="number">-1</span>]);</span><br><span class="line">                left_dp[i] = left_dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span>)</span><br><span class="line">                    left_max[i] = left_max[i<span class="number">-1</span>];</span><br><span class="line">                left_dp[i] = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后往前遍历第二次买的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;n<span class="number">-1</span> &amp;&amp; right_dp[i+<span class="number">1</span>] &gt; prices[i])&#123;</span><br><span class="line">                right_max[i] = max(right_max[i+<span class="number">1</span>], right_dp[i+<span class="number">1</span>] - prices[i]);</span><br><span class="line">                right_dp[i] = right_dp[i+<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (i&lt;n<span class="number">-1</span>)</span><br><span class="line">                    right_max[i] = right_max[i+<span class="number">1</span>];</span><br><span class="line">                right_dp[i] = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据第一次卖得位置和第二次买的位置求得最佳的分割点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)&#123;</span><br><span class="line">            res = max(res, left_max[i]+right_max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/#/description" target="_blank" rel="noopener">188. Best Time to Buy and Sell Stock IV</a></h2><p><strong>题目大意</strong></p>
<p>最多k次交易，请问最大收益是多少。</p>
<p><strong>思路</strong></p>
<p>不会做。参考大神的思路，使用循环引用的动态规划。</p>
<p><code>must_sell[i][k]</code> 表示 第i天必须卖出且至多交易k次的最大收益。<br><code>global_max[i][k]</code> 表示 截止到第i天至多交易k次的最大收益。</p>
<p>状态转移方程：</p>
<p><code>must_sell[i][k] = max(global_max[i-1][k-1] + profit, must_sell[i-1][k] + profit)</code> </p>
<p>(第i天卖出且至多交易k次的最大收益为：前i-1天至多交易k-1次的最大收益 和 第i-1天必须卖出至多交易k次的最大收益 的较大值 加上第i天卖出的收益。）</p>
<p><code>global_max[i][k] = max(global_max[i-1][k], must_sell[i][k])</code> </p>
<p>(前i天至多交易k次的最大收益为：前i-1天至多交易k次的最大收益 和 第i天必须卖出至多交易k次的最大收益 的较大者。)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size(), res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当可以交易的次数足够多</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt; n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i!=n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[i<span class="number">-1</span>] &lt; prices[i])&#123;</span><br><span class="line">                    res+= prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// must_sell[i][k] 必须卖出prices[i]且交易次数最多是k的 最大收益</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; must_sell(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// global_sell[i][k] 进行到prices[i](不一定卖出)且交易次数最多是k的 最大收益</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; global_sell(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> profit = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> kk=<span class="number">1</span>; kk&lt;k+<span class="number">1</span>; ++kk)&#123;</span><br><span class="line">                must_sell[i][kk] = max(global_sell[i<span class="number">-1</span>][kk<span class="number">-1</span>] + profit, must_sell[i<span class="number">-1</span>][kk] + profit);</span><br><span class="line">                global_sell[i][kk] = max(global_sell[i<span class="number">-1</span>][kk], must_sell[i][kk]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global_sell[n<span class="number">-1</span>][k];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;c</span><br></pre></td></tr></table></figure>
<h2 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72.  Edit Distance"></a><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">72.  Edit Distance</a></h2><p><strong>题目大意</strong></p>
<p>计算两个字符串之间的编辑距离。word1通过删除、插入和替换三种操作变为word2，操作需要的次数即为编辑距离。</p>
<p><strong>思路</strong></p>
<p>动态规划</p>
<p><code>if str[i-1]==str[j-1]: dp[i][j] = dp[i-1][j-1]</code></p>
<p><code>if str[i-1]!=str[j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; ++i)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j], min(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/22/luong-attention/" rel="next" title="Effective Approaches to Attention-based Neural Machine Translation">
                <i class="fa fa-chevron-left"></i> Effective Approaches to Attention-based Neural Machine Translation
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/15/logistic-regression/" rel="prev" title="浅谈逻辑回归">
                浅谈逻辑回归 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://owxv9mpb2.bkt.clouddn.com/cyh.jpeg"
                alt="dannyw" />
            
              <p class="site-author-name" itemprop="name">dannyw</p>
              <p class="site-description motion-element" itemprop="description">wangliubupt@163.com</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LinkedList"><span class="nav-number">1.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#445-Add-Two-Numbers-II"><span class="nav-number">1.1.</span> <span class="nav-text">445. Add Two Numbers II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Add-Two-Numbers"><span class="nav-number">1.2.</span> <span class="nav-text">2.Add Two Numbers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-Remove-Nth-Node-From-End-of-List"><span class="nav-number">1.3.</span> <span class="nav-text">19.Remove Nth Node From End of List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-Reverse-Linked-List-II"><span class="nav-number">1.4.</span> <span class="nav-text">92.Reverse Linked List II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-Merge-Two-Sorted-Lists"><span class="nav-number">1.5.</span> <span class="nav-text">21.Merge Two Sorted Lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-Merge-k-Sorted-Lists"><span class="nav-number">1.6.</span> <span class="nav-text">23.Merge k Sorted Lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#138-Copy-List-with-Random-Pointer"><span class="nav-number">1.7.</span> <span class="nav-text">138.Copy List with Random Pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="nav-number">1.8.</span> <span class="nav-text">160.Intersection of Two Linked Lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-Linked-List-Cycle"><span class="nav-number">1.9.</span> <span class="nav-text">141.Linked List Cycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-Linked-List-Cycle-II"><span class="nav-number">1.10.</span> <span class="nav-text">142.Linked List Cycle II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#287-Find-the-Duplicate-Number"><span class="nav-number">1.11.</span> <span class="nav-text">287. Find the Duplicate Number</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BinaryTree"><span class="nav-number">2.</span> <span class="nav-text">BinaryTree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#572-Subtree-of-Another-Tree"><span class="nav-number">2.1.</span> <span class="nav-text">572.Subtree of Another Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal"><span class="nav-number">2.2.</span> <span class="nav-text">144.Binary Tree Preorder Traversal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#145-Binary-Tree-Postorder-Traversal"><span class="nav-number">2.3.</span> <span class="nav-text">145.Binary Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树路径和为某一值"><span class="nav-number">2.4.</span> <span class="nav-text">二叉树路径和为某一值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#112-Path-Sum"><span class="nav-number">2.4.1.</span> <span class="nav-text">112.Path Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-Path-Sum-II"><span class="nav-number">2.4.2.</span> <span class="nav-text">113.Path Sum II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#437-Path-Sum-III"><span class="nav-number">2.4.3.</span> <span class="nav-text">437. Path Sum III</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#255-Verify-Preorder-Sequence-in-Binary-Search-Tree"><span class="nav-number">2.5.</span> <span class="nav-text">255.Verify Preorder Sequence in Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-Flatten-Binary-Tree-to-Linked-List"><span class="nav-number">2.6.</span> <span class="nav-text">114.Flatten Binary Tree to Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树与双向链表"><span class="nav-number">2.7.</span> <span class="nav-text">二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="nav-number">2.8.</span> <span class="nav-text">104.Maximum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="nav-number">2.9.</span> <span class="nav-text">111.Minimum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#222-Count-Complete-Tree-Nodes"><span class="nav-number">2.10.</span> <span class="nav-text">222.Count Complete Tree Nodes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-number">2.11.</span> <span class="nav-text">236.Lowest Common Ancestor of a Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="nav-number">2.12.</span> <span class="nav-text">235.Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#124-Binary-Tree-Maximum-Path-Sum"><span class="nav-number">2.13.</span> <span class="nav-text">124.Binary Tree Maximum Path Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#root-child的最大路径和"><span class="nav-number">2.14.</span> <span class="nav-text">root-child的最大路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node"><span class="nav-number">2.15.</span> <span class="nav-text">116. Populating Next Right Pointers in Each Node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II"><span class="nav-number">2.16.</span> <span class="nav-text">117. Populating Next Right Pointers in Each Node II</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tree"><span class="nav-number">3.</span> <span class="nav-text">Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree"><span class="nav-number">3.1.</span> <span class="nav-text">208.Implement Trie (Prefix Tree)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node-1"><span class="nav-number">3.2.</span> <span class="nav-text">116. Populating Next Right Pointers in Each Node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-1"><span class="nav-number">3.3.</span> <span class="nav-text">117. Populating Next Right Pointers in Each Node II</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stack-amp-queue"><span class="nav-number">4.</span> <span class="nav-text">stack&amp;queue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#155-min-stack"><span class="nav-number">4.1.</span> <span class="nav-text">155.min stack</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dfs-amp-bfs"><span class="nav-number">5.</span> <span class="nav-text">Dfs&amp;bfs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#22-Generate-Parentheses"><span class="nav-number">5.1.</span> <span class="nav-text">22.Generate Parentheses</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-N-Queens"><span class="nav-number">5.2.</span> <span class="nav-text">51.  N-Queens</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-N-Queens-II"><span class="nav-number">5.3.</span> <span class="nav-text">52. N-Queens II</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#trick"><span class="nav-number">6.</span> <span class="nav-text">trick</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#54-Spiral-Matrix"><span class="nav-number">6.1.</span> <span class="nav-text">54.Spiral Matrix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-Majority-Element"><span class="nav-number">6.2.</span> <span class="nav-text">169.Majority Element</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#229-Majority-Element-II"><span class="nav-number">6.3.</span> <span class="nav-text">229.Majority Element II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#347-Top-K-Frequent-Elements"><span class="nav-number">6.4.</span> <span class="nav-text">347.Top K Frequent Elements</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-Kth-Largest-Element-in-an-Array"><span class="nav-number">6.5.</span> <span class="nav-text">215.Kth Largest Element in an Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#179-Largest-Number"><span class="nav-number">6.6.</span> <span class="nav-text">179.Largest Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#264-Ugly-Number-II"><span class="nav-number">6.7.</span> <span class="nav-text">264.Ugly Number II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#315-Count-of-Smaller-Numbers-After-Self"><span class="nav-number">6.8.</span> <span class="nav-text">315.Count of Smaller Numbers After Self</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组中的逆序对"><span class="nav-number">6.9.</span> <span class="nav-text">数组中的逆序对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">6.10.</span> <span class="nav-text">1.Two Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#191-Number-of-1-Bits"><span class="nav-number">6.11.</span> <span class="nav-text">191.Number of 1 Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#231-Power-of-Two"><span class="nav-number">6.12.</span> <span class="nav-text">231.Power of Two</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#326-Power-of-Three"><span class="nav-number">6.13.</span> <span class="nav-text">326.Power of Three</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#342-Power-of-Four"><span class="nav-number">6.14.</span> <span class="nav-text">342.Power of Four</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#523-Continuous-Subarray-Sum"><span class="nav-number">6.15.</span> <span class="nav-text">523.Continuous Subarray Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#135-Candy"><span class="nav-number">6.16.</span> <span class="nav-text">135.Candy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#骰子和概率"><span class="nav-number">6.17.</span> <span class="nav-text">骰子和概率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扑克牌的顺子"><span class="nav-number">6.18.</span> <span class="nav-text">扑克牌的顺子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73-Set-Matrix-Zeroes"><span class="nav-number">6.19.</span> <span class="nav-text">73.Set Matrix Zeroes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#239-Sliding-Window-Maximum"><span class="nav-number">6.20.</span> <span class="nav-text">239.Sliding Window Maximum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-number">6.21.</span> <span class="nav-text">152. Maximum Product Subarray</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#math"><span class="nav-number">7.</span> <span class="nav-text">math</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#233-Number-of-Digit-One"><span class="nav-number">7.1.</span> <span class="nav-text">233.Number of Digit One</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69-Sqrt-x"><span class="nav-number">7.2.</span> <span class="nav-text">69.Sqrt(x)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">7.3.</span> <span class="nav-text">50.Pow(x, n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#372-Super-Pow"><span class="nav-number">7.4.</span> <span class="nav-text">372.Super Pow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#约瑟夫环"><span class="nav-number">7.5.</span> <span class="nav-text">约瑟夫环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#382-Linked-List-Random-Node"><span class="nav-number">7.6.</span> <span class="nav-text">382.Linked List Random Node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-Divide-Two-Integers"><span class="nav-number">7.7.</span> <span class="nav-text">29. Divide Two Integers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两个数相除返回字符串形式"><span class="nav-number">7.8.</span> <span class="nav-text">两个数相除返回字符串形式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Search"><span class="nav-number">8.</span> <span class="nav-text">Binary Search</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#34-Search-for-a-Range"><span class="nav-number">8.1.</span> <span class="nav-text">34.Search for a Range</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array"><span class="nav-number">8.2.</span> <span class="nav-text">153.Find Minimum in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#154-Find-Minimum-in-Rotated-Sorted-Array-II"><span class="nav-number">8.3.</span> <span class="nav-text">154.Find Minimum in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#162-Find-Peak-Element"><span class="nav-number">8.4.</span> <span class="nav-text">162.Find Peak Element</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-Search-in-Rotated-Sorted-Array"><span class="nav-number">8.5.</span> <span class="nav-text">33.Search in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#81-Search-in-Rotated-Sorted-Array-II"><span class="nav-number">8.6.</span> <span class="nav-text">81.Search in Rotated Sorted Array II</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bit-Operation"><span class="nav-number">9.</span> <span class="nav-text">Bit Operation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#136-Single-Number"><span class="nav-number">9.1.</span> <span class="nav-text">136.Single Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#137-Single-Number-II"><span class="nav-number">9.2.</span> <span class="nav-text">137.Single Number II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#260-Single-Number-III"><span class="nav-number">9.3.</span> <span class="nav-text">260.Single Number III</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#string"><span class="nav-number">10.</span> <span class="nav-text">string</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#151-Reverse-Words-in-a-String"><span class="nav-number">10.1.</span> <span class="nav-text">151.Reverse Words in a String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#左旋转字符串"><span class="nav-number">10.2.</span> <span class="nav-text">左旋转字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DP"><span class="nav-number">11.</span> <span class="nav-text">DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最长公共子序列"><span class="nav-number">11.1.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最长公共子串"><span class="nav-number">11.2.</span> <span class="nav-text">最长公共子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-Coin-Change"><span class="nav-number">11.3.</span> <span class="nav-text">322.Coin Change</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-Unique-Paths"><span class="nav-number">11.4.</span> <span class="nav-text">62.Unique Paths</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum"><span class="nav-number">11.5.</span> <span class="nav-text">416.Partition Equal Subset Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#698-Partition-to-K-Equal-Sum-Subsets"><span class="nav-number">11.6.</span> <span class="nav-text">698.Partition to K Equal Sum Subsets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Longest-Palindromic-Substring"><span class="nav-number">11.7.</span> <span class="nav-text">5.Longest Palindromic Substring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-Longest-Increasing-Subsequence"><span class="nav-number">11.8.</span> <span class="nav-text">300.Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#674-Longest-Continuous-Increasing-Subsequence"><span class="nav-number">11.9.</span> <span class="nav-text">674.  Longest Continuous Increasing Subsequence</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-House-Robber"><span class="nav-number">11.10.</span> <span class="nav-text">198.House Robber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213-House-Robber-II"><span class="nav-number">11.11.</span> <span class="nav-text">213. House Robber II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#337-House-Robber-III"><span class="nav-number">11.12.</span> <span class="nav-text">337. House Robber III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">11.13.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-number">11.14.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="nav-number">11.15.</span> <span class="nav-text">123. Best Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#188-Best-Time-to-Buy-and-Sell-Stock-IV"><span class="nav-number">11.16.</span> <span class="nav-text">188. Best Time to Buy and Sell Stock IV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-Edit-Distance"><span class="nav-number">11.17.</span> <span class="nav-text">72.  Edit Distance</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dannyw</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>


<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  
  <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("bMsLV2gAIN9z6YVc8dtXr53l-gzGzoHsz", "y9oyCVpj2Vzlpi90XymKT7oJ");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = '0 ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
}); 
</script>
  

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("bMsLV2gAIN9z6YVc8dtXr53l-gzGzoHsz", "y9oyCVpj2Vzlpi90XymKT7oJ");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
